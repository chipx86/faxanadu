;============================================================================
; Faxanadu (U).nes
;
; PRG12 ($8000 - $bfff)
;============================================================================

    .segment "PRG12"
    .reloc

    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $00                               ; [2]:
    .byte $00                               ; [3]:
    .byte $00                               ; [4]:
    .byte $c0                               ; [5]:
    .byte $bf                               ; [6]:
    .byte $bf                               ; [7]:
    .byte $bf                               ; [8]:
    .byte $bf                               ; [9]:
    .byte $bf                               ; [10]:
    .byte $bf                               ; [11]:
    .byte $bf                               ; [12]:
    .byte $bf                               ; [13]:
    .byte $bf                               ; [14]:
    .byte $bf                               ; [15]:
    .byte $bf                               ; [16]:
    .byte $bf                               ; [17]:
    .byte $bf                               ; [18]:
    .byte $bf                               ; [19]:
    .byte $bf                               ; [20]:
    .byte $bf                               ; [21]:
    .byte $cf                               ; [22]:
    .byte $00                               ; [23]:
    .byte $00                               ; [24]:
    .byte $00                               ; [25]:
    .byte $00                               ; [26]:
    .byte $00                               ; [27]:
    .byte $c0                               ; [0]:
    .byte $bf                               ; [1]:
    .byte $bf                               ; [2]:
    .byte $bf                               ; [3]:
    .byte $bf                               ; [4]:
    .byte $ce                               ; [5]:
    .byte $00                               ; [6]:
    .byte $00                               ; [7]:
    .byte $00                               ; [8]:
    .byte $c8                               ; [9]:
    .byte $00                               ; [10]:
    .byte $00                               ; [11]:
    .byte $00                               ; [12]:
    .byte $be                               ; [13]:
    .byte $b9                               ; [14]:
    .byte $ac                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $00                               ; [18]:
    .byte $00                               ; [19]:
    .byte $bc                               ; [20]:
    .byte $00                               ; [21]:
    .byte $cd                               ; [22]:
    .byte $bf                               ; [23]:
    .byte $bf                               ; [24]:
    .byte $bf                               ; [25]:
    .byte $bf                               ; [26]:
    .byte $cf                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $c8                               ; [2]:
    .byte $00                               ; [3]:
    .byte $00                               ; [4]:
    .byte $00                               ; [5]:
    .byte $00                               ; [6]:
    .byte $bc                               ; [7]:
    .byte $cc                               ; [8]:
    .byte $00                               ; [9]:
    .byte $00                               ; [10]:
    .byte $c1                               ; [11]:
    .byte $c2                               ; [12]:
    .byte $00                               ; [13]:
    .byte $ab                               ; [14]:
    .byte $ac                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $bc                               ; [18]:
    .byte $00                               ; [19]:
    .byte $00                               ; [20]:
    .byte $00                               ; [21]:
    .byte $00                               ; [22]:
    .byte $00                               ; [23]:
    .byte $00                               ; [24]:
    .byte $00                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $02                               ; [3]:
    .byte $03                               ; [4]:
    .byte $00                               ; [5]:
    .byte $00                               ; [6]:
    .byte $00                               ; [7]:
    .byte $00                               ; [8]:
    .byte $00                               ; [9]:
    .byte $d0                               ; [10]:
    .byte $d1                               ; [11]:
    .byte $d2                               ; [12]:
    .byte $d0                               ; [13]:
    .byte $ab                               ; [14]:
    .byte $ac                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $c8                               ; [18]:
    .byte $00                               ; [19]:
    .byte $00                               ; [20]:
    .byte $c8                               ; [21]:
    .byte $00                               ; [22]:
    .byte $00                               ; [23]:
    .byte $9d                               ; [24]:
    .byte $9e                               ; [25]:
    .byte $9f                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $10                               ; [1]:
    .byte $11                               ; [2]:
    .byte $12                               ; [3]:
    .byte $13                               ; [4]:
    .byte $14                               ; [5]:
    .byte $15                               ; [6]:
    .byte $bc                               ; [7]:
    .byte $00                               ; [8]:
    .byte $d0                               ; [9]:
    .byte $b5                               ; [10]:
    .byte $b6                               ; [11]:
    .byte $b7                               ; [12]:
    .byte $b8                               ; [13]:
    .byte $b6                               ; [14]:
    .byte $b8                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $00                               ; [18]:
    .byte $c8                               ; [19]:
    .byte $00                               ; [20]:
    .byte $9c                               ; [21]:
    .byte $a0                               ; [22]:
    .byte $a1                               ; [23]:
    .byte $a2                               ; [24]:
    .byte $a3                               ; [25]:
    .byte $a4                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $20                               ; [1]:
    .byte $21                               ; [2]:
    .byte $22                               ; [3]:
    .byte $23                               ; [4]:
    .byte $24                               ; [5]:
    .byte $25                               ; [6]:
    .byte $26                               ; [7]:
    .byte $27                               ; [8]:
    .byte $c9                               ; [9]:
    .byte $ca                               ; [10]:
    .byte $c9                               ; [11]:
    .byte $ca                               ; [12]:
    .byte $ca                               ; [13]:
    .byte $ca                               ; [14]:
    .byte $ca                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $bc                               ; [18]:
    .byte $2a                               ; [19]:
    .byte $2b                               ; [20]:
    .byte $a5                               ; [21]:
    .byte $a6                               ; [22]:
    .byte $a7                               ; [23]:
    .byte $a8                               ; [24]:
    .byte $a9                               ; [25]:
    .byte $aa                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $30                               ; [1]:
    .byte $31                               ; [2]:
    .byte $32                               ; [3]:
    .byte $33                               ; [4]:
    .byte $34                               ; [5]:
    .byte $35                               ; [6]:
    .byte $36                               ; [7]:
    .byte $37                               ; [8]:
    .byte $38                               ; [9]:
    .byte $39                               ; [10]:
    .byte $ad                               ; [11]:
    .byte $ad                               ; [12]:
    .byte $ae                               ; [13]:
    .byte $ad                               ; [14]:
    .byte $3e                               ; [15]:
    .byte $3f                               ; [16]:
    .byte $04                               ; [17]:
    .byte $05                               ; [18]:
    .byte $06                               ; [19]:
    .byte $07                               ; [20]:
    .byte $08                               ; [21]:
    .byte $09                               ; [22]:
    .byte $0a                               ; [23]:
    .byte $00                               ; [24]:
    .byte $0b                               ; [25]:
    .byte $0c                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $00                               ; [2]:
    .byte $42                               ; [3]:
    .byte $43                               ; [4]:
    .byte $44                               ; [5]:
    .byte $45                               ; [6]:
    .byte $46                               ; [7]:
    .byte $47                               ; [8]:
    .byte $48                               ; [9]:
    .byte $49                               ; [10]:
    .byte $4a                               ; [11]:
    .byte $4b                               ; [12]:
    .byte $4c                               ; [13]:
    .byte $4d                               ; [14]:
    .byte $4e                               ; [15]:
    .byte $4f                               ; [16]:
    .byte $0d                               ; [17]:
    .byte $0e                               ; [18]:
    .byte $0f                               ; [19]:
    .byte $16                               ; [20]:
    .byte $17                               ; [21]:
    .byte $18                               ; [22]:
    .byte $19                               ; [23]:
    .byte $1a                               ; [24]:
    .byte $1b                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $00                               ; [2]:
    .byte $52                               ; [3]:
    .byte $53                               ; [4]:
    .byte $54                               ; [5]:
    .byte $55                               ; [6]:
    .byte $56                               ; [7]:
    .byte $57                               ; [8]:
    .byte $58                               ; [9]:
    .byte $59                               ; [10]:
    .byte $5a                               ; [11]:
    .byte $5b                               ; [12]:
    .byte $5c                               ; [13]:
    .byte $5d                               ; [14]:
    .byte $5e                               ; [15]:
    .byte $5f                               ; [16]:
    .byte $1d                               ; [17]:
    .byte $1e                               ; [18]:
    .byte $1f                               ; [19]:
    .byte $28                               ; [20]:
    .byte $29                               ; [21]:
    .byte $2c                               ; [22]:
    .byte $2d                               ; [23]:
    .byte $2e                               ; [24]:
    .byte $2f                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $bc                               ; [2]:
    .byte $62                               ; [3]:
    .byte $63                               ; [4]:
    .byte $64                               ; [5]:
    .byte $65                               ; [6]:
    .byte $66                               ; [7]:
    .byte $67                               ; [8]:
    .byte $68                               ; [9]:
    .byte $69                               ; [10]:
    .byte $6a                               ; [11]:
    .byte $6b                               ; [12]:
    .byte $6c                               ; [13]:
    .byte $6d                               ; [14]:
    .byte $6e                               ; [15]:
    .byte $6f                               ; [16]:
    .byte $3a                               ; [17]:
    .byte $3b                               ; [18]:
    .byte $3c                               ; [19]:
    .byte $3d                               ; [20]:
    .byte $40                               ; [21]:
    .byte $41                               ; [22]:
    .byte $50                               ; [23]:
    .byte $51                               ; [24]:
    .byte $60                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $00                               ; [2]:
    .byte $72                               ; [3]:
    .byte $73                               ; [4]:
    .byte $74                               ; [5]:
    .byte $75                               ; [6]:
    .byte $76                               ; [7]:
    .byte $77                               ; [8]:
    .byte $78                               ; [9]:
    .byte $79                               ; [10]:
    .byte $7a                               ; [11]:
    .byte $7b                               ; [12]:
    .byte $7c                               ; [13]:
    .byte $7d                               ; [14]:
    .byte $7e                               ; [15]:
    .byte $7f                               ; [16]:
    .byte $61                               ; [17]:
    .byte $70                               ; [18]:
    .byte $71                               ; [19]:
    .byte $80                               ; [20]:
    .byte $90                               ; [21]:
    .byte $91                               ; [22]:
    .byte $92                               ; [23]:
    .byte $93                               ; [24]:
    .byte $00                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $00                               ; [1]:
    .byte $81                               ; [2]:
    .byte $82                               ; [3]:
    .byte $83                               ; [4]:
    .byte $84                               ; [5]:
    .byte $85                               ; [6]:
    .byte $86                               ; [7]:
    .byte $83                               ; [8]:
    .byte $88                               ; [9]:
    .byte $89                               ; [10]:
    .byte $83                               ; [11]:
    .byte $8b                               ; [12]:
    .byte $8c                               ; [13]:
    .byte $8d                               ; [14]:
    .byte $8e                               ; [15]:
    .byte $8f                               ; [16]:
    .byte $94                               ; [17]:
    .byte $95                               ; [18]:
    .byte $96                               ; [19]:
    .byte $97                               ; [20]:
    .byte $98                               ; [21]:
    .byte $83                               ; [22]:
    .byte $9a                               ; [23]:
    .byte $9b                               ; [24]:
    .byte $f3                               ; [25]:
    .byte $ec                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $bc                               ; [1]:
    .byte $00                               ; [2]:
    .byte $00                               ; [3]:
    .byte $bc                               ; [4]:
    .byte $bc                               ; [5]:
    .byte $bc                               ; [6]:
    .byte $00                               ; [7]:
    .byte $c1                               ; [8]:
    .byte $d3                               ; [9]:
    .byte $00                               ; [10]:
    .byte $00                               ; [11]:
    .byte $00                               ; [12]:
    .byte $00                               ; [13]:
    .byte $c4                               ; [14]:
    .byte $c5                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $00                               ; [18]:
    .byte $00                               ; [19]:
    .byte $00                               ; [20]:
    .byte $00                               ; [21]:
    .byte $00                               ; [22]:
    .byte $00                               ; [23]:
    .byte $00                               ; [24]:
    .byte $bc                               ; [25]:
    .byte $00                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cb                               ; [0]:
    .byte $bb                               ; [1]:
    .byte $d3                               ; [2]:
    .byte $d3                               ; [3]:
    .byte $c6                               ; [4]:
    .byte $c7                               ; [5]:
    .byte $cf                               ; [6]:
    .byte $d0                               ; [7]:
    .byte $d1                               ; [8]:
    .byte $b7                               ; [9]:
    .byte $b8                               ; [10]:
    .byte $00                               ; [11]:
    .byte $c8                               ; [12]:
    .byte $00                               ; [13]:
    .byte $d4                               ; [14]:
    .byte $b1                               ; [15]:
    .byte $b3                               ; [16]:
    .byte $b4                               ; [17]:
    .byte $c8                               ; [18]:
    .byte $00                               ; [19]:
    .byte $c1                               ; [20]:
    .byte $d3                               ; [21]:
    .byte $00                               ; [22]:
    .byte $00                               ; [23]:
    .byte $d2                               ; [24]:
    .byte $d3                               ; [25]:
    .byte $c6                               ; [26]:
    .byte $cb                               ; [27]:
    .byte $cd                               ; [0]:
    .byte $bf                               ; [1]:
    .byte $bf                               ; [2]:
    .byte $bf                               ; [3]:
    .byte $cf                               ; [4]:
    .byte $af                               ; [5]:
    .byte $bf                               ; [6]:
    .byte $b0                               ; [7]:
    .byte $b0                               ; [8]:
    .byte $af                               ; [9]:
    .byte $bf                               ; [10]:
    .byte $cf                               ; [11]:
    .byte $c6                               ; [12]:
    .byte $c7                               ; [13]:
    .byte $99                               ; [14]:
    .byte $8a                               ; [15]:
    .byte $87                               ; [16]:
    .byte $c3                               ; [17]:
    .byte $bb                               ; [18]:
    .byte $d0                               ; [19]:
    .byte $d1                               ; [20]:
    .byte $b7                               ; [21]:
    .byte $b8                               ; [22]:
    .byte $c0                               ; [23]:
    .byte $bf                               ; [24]:
    .byte $bf                               ; [25]:
    .byte $bf                               ; [26]:
    .byte $ce                               ; [27]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $00                               ; [2]:
    .byte $00                               ; [3]:
    .byte $cd                               ; [4]:
    .byte $bf                               ; [5]:
    .byte $bf                               ; [6]:
    .byte $bf                               ; [7]:
    .byte $bf                               ; [8]:
    .byte $bf                               ; [9]:
    .byte $bf                               ; [10]:
    .byte $bd                               ; [11]:
    .byte $af                               ; [12]:
    .byte $b2                               ; [13]:
    .byte $b2                               ; [14]:
    .byte $b0                               ; [15]:
    .byte $bd                               ; [16]:
    .byte $af                               ; [17]:
    .byte $bf                               ; [18]:
    .byte $b0                               ; [19]:
    .byte $bf                               ; [20]:
    .byte $af                               ; [21]:
    .byte $bf                               ; [22]:
    .byte $ce                               ; [23]:
    .byte $00                               ; [24]:
    .byte $00                               ; [25]:
    .byte $00                               ; [26]:
    .byte $00                               ; [27]:


;============================================================================
; Set the textbox coordinates and dimensions for an NPC.
;
; The textbox will always be set at:
;
;     X = 10
;     Width = 20
;     Height = 8
;
; If there's a portrait, or the player is high up on the screen:
;
;     Y = 16
;
; Otherwise, if the player is on the ground:
;
;     Y = 6
;
; INPUTS:
;     Player_PosY:
;         The Y position for the player.
;
;     Temp_0201:
;         The loaded IScript portrait ID.
;
; OUTPUTS:
;     TextBox_X:
;         The new X position of the textbox.
;
;     TextBox_Y:
;         The new Y position of the textbox.
;
;     TextBox_Width:
;         The new width of the textbox.
;
;     TextBox_Height:
;         The new height of the textbox.
;
; XREFS:
;     IScripts_CloseCurrentTextBox
;     TextBox_OpenForNPC
;============================================================================
TextBox_SetCoordsForNPC:                    ; [$81c0]
    LDA #$0a
    STA a:TextBox_X                         ; Textbox X = 10
    LDA #$14
    STA a:TextBox_Width                     ; Textbox width = 20
    LDA #$08
    STA a:TextBox_Height                    ; Textbox height = 8


    ;
    ; Check if there's a portrait shown.
    ;
    LDA a:Temp_0201                         ; Load the portrait ID from the
                                            ; IScript.
    BMI @_hasPortrait                       ; If set, jump.


    ;
    ; There's no portrait. Set it based on the player's Y position.
    ;
    ; If the player is around the ground area, set it at Y = 6.
    ;
    ; If the player is higher up on the screen, move it downward to
    ; Y = 16 (same as the portrait).
    ;
    LDY #$06                                ; Textbox Y = 6
    LDA Player_PosY                         ; Check the player's Y position.
    CMP #$40                                ; Is it >= 64?
    BCS @_setYAndReturn                     ; If so, jump to return.

  @_hasPortrait:                            ; [$81dc]
    LDY #$10                                ; Textbox Y = 16

  @_setYAndReturn:                          ; [$81de]
    STY a:TextBox_Y                         ; Set the textbox Y position.
    RTS


;============================================================================
; Open a textbox for NPC dialogue.
;
; This positions the textbox and fills it with temporary
; placeholder text in preparation for drawing the NPC's
; message text.
;
; INPUTS:
;     See falls through.
;
; OUTPUTS:
;     See falls through.
;
; CALLS:
;     TextBox_SetCoordsForNPC
;     TextBox_Open
;
; FALLS THROUGH:
;     IScripts_PositionAndFillPlaceholderText
;
; XREFS:
;     IScriptAction_ShowSellMenu
;     IScripts_Begin
;     Maybe_Shop_DrawTextBox
;============================================================================
TextBox_OpenForNPC:                         ; [$81e2]
    JSR TextBox_SetCoordsForNPC             ; Set textbox coordinates for an
                                            ; NPC dialogue.
    JSR TextBox_Open                        ; Open the textbox.

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Position the text X/Y position in a textbox and fill with placeholder text.
;
; This is done in preparation for clearing out a textbox and
; removing it from the screen.
;
; INPUTS:
;     TextBox_X:
;         The textbox X position.
;
;     TextBox_Y:
;         The textbox Y position.
;
; OUTPUTS:
;     TextBox_ContentsX:
;         The text X position.
;
;     TextBox_ContentsY:
;         The text Y position.
;
; CALLS:
;     IScripts_FillPlaceholderText
;
; XREFS:
;     IScriptAction_AddInventoryItem
;     IScriptAction_ShowQuestionMessage
;============================================================================
IScripts_PositionAndFillPlaceholderText:    ; [$81e8]
    ;
    ; Set the X position for text within the textbox.
    ;
    LDA a:TextBox_X                         ; Load the textbox X.
    CLC
    ADC #$02                                ; Add 2.
    STA TextBox_ContentsX                   ; Set as the text draw X
                                            ; position.


    ;
    ; Set the Y position for text within the textbox.
    ;
    LDA a:TextBox_Y                         ; Load the textbox Y.
    CLC
    ADC #$02                                ; Add 2.
    STA TextBox_ContentsY                   ; Set as the text draw Y
                                            ; position.


    ;
    ; Fill with placeholder text.
    ;
    JMP IScripts_FillPlaceholderText        ; Fill the textbox.


;============================================================================
; Close the opened textbox for the IScript.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     TextBox_Close
;     TextBox_SetCoordsForNPC
;
; XREFS:
;     IScriptAction_EndScript
;============================================================================
IScripts_CloseCurrentTextBox:               ; [$81fb]
    JSR TextBox_SetCoordsForNPC             ; Set textbox coordinates for an
                                            ; NPC dialogue.
    JMP TextBox_Close                       ; Close the textbox.


;============================================================================
; Set the textbox coordinates for a portrait.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TextBox_X:
;         The new X coordinate.
;
;     TextBox_Y:
;         The new Y coordinate.
;
;     TextBox_Width:
;         The new width.
;
;     TextBox_Height:
;         The new height.
;
; XREFS:
;     DEADCODE_TextBox_ClosePortrait
;     IScripts_OpenForPortrait
;============================================================================
TextBox_SetCoordsForPortrait:               ; [$8201]
    LDA #$02
    STA a:TextBox_X                         ; X = 2
    LDA #$0e
    STA a:TextBox_Y                         ; Y = 14
    LDA #$08
    STA a:TextBox_Width                     ; Width = 8
    LDA #$0a
    STA a:TextBox_Height                    ; Height = 10
    RTS


;============================================================================
; Set the sprite X, Y position to the interior of the portrait frame.
;
; This position is relative to the top of the playable screen (below
; the HUD).
;
; INPUTS:
;     None
;
; OUTPUTS:
;     Arg_DrawSprite_PosX:
;         The X position to draw into (0x18)
;
;     Arg_DrawSprite_PosY:
;         The Y position to draw into (0x58)
;
; XREFS:
;     IScripts_UpdatePortraitAnimation
;============================================================================
IScripts_SetPortraitSpriteXY:               ; [$8216]
    LDX #$18
    STX Arg_DrawSprite_PosX                 ; Draw X = 24
    LDX #$58
    STX Arg_DrawSprite_PosY                 ; Draw Y = 88
    RTS


;============================================================================
; Open a textbox frame for a portrait.
;
; This positions the textbox at the position and size
; for a portrait in preparation for drawing the portrait
; picture.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     TextBox_SetCoordsForNPC
;     TextBox_SetCoordsForPortrait
;
; XREFS:
;     IScripts_Begin
;============================================================================
IScripts_OpenForPortrait:                   ; [$821f]
    JSR TextBox_SetCoordsForPortrait        ; Set textbox coordinates for the
                                            ; portrait.
    JMP TextBox_Open                        ; Open the textbox.

;============================================================================
; TODO: Document DEADCODE_TextBox_ClosePortrait
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;============================================================================
DEADCODE_TextBox_ClosePortrait:             ; [$8225]
    JSR TextBox_SetCoordsForPortrait
    JMP TextBox_Close


;============================================================================
; Close the textbox for both the portrait and textbox.
;
; This effectively closes both textboxes on the screen at
; once by taking the entire dimensions of both and replacing
; them with the screen's tiles.
;
; Based on the DEADCODE function above, this used to be split
; into portrait-specific and dialogue-specific textbox closing
; logic, but they likely determined this was faster or cheaper.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TextBox_X:
;     TextBox_Y:
;     TextBox_Width:
;     TextBox_Height:
;         Clobbered.
;
; CALLS:
;     TextBox_Close
;
; XREFS:
;     IScriptAction_EndScript
;============================================================================
TextBox_ClearForPortraitAndText:            ; [$822b]
    LDA #$02
    STA a:TextBox_X                         ; X = 2
    LDA #$08
    STA a:TextBox_Y                         ; Y = 8
    LDA #$1e
    STA a:TextBox_Width                     ; Width = 30
    LDA #$14
    STA a:TextBox_Height                    ; Height = 20
    JMP TextBox_Close                       ; Close the textbox.


;============================================================================
; Begin running an IScript.
;
; This will start loading the IScript to run. Based on
; that script, this may display a portrait for an entity.
;
; Once loaded, a text window will be shown and the first
; action of the script will be executed.
;
; INPUTS:
;     A:
;         The entrypoint offset of the IScript to run.
;
;     ISCRIPT_ADDRS_U:
;     ISCRIPT_ADDRS_L:
;         The lookup table of IScript entrypoints.
;
; OUTPUTS:
;     IScriptOrCHRAddr:
;     IScriptOrCHRAddr+1:
;         The read address for the IScript.
;
;     Temp_0201:
;         The entity ID of the IScript, for portrait
;         display.
;
;     Temp_0200:
;         The IScript entrypoint index.
;
;     IScriptOffset:
;         The byte offset into the script.
;
; CALLS:
;     IScripts_LoadPortraitTiles
;     IScripts_OpenForPortrait
;     TextBox_OpenForNPC
;     IScripts_LoadByte
;
; XREFS:
;     Player_CheckHandlePressUpOnNPC
;     Game_UnlockDoorWithUsableItem
;     Player_PickUpBattleHelmet
;     Player_PickUpBattleSuit
;     Player_PickUpBlackOnyx
;     Player_PickUpDragonSlayer
;     Player_PickUpElixir
;     Player_PickUpGlove
;     Player_PickUpHourGlass
;     Player_PickUpMattock
;     Player_PickUpOintment
;     Player_PickUpRedPotion
;     Player_PickUpWingBoots
;     Player_UseHourGlass
;     Player_UseMattock
;     Player_UseRedPotion
;     Player_UseWingBoots
;============================================================================
IScripts_Begin:                             ; [$8242]
    ;
    ; If this is 0xFF, map to the "Remember Your Mantra."
    ;
    CMP #$ff                                ; Compare the start offset to
                                            ; 0xFF.
    BNE @_loadScript                        ; If equal, jump.
    LDA #$1f                                ; Set the start offset to 0x1F.


    ;
    ; Load the script address from the table.
    ;
  @_loadScript:                             ; [$8248]
    STA a:Temp_0200                         ; Store the index temporarily.
    TAX                                     ; X = A
    LDA ISCRIPT_ADDRS_L,X                   ; Load the lower byte of the
                                            ; IScript address.
    STA IScriptOrCHRAddr                    ; Store as the lower byte.
    LDA ISCRIPT_ADDRS_U,X                   ; Load the upper byte of the
                                            ; IScript address.
    STA IScriptOrCHRAddr_U                  ; Store as the upper byte.
    LDY #$00                                ; Y = 0 (start offset in the
                                            ; script).
    LDA (IScriptOrCHRAddr),Y                ; Load the first byte of the
                                            ; script (portrait ID).
    STA a:Temp_0201                         ; Store it for the duration of
                                            ; the script.
    BPL @_continueScript                    ; If not a portrait ID, jump.


    ;
    ; Begin showing the portrait information.
    ;
    AND #$7f                                ; Keep the portrait ID bits.
    JSR IScripts_LoadPortraitTiles          ; Draw the portrait image.
    JSR IScripts_OpenForPortrait            ; Draw the portrait frame.

  @_continueScript:                         ; [$8267]
    JSR TextBox_OpenForNPC                  ; Open the text window.
    LDA #$01
    STA IScriptOffset                       ; Set IScript offset to 1.

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Invoke the next action listed in an IScript.
;
; This will load the action byte, look up the action
; handler, and then run it. The handler will be
; responsible for loading any further bytes and
; advancing the script.
;
; INPUTS:
;     IScriptActions_U:
;     IScriptActions_L:
;         Address table for the IScript action handlers.
;
; OUTPUTS:
;     A:
;         Address of the handler, pushed to the stack.
;
; CALLS:
;     IScripts_LoadByte
;
; XREFS:
;     IScriptAction_AddGold
;     IScriptAction_AddInventoryItem
;     IScriptAction_ConsumeItem
;     IScriptAction_OpenShop
;     IScriptAction_SetQuestComplete
;     IScriptAction_SetSpawnPoint
;     IScriptAction_ShowMessage
;     IScriptAction_ShowPassword
;     IScriptAction_ShowQuestionMessage
;     IScriptAction_ShowSellMenu
;     IScriptAction_ShowUnskippableMessage
;     IScriptAction_SpendGold
;     IScripts_JumpToNextAddr
;     IScripts_SkipAddrAndInvoke
;     thunk_IScripts_InvokeNextAction
;============================================================================
IScripts_InvokeNextAction:                  ; [$826e]
    JSR IScripts_LoadByte                   ; Load the script ID
    TAX                                     ; Store the byte in X and load
                                            ; from the offset table.
    LDA IScriptActions_U,X                  ; Fetch the upper script offset
    PHA                                     ; Push the upper offset to the
                                            ; stack
    LDA IScriptActions_L,X                  ; Fetch the lower script offset
    PHA                                     ; Push the lower offset to the
                                            ; stack
    RTS


;============================================================================
; Addresses for the IScript action handlers.
;
; XREFS:
;     IScripts_InvokeNextAction
;============================================================================

;
; XREFS:
;     IScripts_InvokeNextAction
;
IScriptActions_L:                           ; [$827b]
    .byte $b3                               ; [0]: End Script action

;
; XREFS:
;     IScripts_InvokeNextAction
;
IScriptActions_L_1_:                        ; [$827c]
    .byte $c4                               ; [1]: Show Unskippable Message
                                            ; action
    .byte $ee                               ; [2]: Show Question Message
                                            ; action
    .byte $d8                               ; [3]: Show Message action
    .byte $25                               ; [4]: Check/Update Player Title
                                            ; action
    .byte $5a                               ; [5]: Spend Gold action
    .byte $90                               ; [6]: Set Spawn Point action
    .byte $9e                               ; [7]: Add Inventory Item action
    .byte $d7                               ; [8]: Open Shop action
    .byte $24                               ; [9]: Add Gold action
    .byte $7f                               ; [10]: Add MP action
    .byte $d0                               ; [11]: If Quest Completed action
    .byte $f5                               ; [12]: If Player Has Title
                                            ; action
    .byte $1e                               ; [13]: If Player Has Gold action
    .byte $e5                               ; [14]: Set Quest Complete action
    .byte $2f                               ; [15]: Show Buy/Sell Menu action
    .byte $56                               ; [16]: Consume Item action
    .byte $5f                               ; [17]: Show Sell Menu action
    .byte $17                               ; [18]: If Player Has Item action
    .byte $ae                               ; [19]: Add HP action
    .byte $36                               ; [20]: Show Password action
    .byte $ad                               ; [21]: Finish Game action
    .byte $07                               ; [22]: Show Message and If
                                            ; Dismissed action
    .byte $aa                               ; [23]: Jump To Script Address
                                            ; action

;
; XREFS:
;     IScripts_InvokeNextAction
;
IScriptActions_U:                           ; [$8293]
    .byte $82                               ; [0]: End Script action

;
; XREFS:
;     IScripts_InvokeNextAction
;
IScriptActions_U_1_:                        ; [$8294]
    .byte $82                               ; [1]: Show Unskippable Message
                                            ; action
    .byte $82                               ; [2]: Show Question Message
                                            ; action
    .byte $82                               ; [3]: Show Message action
    .byte $87                               ; [4]: Check/Update Player Title
                                            ; action
    .byte $83                               ; [5]: Spend Gold action
    .byte $83                               ; [6]: Set Spawn Point action
    .byte $83                               ; [7]: Add Inventory Item action
    .byte $83                               ; [8]: Open Shop action
    .byte $85                               ; [9]: Add Gold action
    .byte $85                               ; [10]: Add MP action
    .byte $85                               ; [11]: If Quest Completed action
    .byte $85                               ; [12]: If Player Has Title
                                            ; action
    .byte $86                               ; [13]: If Player Has Gold action
    .byte $85                               ; [14]: Set Quest Complete action
    .byte $86                               ; [15]: Show Buy/Sell Menu action
    .byte $86                               ; [16]: Consume Item action
    .byte $86                               ; [17]: Show Sell Menu action
    .byte $87                               ; [18]: If Player Has Item action
    .byte $85                               ; [19]: Add HP action
    .byte $87                               ; [20]: Show Password action
    .byte $82                               ; [21]: Finish Game action
    .byte $83                               ; [22]: Show Message and If
                                            ; Dismissed action
    .byte $82                               ; [23]: Jump To Script Address
                                            ; action


;============================================================================
; IScript Action $17: Jump to Address
;
; This will immediately jump to the specified address.
;
; Script Parameters:
;
;     1. Jump address (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::8292]
;============================================================================
IScriptAction_Jump:                         ; [$82ab]
    JMP IScripts_JumpToNextAddr             ; Jump to the next address
                                            ; specified in the script.


;============================================================================
; IScript Action $15: Finish Game
;
; This will immediately finish the game, showing
; the outro screen and victory music.
;
; Script Parameters:
;     None.
;
; XREFS:
;     IScriptActions_L [$PRG12::8290]
;============================================================================
IScriptAction_FinishGame:                   ; [$82ae]
    JSR SplashAnimation_RunOutro            ; Show the outro animation.
    JMP Game_Init                           ; Re-initialize the game.


;============================================================================
; IScript Action $00: End Script
;
; This will close the textbox, if one is opened, and
; finish processing the script.
;
; Script Parameters:
;     None.
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_ShowBuySellMenu
;     IScriptAction_ShowMessage
;     IScriptAction_ShowQuestionMessage
;     IScriptAction_ShowSellMenu
;     IScriptActions_L [$PRG12::827b]
;     IScripts_ShowFinalMessage
;============================================================================
IScriptAction_EndScript:                    ; [$82b4]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    LDA a:Temp_0201                         ; Load the portrait ID.
    BPL @_noPortrait                        ; If a portrait ID is not set,
                                            ; jump.
    JSR IScripts_ClearPortraitImage         ; Clear the portrait image.
    JMP TextBox_ClearForPortraitAndText     ; Clear the portrait frame.

  @_noPortrait:                             ; [$82c2]
    JMP IScripts_CloseCurrentTextBox        ; Clear the current textbox.


;============================================================================
; IScript Action $01: Show Unskippable Message
;
; Displays a message in a text box, with an optional
; portrait depending on the script's Entity ID.
;
; This message cannot be skipped by pressing the B
; button. It's used for important messages, like the
; game's intro.
;
; Script Parameters:
;
;     1. Message ID (1 byte)
;
; XREFS:
;     IScriptActions_L [$PRG12::827c]
;============================================================================
IScriptAction_ShowUnskippableMessage:       ; [$82c5]
    ;
    ; Load the message to display.
    ;
    JSR IScripts_LoadByte                   ; Load the next byte as the
                                            ; message ID.
    JSR Messages_Load                       ; Load the message.


    ;
    ; Draw the characters one-by-one until the message is done.
    ;
  @_loop:                                   ; [$82cb]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_ShowNextChar                ; Draw the next character in the
                                            ; textbox.
    JSR TextBox_CheckShouldContinue         ; Check if the message should
                                            ; continue.
    BCC @_loop                              ; If so, loop.


    ;
    ; Done showing the textbox. Invoke the next action.
    ;
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; IScript Action $03: Show Message
;
; Displays a message in a text box, with an optional
; portrait depending on the script's Entity ID.
;
; This message can be skipped at any point by pressing
; the B button.
;
; Script Parameters:
;
;     1. Message ID (1 byte)
;
; XREFS:
;     IScriptActions_L [$PRG12::827e]
;============================================================================
IScriptAction_ShowMessage:                  ; [$82d9]
    ;
    ; Load the message to display.
    ;
    JSR IScripts_LoadByte                   ; Load the next byte as the
                                            ; message ID.
    JSR Messages_Load                       ; Load the message.


    ;
    ; Draw the characters one-by-one until the message is done.
    ;
  @_loop:                                   ; [$82df]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_ShowNextChar                ; Draw the next character in the
                                            ; textbox.
    JSR TextBox_CheckShouldContinueOrDismissMessage ; Check if the message is
                                                    ; done or continued.
    BCS IScriptAction_EndScript             ; If dismissed, end the script.
    BNE @_loop                              ; If not done, loop.


    ;
    ; Done showing the textbox. Invoke the next action.
    ;
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; IScript Action $02: Show Question Message
;
; Tihs displays a message in a text box, with an
; optional portrait depending on the script's Entity ID.
;
; The message will terminate with a flashing "?" at the
; bottom-center of the dialogue, indicating a question
; for the player.
;
; This message can be skipped at any point by pressing
; the B button.
;
; Script Parameters:
;
;     1. Message ID (1 byte)
;
; XREFS:
;     IScriptActions_L [$PRG12::827d]
;============================================================================
IScriptAction_ShowQuestionMessage:          ; [$82ef]
    JSR IScripts_LoadByte                   ; Load the message ID parameer.
    JSR Messages_Load                       ; Load the message string.

  @_messageLoop:                            ; [$82f5]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_ShowNextChar                ; Show the next character in the
                                            ; textbox.
    JSR TextBox_CheckShouldContinueOrDismissQuestion ; Check whether to
                                                     ; continue or dismiss.
    BCS IScriptAction_EndScript             ; If dismissed, end the script.
    BNE @_messageLoop                       ; Else, if message text remains,
                                            ; loop.


    ;
    ; The message finished. Fill up the textbox with hidden
    ; placeholder text and move on to the next action.
    ;
    JSR IScripts_PositionAndFillPlaceholderText
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; IScript Action $16: Show Question Message then Check If Completed
;
; Tihs displays a message in a text box, with an
; optional portrait depending on the script's Entity ID.
;
; This message can be skipped at any point by pressing
; the B button.
;
; If the message is dismissed, continue on with the script.
;
; If the message completed, load the next address parameter
; and jump to it.
;
; This is not used in the shipped game.
;
; Script Parameters:
;
;     1. Message ID (1 byte)
;     2. Jump Address if Completed (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::8291]
;============================================================================
IScriptAction_ShowQuestionMessageCheckIfDismissed: ; [$8308]
    JSR IScripts_LoadByte                   ; Load the message ID parameer.
    JSR Messages_Load                       ; Load the message string.

  @_messageLoop:                            ; [$830e]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_ShowNextChar                ; Show the next character in the
                                            ; textbox.
    JSR TextBox_CheckShouldContinueOrDismissQuestion ; Check whether to
                                                     ; continue or dismiss.
    BCS @_messageDismissed                  ; If dismissed, jump to continue
                                            ; this script.
    BNE @_messageLoop                       ; Else, if message text remains,
                                            ; loop.


    ;
    ; The message finished. Load the next parameter as an
    ; address and jump to it.
    ;
    JMP IScripts_JumpToNextAddr             ; Else, if completed, jump to the
                                            ; next address specified in the
                                            ; script.


    ;
    ; The message was dismissed. Move on to the next action in
    ; this script.
    ;
  @_messageDismissed:                       ; [$831e]
    JMP IScripts_SkipAddrAndInvoke          ; Invoke the next action in the
                                            ; script.


;============================================================================
; Progressively subtract gold from the player.
;
; This will subtract the code, animating the reduction
; of gold from the status screen.
;
; 10 gold will be subtracted at a time from the player.
; The values passed in will be used as a separate counter
; for how much gold is remaining to subtract.
;
; INPUTS:
;     Temp_0203:
;         Lower byte of the gold amount to subtract.
;
;     Temp_0203:
;         Upper byte of the gold amount to subtract.
;
; OUTPUTS:
;     Temp_Int24:
;     Temp_Int24+1:
;     Temp_0202:
;     Temp_0203:
;         Clobbered.
;
; CALLS:
;     IScripts_UpdatePortraitAnimation
;     Player_SubtractGold
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_SpendGold
;     IScripts_ProgressivelySubtractGold
;============================================================================
IScripts_ProgressivelySubtractGold:         ; [$8321]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    LDA a:Temp_0203                         ; Load the upper byte of the gold
                                            ; amount.
    BMI @_subtractLowerByte                 ; If the upper byte is 0, jump.
    ORA a:Temp_0202                         ; OR with the lower byte.
    BEQ @_subtractUpperByte                 ; If neither has a value, jump.


    ;
    ; Subtract 10 from the counter of gold remaining to take.
    ; If at any point we underflow the lower byte, subtract 1
    ; from the upper byte.
    ;
    LDA a:Temp_0202                         ; Load the lower byte of gold.
    SEC
    SBC #$0a                                ; Subtract 10.
    STA a:Temp_0202                         ; And store as the lower byte.
    LDA a:Temp_0203                         ; Load the upper byte of gold.
    SBC #$00                                ; If the lower is now < 0,
                                            ; subtract 1 from upper.
    STA a:Temp_0203                         ; And store it.


    ;
    ; Remove 10 gold from the player.
    ;
    LDA #$0a                                ; A = 10
    STA Temp_Int24                          ; Store as the lower byte to
                                            ; subtract.
    LDA #$00                                ; A = 0
    STA Temp_Int24_M                        ; Store as the upper byte to
                                            ; subtract.
    JSR Player_SubtractGold                 ; Subtract the gold from the
                                            ; player.
    JMP IScripts_ProgressivelySubtractGold  ; And loop.

  @_subtractUpperByte:                      ; [$834d]
    DEC a:Temp_0203                         ; Subtract 1 from the upper byte.
    LDA #$3c                                ; Use 60 for the lower byte.
    STA a:Temp_0202                         ; And store it.

  @_subtractLowerByte:                      ; [$8355]
    DEC a:Temp_0202                         ; Subtract 1 from the lower byte.
    BNE IScripts_ProgressivelySubtractGold  ; If not 0, loop.
    RTS                                     ; Else, we're done. Return.


;============================================================================
; IScript Action $05: Spend Gold
;
; This takes the specified amount of gold away from the player.
;
; Script Parameters:
;
;     1. Gold amount (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::8280]
;============================================================================
IScriptAction_SpendGold:                    ; [$835b]
    ;
    ; Load the gold amount parameters for the script.
    ;
    JSR IScripts_LoadByte                   ; Load the lower byte of the gold
                                            ; amount.
    STA a:Temp_0202                         ; Store it.
    JSR IScripts_LoadByte                   ; Load the upper byte of the gold
                                            ; amount.
    STA a:Temp_0203                         ; Store it
    LDA a:Temp_0202                         ; Load the lower byte again.
    STA Temp_Int24                          ; Store it in
                                            ; Temp_Int24
                                            ; for comparison.
    LDA a:Temp_0203                         ; Lower the upper byte again.
    STA Temp_Int24_M                        ; And store it in
                                            ; Temp_Int24
                                            ; for comparison.


    ;
    ; Validate that there's enough money. If there is, spend
    ; it. If not, display an error message.
    ;
    JSR IScripts_CheckEnoughMoney           ; Check if there's enough money
                                            ; to pay.
    BCC IScripts_ShowNotEnoughMoney         ; If not, show the Not Enough
                                            ; Money message.
    JSR IScripts_ProgressivelySubtractGold  ; Progressively subtract the
                                            ; gold, animating it.
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; Show that the player doesn't have enough money.
;
; This will progressively show this in a textbox, and
; then end the script.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     Messages_Load
;     IScripts_UpdatePortraitAnimation
;     TextBox_ShowNextChar
;     TextBox_CheckShouldContinueOrDismissMessage
;     IScriptAction_EndScript
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_SpendGold
;============================================================================
IScripts_ShowNotEnoughMoney:                ; [$837c]
    ;
    ; Display the Not Enough Money message.
    ;
    LDA #$03                                ; Set the message ID.

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Show a message for shop purposes, ending the script once finished.
;
; This will show the message and, once dismissed or completed,
; end the current IScript.
;
; INPUTS:
;     A:
;         The ID of the message to show.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     IScriptAction_EndScript
;     IScripts_UpdatePortraitAnimation
;     Messages_Load
;     TextBox_ShowNextChar
;     TextBox_CheckShouldContinueOrDismissMessage
;
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_ShowSellMenu
;============================================================================
IScripts_ShowFinalMessage:                  ; [$837e]
    JSR Messages_Load                       ; Load the message string.


    ;
    ; Progressively write the message.
    ;
  @_messageLoop:                            ; [$8381]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_ShowNextChar                ; Show the next character in the
                                            ; textbox.
    JSR TextBox_CheckShouldContinueOrDismissMessage ; Check whether to
                                                    ; continue or dismiss.
    BCS @_endScript                         ; If dismissed, end the script.
    BNE @_messageLoop                       ; Else, if the message is not
                                            ; finished, loop.

  @_endScript:                              ; [$838e]
    JMP IScriptAction_EndScript             ; End processing of the script.


;============================================================================
; IScript Action $06: Set Spawn Point
;
; Sets the spawn point to the specified temple ID.
;
; Only the furthest temple will be set. If backtracking,
; to an earlier spawn point, then ew spawn point will
; not be set.
;
; Script Parameters:
;
;     1. Temple ID (1 byte)
;
; XREFS:
;     IScriptActions_L [$PRG12::8281]
;============================================================================
IScriptAction_SetSpawnPoint:                ; [$8391]
    JSR IScripts_LoadByte                   ; Load the temple/area ID.
    CMP a:TempleSpawnPoint                  ; Compare against the current
                                            ; spawn point.
    BCC @_nextAction                        ; If the older spawn point is
                                            ; further in the game, don't
                                            ; update.
    STA a:TempleSpawnPoint                  ; Else, set the new spawn point.

  @_nextAction:                             ; [$839c]
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; IScript Action $07: Adds an item with the specified ID to the player's
; inventory.
;
; This will show a textbox with the item's image and name,
; waiting for the player to press a button to dismiss it.
;
; Script Parameters:
;
;     1. Item ID (1 byte)
;
; XREFS:
;     IScriptActions_L [$PRG12::8282]
;============================================================================
IScriptAction_AddInventoryItem:             ; [$839f]
    JSR IScripts_LoadByte                   ; Load the item ID parameter.
    PHA                                     ; Push to the stack, twice.
    PHA
    JSR Player_AddToInventory               ; Add the item to the inventory.


    ;
    ; Begin showing the textbox indicating the added item.
    ;
    ; The text position will be inset 1 from the standard text
    ; position (2 blocks in from the textbox border), allowing
    ; room for the item image.
    ;
    JSR IScriptAction_AddInventoryItem_ClearTextBox ; Clear the textbox and
                                                    ; prepare for showing the
                                                    ; item.
    LDX a:TextBox_X                         ; X = Textbox X location.
    INX                                     ; X += 2
    INX
    STX TextBox_ContentsX                   ; Store as the text X position.
    LDX a:TextBox_Y                         ; X = Textbox Y position.
    INX                                     ; X += 2
    INX
    STX TextBox_ContentsY                   ; Store as the text Y position.


    ;
    ; Draw the item image and name in the textbox.
    ;
    PLA                                     ; Pull the item ID from the
                                            ; stack.
    LDX #$00                                ; X = 0
    JSR TextBox_DrawItemImage               ; Draw the item image.
    INC TextBox_ContentsY                   ; Text Y position += 3
    INC TextBox_ContentsY
    INC TextBox_ContentsY
    PLA                                     ; Pull the item ID from the
                                            ; stack.
    JSR TextBox_DrawItemName                ; Draw the item name.


    ;
    ; Update any portrait and textbox terminators until a
    ; button is pressed.
    ;
  @_textboxLoop:                            ; [$83c8]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_DrawUpArrowTerminatorSymbol ; Draw the Up arrow terminator
                                            ; symbol.
    LDA Joy1_ChangedButtonMask              ; Load any changed controller
                                            ; buttons.
    BPL @_textboxLoop                       ; If not pressed, loop.


    ;
    ; Prepare to clear out the textbox and then invoke the next
    ; action in the script.
    ;
    JSR IScripts_PositionAndFillPlaceholderText ; Fill the textbox with
                                                ; invisible placeholder text.
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; IScript Action $08: Open Shop
;
; This will load an address for shop item data, and then
; display the items in a box.
;
; Script Parameters:
;
;     1. The address of the shop items (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::8283]
;============================================================================
IScriptAction_OpenShop:                     ; [$83d8]
    LDA #$14                                ; "What would you like?"
    JSR Messages_Load

  @LAB_PRG12__83dd:                         ; [$83dd]
    JSR IScripts_UpdatePortraitAnimation
    JSR TextBox_ShowNextChar
    JSR TextBox_CheckShouldContinueOrDismissMessage
    BCS @_endScript
    BNE @LAB_PRG12__83dd
    JSR IScripts_LoadByte
    STA Temp_Int24                          ; Probably shop inventory table
    JSR IScripts_LoadByte
    STA Temp_Int24_M
    JSR Shop_Populate
    JSR Shop_Draw
    JSR IScripts_WaitForMenuInput
    BCC @LAB_PRG12__8402

  @_endScript:                              ; [$83ff]
    JMP IScriptAction_EndScript

  @LAB_PRG12__8402:                         ; [$8402]
    JSR Shop_GetPlayerHasSelectedItem
    BCS @LAB_PRG12__8469
    LDX a:Menu_CursorPos
    LDA DataArray,X
    CMP #$80
    BEQ @LAB_PRG12__8439
    CMP #$81
    BEQ @LAB_PRG12__8439
    CMP #$82
    BEQ @LAB_PRG12__8439
    CMP #$83
    BEQ @LAB_PRG12__8439
    CMP #$92
    BEQ @LAB_PRG12__8439
    CMP #$8a
    BEQ @LAB_PRG12__8439
    CMP #$93
    BEQ @LAB_PRG12__8439
    CMP #$94
    BEQ @LAB_PRG12__8439
    JSR Player_GetInventoryIndexForItem
    TAX
    LDA NumberOfWeapons,X                   ; Number of weapons in the
                                            ; player's inventory.
    CMP MAX_INVENTORY_SLOTS,X
    BEQ @LAB_PRG12__8469

  @LAB_PRG12__8439:                         ; [$8439]
    LDX a:Menu_CursorPos
    LDA ShopItemCostsL,X
    STA Temp_Int24
    STA a:Temp_0202
    LDA ShopItemCostsU,X
    STA Temp_Int24_M
    STA a:Temp_0203
    JSR IScripts_CheckEnoughMoney
    BCS @LAB_PRG12__8457
    JSR Maybe_Shop_DrawTextBox
    JMP IScripts_ShowNotEnoughMoney

  @LAB_PRG12__8457:                         ; [$8457]
    LDX a:Menu_CursorPos
    LDA DataArray,X
    JSR Player_AddToInventory
    JSR IScripts_ProgressivelySubtractGold
    JSR Maybe_Shop_DrawTextBox
    JMP IScripts_InvokeNextAction

  @LAB_PRG12__8469:                         ; [$8469]
    JSR Maybe_Shop_DrawTextBox
    LDA #$06
    JMP IScripts_ShowFinalMessage

;============================================================================
; TODO: Document Maybe_Shop_DrawTextBox
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_OpenShop
;============================================================================
Maybe_Shop_DrawTextBox:                     ; [$8471]
    JSR IScripts_UpdatePortraitAnimation
    JSR IScripts_UpdatePortraitAnimation
    JSR TextBox_Close
    JMP TextBox_OpenForNPC

;
; XREFS:
;     IScriptAction_OpenShop
;     Player_AddToInventory
;
MAX_INVENTORY_SLOTS:                        ; [$847d]
    .byte $04                               ; [0]: Max weapons
    .byte $04                               ; [1]: Max armor
    .byte $04                               ; [2]: Max shields
    .byte $04                               ; [3]: Max spells
    .byte $08                               ; [4]: Max consumable items

;============================================================================
; TODO: Document Shop_GetPlayerHasSelectedItem
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     IScriptAction_OpenShop
;============================================================================
Shop_GetPlayerHasSelectedItem:              ; [$8482]
    LDX a:Menu_CursorPos
    LDA DataArray,X
    BPL @LAB_PRG12__84bf
    LDX #$00
    CMP #$80
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$81
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$82
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$83
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$92
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$8a
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$93
    BEQ @LAB_PRG12__84b5
    INX
    CMP #$94
    BEQ @LAB_PRG12__84b5

  @LAB_PRG12__84b3:                         ; [$84b3]
    CLC
    RTS

  @LAB_PRG12__84b5:                         ; [$84b5]
    LDA a:SpecialItems
    AND BYTE_ARRAY_PRG12__84e5,X
    BEQ @LAB_PRG12__84b3

  @LAB_PRG12__84bd:                         ; [$84bd]
    SEC
    RTS

  @LAB_PRG12__84bf:                         ; [$84bf]
    PHA
    JSR Player_GetInventoryIndexForItem
    TAX
    LDA INVENTORY_CATEGORY_L,X
    STA Temp_Int24
    LDA INVENTORY_CATEGORY_U,X
    STA Temp_Int24_M
    PLA
    AND #$1f
    CMP SelectedWeapon,X
    BEQ @LAB_PRG12__84bd
    LDY NumberOfWeapons,X
    BEQ @LAB_PRG12__84b3
    DEY

  @LAB_PRG12__84dc:                         ; [$84dc]
    CMP (Temp_Int24),Y
    BEQ @LAB_PRG12__84bd
    DEY
    BPL @LAB_PRG12__84dc
    CLC
    RTS

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5:                     ; [$84e5]
    .byte $80                               ; [0]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_1_:                  ; [$84e6]
    .byte $40                               ; [1]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_2_:                  ; [$84e7]
    .byte $20                               ; [2]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_3_:                  ; [$84e8]
    .byte $10                               ; [3]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_4_:                  ; [$84e9]
    .byte $08                               ; [4]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_5_:                  ; [$84ea]
    .byte $04                               ; [5]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_6_:                  ; [$84eb]
    .byte $02                               ; [6]:

;
; XREFS:
;     Shop_GetPlayerHasSelectedItem
;
BYTE_ARRAY_PRG12__84e5_7_:                  ; [$84ec]
    .byte $01                               ; [7]:

;============================================================================
; TODO: Document IScripts_WaitForMenuInput
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_ShowSellMenu
;     IScripts_WaitForMenuInput
;============================================================================
IScripts_WaitForMenuInput:                  ; [$84ed]
    JSR IScripts_UpdatePortraitAnimation
    JSR Menu_UpdateAndDraw
    LDA Joy1_ChangedButtonMask
    BMI @_returnFalse
    ASL A
    BMI @_returnTrue
    JMP IScripts_WaitForMenuInput

  @_returnFalse:                            ; [$84fd]
    CLC
    RTS

  @_returnTrue:                             ; [$84ff]
    SEC
    RTS


;============================================================================
; Populate the items in the menu.
;
; This will take the menus stored in the address indicated
; in Temp_Int24 and Temp_Int24+1. It will
; loop through
; these, adding the items and costs to the menu state.
;
; INPUTS:
;     Temp_Int24:
;     Temp_Int24+1:
;         The address of the menu items to load.
;
; OUTPUTS:
;     Arg_StringsCount:
;         Position of the last menu item.
;
;     Menu_CursorPos:
;         Start position of the cursor (0).
;
;     DataArray:
;         The populated list of items.
;
;     ShopItemCostsL:
;     ShopItemCostsU:
;         The populated costs for each item.
;
; XREFS:
;     IScriptAction_OpenShop
;============================================================================
Shop_Populate:                              ; [$8501]
    LDY #$00                                ; Y = 0 (loop counter)
    LDX #$00                                ; X = 0 (menu position counter)
    STX a:Menu_CursorPos                    ; Cusor position = 0


    ;
    ; Fetch the menu item at this index.
    ;
  @_populateLoop:                           ; [$8508]
    LDA (Temp_Int24),Y                      ; A = Menu item at Y.


    ;
    ; Check if we're on the last item.
    ;
    CMP #$ff                                ; Check if it's 0xFF (the menu
                                            ; terminator).
    BEQ @_finish                            ; If so, we're done.


    ;
    ; Store the item.
    ;
    STA DataArray,X                         ; Store the item in the menu.
    INY                                     ; Y++


    ;
    ; Store the cost.
    ;
    LDA (Temp_Int24),Y                      ; Load the lower byte of the item
                                            ; cost.
    STA ShopItemCostsL,X                    ; Store it.
    INY                                     ; Y++
    LDA (Temp_Int24),Y                      ; Load the upper byte of the item
                                            ; cost.
    STA ShopItemCostsU,X                    ; Store it.


    ;
    ; Increment our counters.
    ;
    INY                                     ; Y++
    INX                                     ; X++
    BNE @_populateLoop                      ; If we're not done, loop.

  @_finish:                                 ; [$8521]
    STX a:Arg_StringsCount                  ; Set the last menu position.
    RTS


;============================================================================
; IScript action to add gold.
;
; This will load the lower and middle bytes of gold and
; progressively fill up the player's gold counter.
;
; It will then invoke the next action in the script.
;
; XREFS:
;     IScriptActions_L [$PRG12::8284]
;============================================================================
IScriptAction_AddGold:                      ; [$8525]
    JSR IScripts_LoadByte                   ; Load the lower byte for the
                                            ; gold amount.
    STA a:Temp_0202                         ; Store it.
    JSR IScripts_LoadByte                   ; Load the upper byte for the
                                            ; gold amount.
    STA a:Temp_0203                         ; Store it.
    JSR IScripts_ProgressivelyAddGold       ; Progressively add gold.
    JMP IScripts_InvokeNextAction           ; Invoke the next action.

;============================================================================
; TODO: Document IScripts_ProgressivelyAddGold
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_AddGold
;     IScriptAction_ShowSellMenu
;     IScripts_ProgressivelyAddGold
;============================================================================
IScripts_ProgressivelyAddGold:              ; [$8537]
    JSR IScripts_UpdatePortraitAnimation
    LDA a:Temp_0203
    BMI @LAB_PRG12__856e
    ORA a:Temp_0202
    BEQ @LAB_PRG12__8566
    JSR IScripts_PlayGoldChangeSound
    LDA a:Temp_0202
    SEC
    SBC #$0a
    STA a:Temp_0202
    LDA a:Temp_0203
    SBC #$00
    STA a:Temp_0203
    LDA #$0a
    STA Temp_Int24
    LDA #$00
    STA Temp_Int24_M
    JSR Player_AddGold
    JMP IScripts_ProgressivelyAddGold

  @LAB_PRG12__8566:                         ; [$8566]
    DEC a:Temp_0203
    LDA #$3c
    STA a:Temp_0202

  @LAB_PRG12__856e:                         ; [$856e]
    DEC a:Temp_0202
    BNE IScripts_ProgressivelyAddGold
    RTS


;============================================================================
; Play the gold change sound every 7 ticks.
;
; INPUTS:
;     InterruptCounter:
;         The interrupt counter to control timing of sounds.
;
; OUTPUTS:
;     None
;
; XREFS:
;     IScripts_ProgressivelyAddGold
;============================================================================
IScripts_PlayGoldChangeSound:               ; [$8574]
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$03                                ; Check if we're ready to play a
                                            ; sound.
    BNE @_return                            ; If not, return.


    ;
    ; We're ready to play the sound.
    ;
    LDA #$19                                ; 0x19 == Change gold amount
                                            ; sound
    JSR Sound_PlayEffect                    ; Play the sound.

  @_return:                                 ; [$857f]
    RTS


;============================================================================
; IScript action for adding MP.
;
; This will read the first byte as the MP amount.
;
; If this is under the MP cap, it will begin the process of
; progressively adding MP to the user, animating filling up
; the HP.
;
; XREFS:
;     IScriptActions_L [$PRG12::8285]
;============================================================================
IScriptAction_AddMP:                        ; [$8580]
    JSR IScripts_LoadByte                   ; Load the MP amount from the
                                            ; script.
    STA a:IScript_HPOrMPValueToAdd          ; Store in the variable to fill
                                            ; MP up to.
    LDA a:Player_MP                         ; Load the currently-added MP
                                            ; value we're filling from.
    CMP #$50                                ; Compare to the cap.
    BCS thunk_IScripts_InvokeNextAction     ; If at or over, we're done. Jump
                                            ; to invoke the next action.

  @_fillLoop:                               ; [$858d]
    JSR IScripts_UpdatePortraitAnimation
    JSR IScripts_PlayFillingSound           ; Play the sound for filling a
                                            ; bit of MP.
    LDX a:Player_MP                         ; X = Remaining value to add.
    INX                                     ; X++
    TXA                                     ; A = X
    JSR Player_SetMP                        ; Set the current mana points.
    DEC a:IScript_HPOrMPValueToAdd          ; Decrement the remaining value
                                            ; to add.
    BNE @_fillLoop                          ; If we're not done, loop.

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Thunk for invoking the next IScript action.
;
; This is here so that other code can jump to it cleanly.
;
; XREFS:
;     IScriptAction_AddHP
;     IScriptAction_AddMP
;============================================================================
thunk_IScripts_InvokeNextAction:            ; [$85a0]
    JMP IScripts_InvokeNextAction


;============================================================================
; Play a sound when filling the HP or MP bar.
;
; This will play every 7 ticks.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     None
;
; XREFS:
;     IScriptAction_AddHP
;     IScriptAction_AddMP
;============================================================================
IScripts_PlayFillingSound:                  ; [$85a3]
    LDA InterruptCounter
    AND #$03
    BNE RETURN_85AE
    LDA #$13
    JSR Sound_PlayEffect

    ;
    ; XREFS:
    ;     IScripts_PlayFillingSound
    ;
RETURN_85AE:                                ; [$85ae]
    RTS


;============================================================================
; IScript action for adding HP.
;
; This will read the first byte as the HP amount.
;
; If this is under the HP cap, it will begin the process of
; progressively adding HP to the user, animating filling up
; the HP.
;
; NOTE: If you look at the last couple instructions, it may
;       seem it's falling through to
;       IScriptAction_IfQuestCompleted.
;
;       This does not happen. The combination of BEQ and BNE
;       ensures we jump to an IScripts_InvokeNextAction
;       and
;       ends.
;
; XREFS:
;     IScriptActions_L [$PRG12::828e]
;============================================================================
IScriptAction_AddHP:                        ; [$85af]
    JSR IScripts_LoadByte                   ; Load the HP value to add.
    STA a:IScript_HPOrMPValueToAdd          ; Store in the variable to fill
                                            ; HP up to.
    LDA a:Temp_AddedHPValue                 ; Load the currently-added HP
                                            ; value we're filling from.
    CMP #$50                                ; Compare against the cap of 80.
    BCS thunk_IScripts_InvokeNextAction     ; If over, we're done. Invoke the
                                            ; next action.

  @_fillLoop:                               ; [$85bc]
    JSR IScripts_UpdatePortraitAnimation
    JSR IScripts_PlayFillingSound           ; Play the sound for filling a
                                            ; bit of HP.
    LDX a:Temp_AddedHPValue                 ; X = Remaining value to add
    INX                                     ; X++
    TXA                                     ; A = X
    JSR UI_DrawPlayerHPValue                ; Draw the next bit of health.
    DEC a:IScript_HPOrMPValueToAdd          ; Decrement the remaining amount
                                            ; to add.
    BNE @_fillLoop                          ; If there's more to add, loop.
    BEQ thunk_IScripts_InvokeNextAction     ; Else, invoke the next action.

    ;
    ; X-- Does not fall through -- Terminates at branches above --X
    ;


;============================================================================
; IScript action for a conditional check based on completed quests.
;
; This will read the next byte representing a quest index.
;
; If the player has completed the quests in the bitmask,
; this will read the next 2-byte address and jump to the
; script at that location.
;
; If they have not completed the quests, this will skip the
; address and invoke the following action.
;
; NOTE: This only checks the 3 least-significant bits of the
;       quests bitmask.
;
; XREFS:
;     IScriptActions_L [$PRG12::8286]
;============================================================================
IScriptAction_IfQuestCompleted:             ; [$85d1]
    JSR IScripts_LoadByte                   ; Load the next byte as the quest
                                            ; index into our table.
    TAX                                     ; X = result
    LDA a:Quests                            ; Load the current player quests.
    AND ISCRIPTS_QUEST_BITS-1,X             ; AND it to the bitmask at the
                                            ; given index.
    BNE @_hasQuestCompleted
    JMP IScripts_SkipAddrAndInvoke          ; Skip 2 bytes and invoke the
                                            ; following action.

  @_hasQuestCompleted:                      ; [$85e0]
    JMP IScripts_JumpToNextAddr

ISCRIPTS_QUEST_BITS:                        ; [$85e3]
    .byte $01,$02,$04                       ; [$85e3] byte


;============================================================================
; IScript action for marking a quest as complete.
;
; This will read the next byte as a quest bitmask value
; and set it.
;
; It will then invoke the following action.
;
; XREFS:
;     IScriptActions_L [$PRG12::8289]
;============================================================================
IScriptAction_SetQuestComplete:             ; [$85e6]
    JSR IScripts_LoadByte                   ; Load the next byte as the quest
                                            ; index into our table.
    TAX                                     ; X = result
    LDA a:Quests                            ; Load the current player quests.
    ORA ISCRIPTS_QUEST_BITS-1,X             ; OR it with the bit for this
                                            ; index.
    STA a:Quests                            ; Store as the new quests
                                            ; bitmask.
    JMP IScripts_InvokeNextAction           ; Invoke the next action.


;============================================================================
; IScript action for a conditional check based on a player title.
;
; This will read the next byte as a player title.
;
; If the player has reached that title, this will read
; the next 2-byte address and jump to the script at that
; location.
;
; If not, this will skip the 2 bytes and invoke the
; following action.
;
; XREFS:
;     IScriptActions_L [$PRG12::8287]
;============================================================================
IScriptAction_IfPlayerHasTitle:             ; [$85f6]
    JSR IScripts_LoadByte                   ; Load the next byte as the
                                            ; player title to check.
    CMP a:PlayerTitle                       ; Compare to the current player
                                            ; title.
    BEQ IScripts_JumpToNextAddr             ; If <=, jump to the script
                                            ; address in the next argument.
    BCC IScripts_JumpToNextAddr
    JMP IScripts_SkipAddrAndInvoke          ; Else, skip the address and
                                            ; invoke the next action.


;============================================================================
; Jump to the next address found in an IScript.
;
; This will read the next 2-byte address and jump to the
; script at that location.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     None
;
; XREFS:
;     IScriptAction_CheckUpdatePlayerTitle
;     IScriptAction_IfPlayerHasGold
;     IScriptAction_IfPlayerHasItem
;     IScriptAction_IfPlayerHasTitle
;     IScriptAction_IfQuestCompleted
;     IScriptAction_Jump
;     IScriptAction_ShowBuySellMenu
;     IScriptAction_ShowQuestionMessageCheckIfDismissed
;============================================================================
IScripts_JumpToNextAddr:                    ; [$8603]
    ;
    ; Load the next two event bytes and use that as the
    ; address for the next event to invoke.
    ;
    ; The logic here is doing a bit more than it has to.
    ; It loads the lower byte, push it, then pop it, then
    ; store it. It should just store it.
    ;
    JSR IScripts_LoadByte                   ; Load the next byte as the lower
                                            ; byte of the script address.
    PHA                                     ; Push to the stack.
    JSR IScripts_LoadByte                   ; Load the next byte as the upper
                                            ; byte of the script address.
    STA IScriptOrCHRAddr_U                  ; Store it.
    PLA                                     ; Pop the lower byte.
    STA IScriptOrCHRAddr                    ; Store it.
    LDA #$00                                ; A = 0.
    STA IScriptOffset                       ; Store as the new script offset.
    JMP IScripts_InvokeNextAction           ; Invoke the action at that
                                            ; address


;============================================================================
; Skip the next 2-byte address and invoke the next IScript action.
;
; XREFS:
;     IScriptAction_CheckUpdatePlayerTitle
;     IScriptAction_IfPlayerHasGold
;     IScriptAction_IfPlayerHasItem
;     IScriptAction_IfPlayerHasTitle
;     IScriptAction_IfQuestCompleted
;     IScriptAction_ShowBuySellMenu
;     IScriptAction_ShowQuestionMessageCheckIfDismissed
;============================================================================
IScripts_SkipAddrAndInvoke:                 ; [$8616]
    JSR IScripts_LoadByte                   ; Load 2 bytes and throw them
                                            ; out.
    JSR IScripts_LoadByte
    JMP IScripts_InvokeNextAction           ; Invoke the next action.


;============================================================================
; IScript action for a conditional check based on gold.
;
; If the player has any gold, the next 2-byte address will
; be read and this will jump to the script at that location.
;
; If the player has no gold, the next 2 bytes will be skipped
; and the following action will be invoked.
;
; XREFS:
;     IScriptActions_L [$PRG12::8288]
;============================================================================
IScriptAction_IfPlayerHasGold:              ; [$861f]
    LDA a:Gold                              ; Load the lower byte of the
                                            ; player's gold.
    ORA a:Gold_M                            ; OR with the medium byte.
    ORA a:Gold_U                            ; And the upper byte.
    BNE @_hasGold                           ; If there's any value set, jump.
    JMP IScripts_SkipAddrAndInvoke          ; Else, skip the next 2 bytes and
                                            ; invoke the following action.

  @_hasGold:                                ; [$862d]
    JMP IScripts_JumpToNextAddr             ; The player has gold, so jump to
                                            ; the next listed address.


;============================================================================
; IScript action for showing the Buy/Sell menu.
;
; This will first display the "Come here to buy or sell?"
; message. It'll listen for a choice.
;
; If the player chose "Buy", the next 2-byte address will
; be read from the script and this will jump to that
; address.
;
; If the player chose "Sell", this will skip the address
; and execute the next script action.
;
; XREFS:
;     IScriptActions_L [$PRG12::828a]
;============================================================================
IScriptAction_ShowBuySellMenu:              ; [$8630]
    ;
    ; Display the next "Come here to buy or sell?" message.
    ;
    LDA #$10                                ; 0x10 == "Did you come here to
                                            ; buy and sell?"
    JSR IScripts_LoadAndShowMessage         ; Load and show that message in
                                            ; its entirety.


    ;
    ; Set 2 strings for the menu.
    ;
    LDA #$02                                ; Queue 2 strings to draw.
    STA a:Arg_StringsCount                  ; Set it.


    ;
    ; Set the start cursor position to Buy.
    ;
    LDA #$00                                ; Set the start cursor position
                                            ; to 0.
    STA a:Menu_CursorPos


    ;
    ; Render the menu and wait for button changes.
    ;
  @_loop:                                   ; [$863f]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR Menu_UpdateAndDraw                  ; Update and draw the menu.
    LDA Joy1_ChangedButtonMask              ; Load the changed button mask.
    BMI @_choiceMade                        ; If the A button was pressed,
                                            ; jump.


    ;
    ; Check any button presses since the last iteration.
    ;
    ASL A                                   ; Increment the bit to check in
                                            ; the button mask.
    BPL @_loop                              ; If any other button was
                                            ; pressed, loop.


    ;
    ; End the script.
    ;
    JMP IScriptAction_EndScript


    ;
    ; Perform the next action based on the choice.
    ;
  @_choiceMade:                             ; [$864f]
    LDA a:Menu_CursorPos                    ; Check the cursor position.
    BEQ IScripts_JumpToNextAddr             ; If it's the first item, jump to
                                            ; the next address in the script.
    JMP IScripts_SkipAddrAndInvoke          ; Else, skip the address and
                                            ; invoke the next action.


;============================================================================
; IScript action for consuming a player's item.
;
; This will load the next byte as an inventory item type
; and remove it from the player's inventory.
;
; It will then invoke the next action in the script.
;
; XREFS:
;     IScriptActions_L [$PRG12::828b]
;============================================================================
IScriptAction_ConsumeItem:                  ; [$8657]
    JSR IScripts_LoadByte                   ; Load the next byte as the item
                                            ; ID.
    JSR Player_RemoveItem                   ; Remove the item from the
                                            ; player's inventory.
    JMP IScripts_InvokeNextAction           ; Invoke the next action.

;============================================================================
; TODO: Document IScriptAction_ShowSellMenu
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptActions_L [$PRG12::828c]
;============================================================================
IScriptAction_ShowSellMenu:                 ; [$8660]
    JSR IScripts_LoadByte
    STA Temp_Int24
    JSR IScripts_LoadByte
    STA Temp_Int24_M
    LDA #$00
    STA a:Arg_StringsCount
    LDX #$04

  @LAB_PRG12__8671:                         ; [$8671]
    LDY NumberOfWeapons,X
    BEQ @LAB_PRG12__86b7
    TXA
    PHA
    JSR Player_GetInventoryBitForIndex
    STA a:Maybe_Shop_InventoryBitmask
    LDA INVENTORY_CATEGORY_L,X
    STA Temp_Int24_U
    LDA INVENTORY_CATEGORY_U,X
    STA Maybe_Temp4
    DEY

  @LAB_PRG12__8689:                         ; [$8689]
    TYA
    PHA
    LDA (Temp_Int24_U),Y
    ORA a:Maybe_Shop_InventoryBitmask
    TAX
    JSR IScripts_SellMenu_Something8704
    BNE @LAB_PRG12__86b0
    LDX a:Arg_StringsCount
    STA DataArray,X
    INY
    LDA (Temp_Int24),Y
    STA ShopItemCostsL,X
    INY
    LDA (Temp_Int24),Y
    LSR A
    ROR ShopItemCostsL,X
    STA ShopItemCostsU,X
    INX
    STX a:Arg_StringsCount

  @LAB_PRG12__86b0:                         ; [$86b0]
    PLA
    TAY
    DEY
    BPL @LAB_PRG12__8689
    PLA
    TAX

  @LAB_PRG12__86b7:                         ; [$86b7]
    INX
    CPX #$05
    BNE @LAB_PRG12__8671
    LDA a:Arg_StringsCount
    BNE @LAB_PRG12__86c6
    LDA #$12
    JMP IScripts_ShowFinalMessage

  @LAB_PRG12__86c6:                         ; [$86c6]
    LDA #$13
    JSR Messages_Load

  @LAB_PRG12__86cb:                         ; [$86cb]
    JSR IScripts_UpdatePortraitAnimation
    JSR TextBox_ShowNextChar
    JSR TextBox_CheckShouldContinueOrDismissMessage
    BCS @_endScript
    BNE @LAB_PRG12__86cb
    JSR Shop_Draw
    JSR IScripts_WaitForMenuInput
    BCS @_endScript
    LDX a:Menu_CursorPos
    LDA ShopItemCostsL,X
    STA a:Temp_0202
    LDA ShopItemCostsU,X
    STA a:Temp_0203
    LDA DataArray,X
    JSR Player_RemoveItem
    JSR IScripts_ProgressivelyAddGold
    JSR TextBox_Close
    JSR TextBox_OpenForNPC
    JMP IScripts_InvokeNextAction

  @_endScript:                              ; [$8701]
    JMP IScriptAction_EndScript

;============================================================================
; TODO: Document IScripts_SellMenu_Something8704
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_ShowSellMenu
;============================================================================
IScripts_SellMenu_Something8704:            ; [$8704]
    LDY #$00

  @_loop:                                   ; [$8706]
    LDA (Temp_Int24),Y
    CMP #$ff
    BEQ @LAB_PRG12__8716
    TXA
    CMP (Temp_Int24),Y
    BEQ @_return
    INY
    INY
    INY
    BNE @_loop

  @LAB_PRG12__8716:                         ; [$8716]
    TAX

  @_return:                                 ; [$8717]
    RTS


;============================================================================
; IScript Action $12: If Player Has Item.
;
; This will load the next byte as an inventory item type.
;
; If the player has the item, the next 2-byte address will
; be loaded and this will jump to that address.
;
; If the item is not in the inventory, the address will
; be skipped and the following action will be invoked.
;
; Script Parameters:
;
;     1. Item ID (1 byte)
;     2. Jump address (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::828d]
;============================================================================
IScriptAction_IfPlayerHasItem:              ; [$8718]
    JSR IScripts_LoadByte                   ; Load the next byte as the item
                                            ; ID.
    JSR Player_LacksItem                    ; Check if the player lacks this
                                            ; item.
    BCC @_invokeElse                        ; If they have it, jump.


    ;
    ; The player does not have the item.
    ;
    JMP IScripts_SkipAddrAndInvoke          ; Skip the next 2 bytes and
                                            ; invoke the following action.


    ;
    ; The player has the item.
    ;
  @_invokeElse:                             ; [$8723]
    JMP IScripts_JumpToNextAddr             ; Jump to the next address in the
                                            ; script.


;============================================================================
; IScript Action $04: Check and Update Player Title
;
; If the player was eligible for a new title, their title
; will be increased and the next 2-byte address in the
; script be loaded and this will jump to that address.
;
; If not, the address will be skipped and the next action
; will be invoked.
;
; Script Parameters:
;
;     1. If-Updated Jump Address (2 bytes)
;
; XREFS:
;     IScriptActions_L [$PRG12::827f]
;============================================================================
IScriptAction_CheckUpdatePlayerTitle:       ; [$8726]
    LDA a:NextPlayerTitle                   ; Load the next player title.
    CMP a:PlayerTitle                       ; Compare against the current
                                            ; title.
    BEQ @_invokeElse                        ; If they're the same, jump.


    ;
    ; The player title is not a match. Update it.
    ;
    STA a:PlayerTitle                       ; Advance the player title.
    JMP IScripts_JumpToNextAddr             ; Read the next 2 bytes as an
                                            ; address and jump to it.


    ;
    ; The player already has that title.
    ;
  @_invokeElse:                             ; [$8734]
    JMP IScripts_SkipAddrAndInvoke          ; Skip the next 2 bytes and
                                            ; invoke the following action.


;============================================================================
; IScript Action $14: Show Password
;
; This is used when interacting with Gurus. The current
; state of the game will be encoded as a password and
; displayed.
;
; Script Parameters:
;     None.
;
; XREFS:
;     IScriptActions_L [$PRG12::828f]
;============================================================================
IScriptAction_ShowPassword:                 ; [$8737]
    JSR Password_GenerateStateAndReset      ; Generate the password state.
    JSR TextBox_ClearPasswordSize           ; Clear the textbox.
    LDA #$00
    STA a:IScripts_Unused_207               ; DEADCODE: Set to 0.

  @_charLoop:                               ; [$8742]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR PasswordScreen_ShowNextChar         ; Show the next character in the
                                            ; password.
    BCC @_charLoop                          ; If not done, loop.

  @_portraitLoop:                           ; [$874a]
    JSR IScripts_UpdatePortraitAnimation    ; Update the portrait animation.
    JSR TextBox_DrawUpArrowTerminatorSymbol ; Draw the Up Arrow in the
                                            ; textbox.
    LDA Joy1_ChangedButtonMask              ; A = Changed button mask
    BPL @_portraitLoop                      ; If not dismissed, loop.
    JMP IScripts_InvokeNextAction           ; Invoke the next action in the
                                            ; script.


;============================================================================
; Show the next character of a password.
;
; This will fetch the next 6 bits of a password and look
; that up in the character display lookup table.
;
; INPUTS:
;     PASSWORD_ENTERED_CHARS
;         The lookup table of characters.
;
; OUTPUTS:
;     C:
;         1 if finished with the password.
;         0 if there are characters remaining.
;
; CALLS:
;     Password_GetNext6Bits
;     TextBox_ShowMessage
;
; XREFS:
;     IScriptAction_ShowPassword
;============================================================================
PasswordScreen_ShowNextChar:                ; [$8757]
    JSR Password_GetNext6Bits               ; Get the next 6 bits of password
                                            ; state for the character offset.
    PHP                                     ; Push flags to stack.
    TAY                                     ; Y = A (index)
    LDA PASSWORD_ENTERED_CHARS,Y            ; A = character at index Y
    JSR TextBox_ShowMessage                 ; Show the character in the
                                            ; textbox.
    PLP                                     ; Pop flags.
    RTS


;============================================================================
; List of password characters by index.
;
; XREFS:
;     PasswordScreen_DrawAtCursorPosition
;     PasswordScreen_ShowNextChar
;============================================================================

;
; XREFS:
;     PasswordScreen_DrawAtCursorPosition
;     PasswordScreen_ShowNextChar
;
PASSWORD_ENTERED_CHARS:                     ; [$8764]
    .byte "ABCDEFGH"                        ; [$8764] char
    .byte "IJKLMNOP"                        ; [$876c] char
    .byte "QRSTUVWX"                        ; [$8774] char
    .byte "YZabcdef"                        ; [$877c] char
    .byte "ghijklmn"                        ; [$8784] char
    .byte "opqrstuv"                        ; [$878c] char
    .byte "wxyz0123"                        ; [$8794] char
    .byte "456789,?"                        ; [$879c] char


;============================================================================
; Load the next byte from the IScript.
;
; This will load the byte and update the offset.
;
; If the offset wraps around from 0xFF to 0, the upper
; bound of the address will wrap.
;
; INPUTS:
;     IScriptOrCHRAddr:
;         The start address of the script to read from.
;
;     IScriptOffset:
;         The offset within the script.
;
; OUTPUTS:
;     A:
;         The resulting byte.
;
; XREFS:
;     IScriptAction_AddGold
;     IScriptAction_AddHP
;     IScriptAction_AddInventoryItem
;     IScriptAction_AddMP
;     IScriptAction_ConsumeItem
;     IScriptAction_IfPlayerHasItem
;     IScriptAction_IfPlayerHasTitle
;     IScriptAction_IfQuestCompleted
;     IScriptAction_OpenShop
;     IScriptAction_SetQuestComplete
;     IScriptAction_SetSpawnPoint
;     IScriptAction_ShowMessage
;     IScriptAction_ShowQuestionMessage
;     IScriptAction_ShowQuestionMessageCheckIfDismissed
;     IScriptAction_ShowSellMenu
;     IScriptAction_ShowUnskippableMessage
;     IScriptAction_SpendGold
;     IScripts_InvokeNextAction
;     IScripts_JumpToNextAddr
;     IScripts_SkipAddrAndInvoke
;============================================================================
IScripts_LoadByte:                          ; [$87a4]
    LDY IScriptOffset                       ; Y = current event offset
    LDA (IScriptOrCHRAddr),Y                ; A = byte in the script at the
                                            ; offset
    INY                                     ; Y++
    BNE @_incOffset                         ; If byte is not 0, update event
                                            ; and return.


    ;
    ; The offset wrapped from 0xFF to 0. Update the upper byte
    ; of the script address for the next read.
    ;
    INC IScriptOrCHRAddr_U                  ; Increment the address

  @_incOffset:                              ; [$87ad]
    STY IScriptOffset                       ; Set new offset

    ;
    ; XREFS:
    ;     IScripts_UpdatePortraitAnimation
    ;
RETURN_87AF:                                ; [$87af]
    RTS


;============================================================================
; Update the portrait animation during message display.
;
; This will redraw the screen in a frozen state, and then
; compute what frame of animation to show for the portrait.
;
; If there's no message to display, or the drawing of the
; message finished, then portrait frame 0 will be shown.
; Otherwise, the frame will be based on the animation counter,
; using frames 0..2.
;
; INPUTS:
;     InterruptCounter:
;         The current interrupt counter.
;
;     MessageID:
;         The currently-displaying message ID.
;
;     Temp_0201:
;         The portrait ID.
;
;     TextBox_MessagePaused:
;         The message display ended flag.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     Game_DrawScreenInFrozenState
;     Screen_ResetSpritesForGamePlay
;     IScripts_DrawPortraitAnimationFrame
;     IScripts_SetPortraitSpriteXY
;     WaitForNextFrame
;
; XREFS:
;     IScriptAction_AddHP
;     IScriptAction_AddInventoryItem
;     IScriptAction_AddMP
;     IScriptAction_EndScript
;     IScriptAction_OpenShop
;     IScriptAction_ShowBuySellMenu
;     IScriptAction_ShowMessage
;     IScriptAction_ShowPassword
;     IScriptAction_ShowQuestionMessage
;     IScriptAction_ShowQuestionMessageCheckIfDismissed
;     IScriptAction_ShowSellMenu
;     IScriptAction_ShowUnskippableMessage
;     IScripts_ProgressivelyAddGold
;     IScripts_ProgressivelySubtractGold
;     IScripts_ShowFinalMessage
;     IScripts_WaitForMenuInput
;     Maybe_Shop_DrawTextBox
;============================================================================
IScripts_UpdatePortraitAnimation:           ; [$87b0]
    JSR WaitForNextFrame                    ; Wait for the next frame.
    JSR Screen_ResetSpritesForGamePlay      ; Set up state for a screen draw.
    JSR Game_DrawScreenInFrozenState        ; Draw the screen in a frozen
                                            ; animation state.
    LDA a:Temp_0201                         ; Load the portrait ID.
    BPL RETURN_87AF                         ; If no portrait, return.
    JMP @_updatePortrait                    ; Else, jump to update portrait
                                            ; (oddly, since we could fall
                                            ; through).

  @_updatePortrait:                         ; [$87c1]
    LDA a:MessageID                         ; Load the current message ID.
    BEQ @_messageIsUnset                    ; If unset, jump.
    LDA a:TextBox_MessagePaused             ; Load the message-ended flag.
    BNE @_messageIsUnset                    ; If the message ended, jump.


    ;
    ; The message is still animating, so choose the next
    ; animation frame.
    ;
    LDA InterruptCounter                    ; Load the interrupt counter.
    LSR A                                   ; Divide by 8.
    LSR A
    LSR A
    AND #$03                                ; Keep bits 0-1 as the new
                                            ; animation frame.
    BPL @_drawFrame                         ; Jump to finish the update.


    ;
    ; There's no message to continue showing, so freeze the
    ; animation to frame 0.
    ;
  @_messageIsUnset:                         ; [$87d4]
    LDA #$00                                ; Force animation frame to 0.

  @_drawFrame:                              ; [$87d6]
    JSR IScripts_SetPortraitSpriteXY        ; Set the X/Y location for the
                                            ; portrait sprite.
    JMP IScripts_DrawPortraitAnimationFrame ; Draw the computed animation
                                            ; frame.


;============================================================================
; Check if the user has enough money.
;
; This will determine a result based on the values stored
; in GoldMRequired and GoldLRequired.
;
; If Gold_U is at all set, it's assumed the player has
; enough money, because all checks are under this amount.
;
; Else, if Gold_M has more than the requested amount, or
; is equal and Gold_L has more, then the player has enough.
;
; INPUTS:
;     Temp_Int24:
;     Temp_Int24+1:
;         The amount of gold required for a true result.
;
;     Gold:
;     Gold_M:
;     Gold_U:
;         The amount of gold the player has.
;
; OUTPUTS:
;     C:
;         1 if the player has enough gold.
;         0 if the player does not.;
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_SpendGold
;============================================================================
IScripts_CheckEnoughMoney:                  ; [$87dc]
    ;
    ; Check the upper byte of the gold.
    ;
    LDA a:Gold_U                            ; Load the upper byte of the
                                            ; player's gold amount.
    CMP #$00                                ; Is it 0?
    BNE @_return                            ; If no, return. CMP set Carry as
                                            ; our result.


    ;
    ; Check the middle byte of the gold.
    ;
    LDA a:Gold_M                            ; Load the middle byte of the
                                            ; player's gold amount.
    CMP Temp_Int24_M                        ; Compare to the required amount.
    BNE @_return                            ; If not 0, return. CMP set Carry
                                            ; as our result.


    ;
    ; Check the lower byte of the gold.
    ;
    LDA a:Gold                              ; Load the lower byte of the gold
                                            ; amount.
    CMP Temp_Int24                          ; Compare to get our final result
                                            ; as the Carry flag.

  @_return:                                 ; [$87ef]
    RTS


;============================================================================
; Return a pixel X position for the current textbox position.
;
; INPUTS:
;     TextBox_X:
;         The textbox X position.
;
; OUTPUTS:
;     A:
;         The pixel X position.
;
; XREFS:
;     Menu_UpdateAndDraw
;============================================================================
TextBox_GetXPixelCoord:                     ; [$87f0]
    LDA a:TextBox_X                         ; Load the X tile position.
    ASL A                                   ; Multiply by 8 to convert to a
                                            ; pixel position.
    ASL A
    ASL A
    RTS                                     ; Return it.


;============================================================================
; Return a pixel Y position for the current textbox position.
;
; INPUTS:
;     TextBox_Y:
;         The textbox Y position.
;
; OUTPUTS:
;     A:
;         The pixel Y position.
;
; XREFS:
;     Menu_UpdateAndDraw
;============================================================================
TextBox_GetYPixelCoord:                     ; [$87f7]
    LDA a:TextBox_Y                         ; Load the Y tile position.
    ASL A                                   ; Multiply by 8 to convert to a
                                            ; pixel position.
    ASL A
    ASL A
    RTS                                     ; Return it.

;============================================================================
; TODO: Document TextBox_GetNextAttributeDataOffset
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     A
;
; XREFS:
;     TextBox_FillBackground
;     TextBox_SetNextAttributeData
;============================================================================
TextBox_GetNextAttributeDataOffset:         ; [$87fe]
    LDA TextBox_ContentsY
    ASL A
    ASL A
    AND #$f8
    STA Temp_Int24_M
    LDA TextBox_ContentsX
    LSR A
    ORA Temp_Int24_M
    STA Temp_Int24_M
    RTS

;============================================================================
; TODO: Document TextBox_SetNextAttributeData
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     TextBox_FillBackground
;============================================================================
TextBox_SetNextAttributeData:               ; [$880e]
    STA Temp_Int24
    JSR TextBox_GetNextAttributeDataOffset
    TAX
    LDA TextBox_ContentsY
    LSR A
    BCS @LAB_PRG12__8842
    LDA TextBox_ContentsX
    LSR A
    BCS @LAB_PRG12__882f
    LDA TextBox_AttributeData,X
    AND #$fc
    STA Temp_Int24_M
    LDA Temp_Int24
    AND #$03
    ORA Temp_Int24_M
    STA TextBox_AttributeData,X
    RTS

  @LAB_PRG12__882f:                         ; [$882f]
    LDA TextBox_AttributeData,X
    AND #$f3
    STA Temp_Int24_M
    LDA Temp_Int24
    ASL A
    ASL A
    AND #$0c
    ORA Temp_Int24_M
    STA TextBox_AttributeData,X
    RTS

  @LAB_PRG12__8842:                         ; [$8842]
    LDA TextBox_ContentsX
    LSR A
    BCS @LAB_PRG12__885c
    LDA TextBox_AttributeData,X
    AND #$cf
    STA Temp_Int24_M
    LDA Temp_Int24
    ASL A
    ASL A
    ASL A
    ASL A
    AND #$30
    ORA Temp_Int24_M
    STA TextBox_AttributeData,X
    RTS

  @LAB_PRG12__885c:                         ; [$885c]
    LDA TextBox_AttributeData,X
    AND #$3f
    STA Temp_Int24_M
    LDA Temp_Int24
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A
    AND #$c0
    ORA Temp_Int24_M
    STA TextBox_AttributeData,X
    RTS

PLAYER_TOP_MENU_ITEM_STRINGS:               ; [$8873]
    .byte $06,"WEAPON "                     ; [$8873] char
    .byte "        "                        ; [$887b] char
    .byte $05,"ARMOR  "                     ; [$8883] char
    .byte "        "                        ; [$888b] char
    .byte $06,"SHIELD "                     ; [$8893] char
    .byte "        "                        ; [$889b] char
    .byte $05,"MAGIC  "                     ; [$88a3] char
    .byte "        "                        ; [$88ab] char
    .byte $04,"ITEM   "                     ; [$88b3] char
    .byte "        "                        ; [$88bb] char
    .byte $06,"PLAYER "                     ; [$88c3] char
    .byte "        "                        ; [$88cb] char

PLAYER_STATUS_MENU_STRINGS:                 ; [$88d3]
    .byte $09,"    RAN"                     ; [$88d3] char
    .byte "K:      "                        ; [$88db] char
    .byte $09,"NEXT EX"                     ; [$88e3] char
    .byte "P:      "                        ; [$88eb] char
    .byte $09,"WEAPON:"                     ; [$88f3] char
    .byte "        "                        ; [$88fb] char
    .byte $09," ARMOR:"                     ; [$8903] char
    .byte "        "                        ; [$890b] char
    .byte $09,"SHIELD:"                     ; [$8913] char
    .byte "        "                        ; [$891b] char
    .byte $09," MAGIC:"                     ; [$8923] char
    .byte "        "                        ; [$892b] char
    .byte $09,"  ITEM:"                     ; [$8933] char
    .byte "        "                        ; [$893b] char

PLAYER_STATUS_MENU_TITLES:                  ; [$8943]
    .byte $09,"NOVICE "                     ; [$8943] char
    .byte "        "                        ; [$894b] char
    .byte $09,"ASPIRAN"                     ; [$8953] char
    .byte "T       "                        ; [$895b] char
    .byte $09,"BATTLER"                     ; [$8963] char
    .byte "        "                        ; [$896b] char
    .byte $09,"FIGHTER"                     ; [$8973] char
    .byte "        "                        ; [$897b] char
    .byte $09,"ADEPT  "                     ; [$8983] char
    .byte "        "                        ; [$898b] char
    .byte $09,"CHEVALI"                     ; [$8993] char
    .byte "ER      "                        ; [$899b] char
    .byte $09,"VETERAN"                     ; [$89a3] char
    .byte "        "                        ; [$89ab] char
    .byte $09,"WARRIOR"                     ; [$89b3] char
    .byte "        "                        ; [$89bb] char
    .byte $09,"SWORDMA"                     ; [$89c3] char
    .byte "N       "                        ; [$89cb] char
    .byte $09,"HERO   "                     ; [$89d3] char
    .byte "        "                        ; [$89db] char
    .byte $09,"SOLDIER"                     ; [$89e3] char
    .byte "        "                        ; [$89eb] char
    .byte $09,"MYRMIDO"                     ; [$89f3] char
    .byte "N       "                        ; [$89fb] char
    .byte $09,"CHAMPIO"                     ; [$8a03] char
    .byte "N       "                        ; [$8a0b] char
    .byte $09,"SUPERHE"                     ; [$8a13] char
    .byte "RO      "                        ; [$8a1b] char
    .byte $09,"PALADIN"                     ; [$8a23] char
    .byte "        "                        ; [$8a2b] char
    .byte $09,"LORD   "                     ; [$8a33] char
    .byte "        "                        ; [$8a3b] char
    .byte $09,"NO WEAP"                     ; [$8a43] char
    .byte "ON      "                        ; [$8a4b] char
    .byte $09,"NO ARMO"                     ; [$8a53] char
    .byte "R       "                        ; [$8a5b] char
    .byte $09,"NO SHIE"                     ; [$8a63] char
    .byte "LD      "                        ; [$8a6b] char
    .byte $09,"NO MAGI"                     ; [$8a73] char
    .byte "C       "                        ; [$8a7b] char
    .byte $09,"NO ITEM"                     ; [$8a83] char
    .byte "        "                        ; [$8a8b] char

;============================================================================
; TODO: Document PlayerMenu_Show
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     GameLoop_CheckShowPlayerMenu
;============================================================================
PlayerMenu_Show:                            ; [$8a93]
    LDA #$06
    STA a:Arg_StringsCount
    LDA #$00
    STA a:Menu_CursorPos
    LDA #$02
    STA a:TextBox_X
    LDA #$06
    STA a:TextBox_Y
    LDA #$0a
    STA a:TextBox_Width
    LDA #$0e
    STA a:TextBox_Height
    LDA #$18
    JSR Sound_PlayEffect
    JSR TextBox_Open
    LDA #$73
    STA Temp_Int24
    LDA #$88
    STA Temp_Int24_M
    LDX #$00
    STX a:DataArray
    INX
    STX a:DataArray_1_
    INX
    STX a:DataArray_2_
    INX
    STX a:DataArray_3_
    INX
    STX a:DataArray_4_
    INX
    STX a:DataArray_5_
    JSR PlayerMenu_DrawStringLines

  @_inputLoop:                              ; [$8add]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForGamePlay
    JSR Menu_UpdateAndDraw
    LDA Joy1_ChangedButtonMask
    BMI @_loadMenuIDs
    ASL A
    BPL @_inputLoop
    JMP TextBox_Close

  @_loadMenuIDs:                            ; [$8af0]
    LDX a:Menu_CursorPos
    CPX #$05
    BNE PlayerMenu_ShowSubmenu
    JMP PlayerMenu_ShowStatusMenu

;============================================================================
; TODO: Document PlayerMenu_ShowSubmenu
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_Show
;============================================================================
PlayerMenu_ShowSubmenu:                     ; [$8afa]
    LDA #$04
    STA a:TextBox_X
    LDA #$08
    STA a:TextBox_Y
    LDA #$14
    STA a:TextBox_Width
    LDA #$12
    STA a:TextBox_Height
    JSR TextBox_Open
    LDX a:Menu_CursorPos
    STX a:PlayerMenu_SelectedInventory
    LDA NumberOfWeapons,X
    BNE PlayerMenu_ShowInventoryMenu
    LDA a:TextBox_X
    CLC
    ADC #$02
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    CLC
    ADC #$02
    STA TextBox_ContentsY
    JSR PPU_SetAddrForTextBoxPos
    LDA #$43
    STA Temp_Int24
    LDA #$8a
    STA Temp_Int24_M
    LDA a:Menu_CursorPos
    JSR Math_MultiplyBy16
    TAY
    JSR UI_DrawString

  @_inputLoop:                              ; [$8b41]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForGamePlay
    LDA Joy1_ChangedButtonMask
    ASL A
    BPL @_inputLoop
    JMP PlayerMenu_Close

;============================================================================
; TODO: Document PlayerMenu_ShowInventoryMenu
;
; INPUTS:
;     A
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_ShowSubmenu
;============================================================================
PlayerMenu_ShowInventoryMenu:               ; [$8b4f]
    STA a:Arg_StringsCount
    LDA INVENTORY_CATEGORY_L,X
    STA Temp_Int24
    LDA INVENTORY_CATEGORY_U,X
    STA Temp_Int24_M
    LDY #$00

  @_loadMenuIDs:                            ; [$8b5e]
    LDA (Temp_Int24),Y
    STA DataArray,Y
    INY
    CPY a:Arg_StringsCount
    BNE @_loadMenuIDs
    JSR PlayerMenu_DrawInventoryItems
    LDA #$00
    STA a:Menu_CursorPos                    ; Set the menu cursor position to
                                            ; 0.

    ;
    ; v-- Fall through --v
    ;
;============================================================================
; TODO: Document PlayerMenu_HandleInventoryMenuInput
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_HandleInvalidChoice
;     PlayerMenu_HandleInventoryMenuInput
;============================================================================
PlayerMenu_HandleInventoryMenuInput:        ; [$8b71]
    ;
    ; Wait for input on the menu.
    ;
    JSR WaitForNextFrame                    ; Wait for the next frame.
    JSR Screen_ResetSpritesForGamePlay      ; Set up draw state.
    JSR Menu_UpdateAndDraw                  ; Update and draw the menu.
    LDA Joy1_ChangedButtonMask              ; Check for a changed button.
    BMI @_hasInput                          ; If the the "A" button is
                                            ; pressed, jump to handle input.
    ASL A                                   ; Shift the button mask left.
    BMI PlayerMenu_Close                    ; If the "B" button is pressed,
                                            ; close the menu.
    BPL PlayerMenu_HandleInventoryMenuInput

  @_hasInput:                               ; [$8b83]
    LDA a:Area_CurrentArea                  ; Load the current area.
    CMP #$04                                ; Is the player inside/in a place
                                            ; where they can't equip?
    BEQ PlayerMenu_HandleInvalidChoice      ; If so, it's an invalid choice.


    ;
    ; The player is in an area where they can equip. See if
    ; this inventory allows equipping (only Magic and Item).
    ;
    LDA a:PlayerMenu_SelectedInventory      ; Load the selected inventory
                                            ; index.
    CMP #$03                                ; Is it the Magic or Item
                                            ; inventory?
    BCS PlayerMenu_EquipItem                ; If so, always allow equipping
                                            ; the item.


    ;
    ; Check the selected weapon and see if it's the Dragon Slayer
    ; (which also implies the Battle Suit and Battle Helmet).
    ;
    ; If they have these, they cannot select a new item. If they
    ; don't, they can.
    ;
    LDA a:SelectedWeapon                    ; Load the selected weapon.
    CMP #$03                                ; Is it the Dragon Slayer?
    BEQ PlayerMenu_HandleInvalidChoice      ; If not, it's an invalid choice.
    LDX a:Menu_CursorPos                    ; X = Menu cursor position.
    LDA DataArray,X                         ; A = Item ID at the cursor
                                            ; position.
    CMP #$03                                ; Is the item ID 3 (Dragon
                                            ; Slayer)?
    BNE PlayerMenu_EquipItem                ; If not, proceed to equip the
                                            ; item normally.


    ;
    ; The player selected a Dragon Slayer, Battle Suit, or Battle
    ; Helmet. Check if they have all three, and if so, they'll all
    ; be equipped.
    ;
    ; First, check for the Dragon Slayer.
    ;
    LDA #$03                                ; 0x03 == Dragon Slayer
    JSR Player_LacksItem                    ; Does the player have it?
    BCS PlayerMenu_HandleInvalidChoice      ; If not, it's an invalid choice.


    ;
    ; They have the Dragon Slayer. Check for the Battle Suit.
    ;
    LDA #$23                                ; 0x23 == Battle Suit.
    JSR Player_LacksItem                    ; Does the player have it?
    BCS PlayerMenu_HandleInvalidChoice      ; If not, it's an invalid choice.


    ;
    ; They have the Dragon Slayer and Battle Suit. Check for the
    ; Battle Helmet.
    ;
    LDA #$43                                ; 0x43 == Battle Helmet.
    JSR Player_LacksItem                    ; Does the player have it?
    BCS PlayerMenu_HandleInvalidChoice      ; If not, it's an invalid choice.


    ;
    ; They have all three. Equip them all and close the menu.
    ;
    LDA #$08                                ; 0x08 == Item Pick-Up sound.
    JSR Sound_PlayEffect                    ; Play it.
    LDA #$03                                ; 0x03 == Dragon Slayer.
    JSR Player_Equip                        ; Equip it.
    LDA #$23                                ; 0x23 == Battle Suit.
    JSR Player_Equip                        ; Equip it.
    LDA #$43                                ; 0x43 == Battle Helmet.
    JSR Player_Equip                        ; Equip it.
    JMP PlayerMenu_Close                    ; Close the Player Menu.

;============================================================================
; TODO: Document PlayerMenu_EquipItem
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_HandleInventoryMenuInput
;============================================================================
PlayerMenu_EquipItem:                       ; [$8bce]
    LDA #$08                                ; 0x08 == Item pick-up sound.
    JSR Sound_PlayEffect                    ; Play it.
    LDX a:Menu_CursorPos                    ; X = Menu cursor position.
    LDA a:PlayerMenu_SelectedInventory      ; A = Selected inventory.
    JSR Player_GetInventoryBitForIndex      ; Get the inventory bits.
    ORA DataArray,X                         ; OR it with the selected item
                                            ; index as an item ID.
    JSR Player_Equip                        ; Equip the resulting item.
    JMP PlayerMenu_Close                    ; Close the Player Menu.

;============================================================================
; TODO: Document PlayerMenu_HandleInvalidChoice
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_HandleInventoryMenuInput
;============================================================================
PlayerMenu_HandleInvalidChoice:             ; [$8be5]
    LDA #$0d                                ; 0x0D == Invalid Choice sound
                                            ; effect.
    JSR Sound_PlayEffect                    ; Play it.
    JMP PlayerMenu_HandleInventoryMenuInput ; Resume handling of the
                                            ; inventory menu.


;============================================================================
; Close the Player Menu.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TextBox_X:
;     TextBox_Y:
;     TextBox_Width:
;     TextBox_Height:
;         Clobbered.
;
; CALLS:
;     TextBox_Close
;
; XREFS:
;     PlayerMenu_EquipItem
;     PlayerMenu_HandleInventoryMenuInput
;     PlayerMenu_ShowSubmenu
;============================================================================
PlayerMenu_Close:                           ; [$8bed]
    LDA #$02
    STA a:TextBox_X                         ; Set box X coordinate to 2.
    LDA #$06
    STA a:TextBox_Y                         ; Set box Y coordinate to 6.
    LDA #$16
    STA a:TextBox_Width                     ; Set box width to 22.
    LDA #$14
    STA a:TextBox_Height                    ; Set box height to 20.
    JMP TextBox_Close                       ; Close the Player Menu.

;============================================================================
; TODO: Document PlayerMenu_DrawInventoryItems
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_ShowInventoryMenu
;============================================================================
PlayerMenu_DrawInventoryItems:              ; [$8c04]
    LDA a:TextBox_Y
    STA TextBox_ContentsY
    LDX #$00

  @LAB_PRG12__8c0b:                         ; [$8c0b]
    TXA
    PHA
    INC TextBox_ContentsY
    LDY a:TextBox_X
    INY
    INY
    STY TextBox_ContentsX
    LDA a:PlayerMenu_SelectedInventory
    JSR Player_GetInventoryBitForIndex
    ORA DataArray,X
    PHA
    JSR TextBox_DrawItemImage
    PLA
    INC TextBox_ContentsY
    INC TextBox_ContentsX
    INC TextBox_ContentsX
    JSR TextBox_DrawItemName
    PLA
    TAX
    INX
    CPX a:Arg_StringsCount
    BNE @LAB_PRG12__8c0b
    RTS

;============================================================================
; TODO: Document TextBox_DrawItemName
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_AddInventoryItem
;     PlayerMenu_DrawInventoryItems
;     PlayerMenu_ShowStatusMenu
;     Shop_Draw
;============================================================================
TextBox_DrawItemName:                       ; [$8c36]
    PHA
    PHA
    JSR PPU_SetAddrForTextBoxPos
    PLA
    JSR Player_GetInventoryIndexForItem
    TAX
    LDA ITEM_NAME_CATEGORIES_L,X
    STA Temp_Int24
    LDA ITEM_NAME_CATEGORIES_U,X
    STA Temp_Int24_M
    PLA
    AND #$1f
    JSR Math_MultiplyBy16
    BCC @LAB_PRG12__8c54
    INC Temp_Int24_M

  @LAB_PRG12__8c54:                         ; [$8c54]
    TAY
    JMP UI_DrawString


;============================================================================
; Draw the image for an item in a textbox.
;
; This is used when acquiring an item. The image's tileset
; will be queued into the PPU buffer, followed by the
; indexes of the tiles to draw for the item.
;
; These will be positioned within the textbox where the first
; character of text would normally be.
;
; INPUTS:
;     A:
;         The ID of the item to draw.
;
;     X:
;         The offset within the loaded PPU tiles containing
;         the tiles to display. Each value represents a
;         4-tile span of 64 bytes.
;
; OUTPUTS:
;     PPU_TargetAddr:
;         Clobbered.
;
; CALLS:
;     PPU_SetAddrForTextBoxPos
;     PPU_IncrementAddrBy32
;     PPUBuffer_QueueCommandOrLength
;     PPUBuffer_Set
;     TextBox_LoadItemSourceTiles
;
; XREFS:
;     IScriptAction_AddInventoryItem
;     PlayerMenu_DrawInventoryItems
;     PlayerMenu_ShowStatusMenu
;     Shop_Draw
;============================================================================
TextBox_DrawItemImage:                      ; [$8c58]
    ;
    ; Save the registers temporarily.
    ;
    STA Temp_Int24                          ; Store the item ID temporarily.
    TYA                                     ; A = Y
    PHA                                     ; Push to the stack.
    TXA                                     ; A = X
    PHA                                     ; Push to the stack.


    ;
    ; Set the target PPU address to load tiles into. The following
    ; code is equivalent to:
    ;
    ;     addr = $1400 + (index * 64)
    ;
    ; 64 is the number of bytes for a full item image
    ; (8 bytes * 4 tiles). This will be used again below.
    ;
    LDA #$00                                ; A = 0
    STA PPU_TargetAddr                      ; Set as the lower byte.
    TXA                                     ; A = X (item index)
    PHA                                     ; Push to the stack, twice.
    PHA
    LSR A                                   ; C = bit0(index)
    ROR PPU_TargetAddr                      ; If C == 0, then set to 0. Else,
                                            ; set to 0x80.
    LSR A                                   ; A = itemID >> 2 C = bit1(index)
    ROR PPU_TargetAddr                      ; Set to (bit1(index) << 7) |
                                            ; (bit0(index) << 6. == (index &
                                            ; 3) * 64.
    ADC #$14                                ; A = 0x14 + C.
    STA PPU_TargetAddr_U                    ; Set as the upper byte.


    ;
    ; Queue the address for the source tiles for the item into the
    ; PPU at the address above. The indexes following this will be
    ; relative to that address.
    ;
    LDA Temp_Int24                          ; Load the item ID.
    JSR TextBox_LoadItemSourceTiles         ; Load the source tiles address
                                            ; in the PPU.


    ;
    ; Position the image where the text would normally go.
    ;
    JSR PPU_SetAddrForTextBoxPos            ; Set the draw position for the
                                            ; image.


    ;
    ; Draw the top two tiles of the image in the PPU buffer.
    ;
    ; There are:
    ;
    ;     Tile1 = 64 + (itemID * 16)
    ;     Tile2 = Tile1 + 1
    ;
    ; (16 == 8 bytes * 2 tiles)
    ;
    LDA #$02                                ; A = 2 (tiles)
    JSR PPUBuffer_QueueCommandOrLength      ; Write the length to the PPU
                                            ; buffer.
    PLA                                     ; Pull the index from the stack.
    ASL A                                   ; Multiply by 16.
    ASL A
    ADC #$40                                ; Add 64 + C.
    JSR PPUBuffer_Set                       ; Add to the PPU buffer.
    CLC
    ADC #$01                                ; Add 1.
    JSR PPUBuffer_Set                       ; Add to the PPU buffer.


    ;
    ; Advane to the target address to the next position (bottom
    ; 2 tiles of the image).
    ;
    STX PPUBuffer_WriteOffset               ; Store the new PPU buffer write
                                            ; offset.
    JSR PPU_IncrementAddrBy32               ; Increment the PPU address by
                                            ; 32.


    ;
    ; Draw the second part of the image in the PPU buffer.
    ;
    ; There are:
    ;
    ;     Tile3 = 66 + (index * 16)
    ;     Tile4 = Tile3 + 1
    ;
    ; (16 == 8 bytes * 2 tiles)
    ;
    LDA #$02                                ; A = 2 (tiles)
    JSR PPUBuffer_QueueCommandOrLength      ; Write the length to the PPU
                                            ; buffer.
    PLA                                     ; Pull the index from the stack.
    ASL A                                   ; Multiply by 16.
    ASL A
    ADC #$42                                ; Add 66 + C.
    JSR PPUBuffer_Set                       ; Add left tile index the PPU
                                            ; buffer.
    CLC
    ADC #$01                                ; Add 1.
    JSR PPUBuffer_Set                       ; Add right tile to the PPU
                                            ; buffer.
    STX PPUBuffer_WriteOffset               ; Store the new PPU buffer write
                                            ; offset.


    ;
    ; Restore the registers saved at the top of the function.
    ;
    PLA                                     ; Pop the X register value.
    TAX                                     ; Set it back on X.
    PLA                                     ; Pop the Y register value.
    TAY                                     ; Set it back on Y.
    RTS                                     ; And return.


;============================================================================
; Equip an item from the inventory.
;
; INPUTS:
;     A:
;         The inventory item, with bits set indicating the
;         inventory.
;
;     SelectedWeapon
;         The starting range of inventories to look up
;         items from.
;
; OUTPUTS:
;     Temp_EquipingItem:
;     Temp_PrevInventoryItem:
;         Clobbered.
;
; CALLS:
;     Player_AddToInventory
;     Player_GetInventoryIndexForItem
;     Player_RemoveItem
;     Player_SetArmor
;     Player_SetItem
;     Player_SetMagic
;     Player_SetShield
;     Player_SetWeapon
;
; XREFS:
;     PlayerMenu_EquipItem
;     PlayerMenu_HandleInventoryMenuInput
;============================================================================
Player_Equip:                               ; [$8ca9]
    ;
    ; Calculate the target inventory and store the old and
    ; new items temporary.
    ;
    STA a:Temp_EquipingItem                 ; Store the item that we're
                                            ; equipping.
    JSR Player_GetInventoryIndexForItem     ; Compute the inventory index of
                                            ; the item.
    TAX                                     ; Set X = the inventory index we
                                            ; computed
    LDA SelectedWeapon,X                    ; Get the current item in the
                                            ; target inventory.
    STA a:Temp_PrevInventoryItem            ; Store the old item we're
                                            ; unequipping.


    ;
    ; Unequip the old item.
    ;
    LDA a:Temp_EquipingItem
    JSR Player_RemoveItem                   ; Unequip the old item.
    LDA a:Temp_PrevInventoryItem            ; Load back the previous item.


    ;
    ; Only add to the inventory if we didn't already have one.
    ;
    BMI @_inInventory                       ; Branch if we don't need to add
                                            ; to the inventory.
    LDA a:Temp_EquipingItem                 ; Load the item we're equipping.
    AND #$e0                                ; Clear out all but the inventory
                                            ; bits.
    ORA a:Temp_PrevInventoryItem            ; Add the item's value.
    JSR Player_AddToInventory               ; Now add to the inventory.

  @_inInventory:                            ; [$8ccc]
    LDA a:Temp_EquipingItem


    ;
    ; Set the normalized value within the inventory.
    ;
    JSR Player_GetInventoryIndexForItem     ; Calculate the inventory slot
                                            ; again.
    TAY                                     ; Set Y = inventory slot
    LDA a:Temp_EquipingItem                 ; Set A = new item
    AND #$1f                                ; Clear out the inventory bits,
                                            ; yielding the item value.
    DEY
    BEQ @_isArmor                           ; Check if it's armor.
    DEY
    BEQ @_isShield                          ; Check if it's a shield.
    DEY
    BEQ @_isMagic                           ; Check if it's magic.
    DEY
    BEQ @_isItem                            ; Check if it's an item.


    ;
    ; Inventory 0 (weapons)
    ;
    JMP Player_SetWeapon                    ; Set the current weapon.


    ;
    ; Inventory 1 (armor)
    ;
  @_isArmor:                                ; [$8ce7]
    JMP Player_SetArmor                     ; Set the current armor.


    ;
    ; Inventory 2 (shield)
    ;
  @_isShield:                               ; [$8cea]
    JMP Player_SetShield                    ; Set the current shield.


    ;
    ; Inventory 3 (magic)
    ;
  @_isMagic:                                ; [$8ced]
    JMP Player_SetMagic                     ; Set the current magic.


    ;
    ; Inventory 4 (normal items)
    ;
  @_isItem:                                 ; [$8cf0]
    JMP Player_SetItem                      ; Set the current item.


;============================================================================
; Set the player's current magic spell.
;
; INPUTS:
;     A:
;         The magic spell to set.
;
; OUTPUTS:
;     SelectedMagic:
;         The updated magic spell.
;
; XREFS:
;     Player_Equip
;============================================================================
Player_SetMagic:                            ; [$8cf3]
    STA a:SelectedMagic                     ; Store the provided A value as
                                            ; the selected magic.
    RTS


;============================================================================
; Return whether the player lacks an item in the inventory.
;
; This will inspect the inventory bits of the item (the 3
; most significant bits), using the remaining bits as the
; value of the item in the inventory.
;
; INPUTS:
;     A:
;         The item index with inventory bits to check.
;
;     NumberOfWeapons:
;         The starting range of inventory counters,
;         indexed by inventory IDs.
;
;     SelectedWeapon:
;         The starting range of selected item memory,
;         indexed by the inventory IDs.
;
;     WeaponInventory:
;         The starting range of inventories, indexed
;         by the inventory IDs.
;
;     INVENTORY_CATEGORY_U:
;     INVENTORY_CATEGORY_L:
;         A lookup table of inventory ID to address.
;
;     SPECIAL_ITEM_BITMASKS:
;         A lookup table of item indexes to special items
;         bitmasks.
;
; OUTPUTS:
;     C:
;         1 if the item is not in the inventory.
;         0 if it is.
;
;     Temp_Int24:
;     Temp_Int24+1:
;         Clobbered.
;
; CALLS:
;     Player_GetInventoryIndexForItem
;
; XREFS:
;     IScriptAction_IfPlayerHasItem
;     PlayerMenu_HandleInventoryMenuInput
;============================================================================
Player_LacksItem:                           ; [$8cf7]
    ;
    ; Check if this is a special item.
    ;
    ; Each special item type will be converted into an index in
    ; the SPECIAL_ITEMS_BITMASKS lookup table.
    ;
    ; If the matching bit is set, the item exists, so return false.
    ;
    LDX #$00                                ; X will be our lookup table
                                            ; index.
    CMP #$80                                ; Check Ring of Elf.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$81                                ; Check Ring of Ruby.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$82                                ; Check Ring of Dworf.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$83                                ; Check Demon's Ring.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$92                                ; Check Elixir.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$8a                                ; Check Magical Rod.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$93                                ; Check Pendant.
    BEQ @_specialItemMatched
    INX                                     ; X++
    CMP #$94                                ; Check Black Onyx.
    BEQ @_specialItemMatched
    PHA                                     ; Push the item value on the
                                            ; stack.
    JSR Player_GetInventoryIndexForItem     ; Get the inventory for the item.
    TAY                                     ; Set Y = inventory.
    LDA INVENTORY_CATEGORY_L,Y
    STA Temp_Int24
    LDA INVENTORY_CATEGORY_U,Y
    STA Temp_Int24_M


    ;
    ; Check if this item is currently equipped.
    ;
    ; If so, we'll be returning false (we don't lack it).
    ;
    PLA                                     ; Pull the item into A
    AND #$1f                                ; Clear out the inventory bits,
                                            ; leaving the item value.
    CMP SelectedWeapon,Y                    ; Get the inventory index from Y.
    BEQ @_returnFalse                       ; If this item is currently set,
                                            ; return false.


    ;
    ; Check the number of items in the target inventory.
    ;
    ; If the number is 0, we definitely lack the item.
    ;
    LDX NumberOfWeapons,Y                   ; Set X = inventory item count.
    BEQ @_returnTrue                        ; If 0, we lack the item.


    ;
    ; Loop through all items in the inventory to see if
    ; we have this item.
    ;
    LDY #$00                                ; Set Y = 0 for the loop counter


    ;
    ; Check the item at the address to see if it matches this one.
    ;
    ; If so, we don't lack the item.
    ;
  @_checkInventoryLoop:                     ; [$8d3e]
    CMP (Temp_Int24),Y                      ; Check the inventory address at
                                            ; this index.
    BEQ @_returnFalse                       ; If it's a match, we don't lack
                                            ; the item. Return false.
    INY                                     ; Y++.
    DEX                                     ; Reduce the number of items left
                                            ; to check.
    BNE @_checkInventoryLoop                ; Next loop.


    ;
    ; The item could not be found. The player lacks the item.
    ;
  @_returnTrue:                             ; [$8d46]
    SEC                                     ; Set for a true result.
    RTS

  @_specialItemMatched:                     ; [$8d48]
    LDA a:SpecialItems                      ; Load the player's Special Items
                                            ; bitmask.
    AND SPECIAL_ITEMS_BITMASKS,X            ; Clear the bit for the matched
                                            ; item.
    BEQ @_returnTrue

  @_returnFalse:                            ; [$8d50]
    CLC                                     ; Clear for a false result.
    RTS


;============================================================================
; A mapping of item IDs to Special Items bitmasks.
;
; XREFS:
;     Player_LacksItem
;============================================================================

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS:                     ; [$8d52]
    .byte $80                               ; [0]: Ring of Elf

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_1_:                  ; [$8d53]
    .byte $40                               ; [1]: Ring of Ruby

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_2_:                  ; [$8d54]
    .byte $20                               ; [2]: Ring of Dworf

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_3_:                  ; [$8d55]
    .byte $10                               ; [3]: Demon's Ring

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_4_:                  ; [$8d56]
    .byte $08                               ; [4]: Elixir

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_5_:                  ; [$8d57]
    .byte $04                               ; [5]: Magical Rod

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_6_:                  ; [$8d58]
    .byte $02                               ; [6]: Pendant

;
; XREFS:
;     Player_LacksItem
;
SPECIAL_ITEMS_BITMASKS_7_:                  ; [$8d59]
    .byte $01                               ; [7]: Black Onyx


;============================================================================
; Show the player's status in the Player Menu.
;
; INPUTS:
;     NextPlayerTitle:
;         The next title to reach.
;
;     SelectedWeapon:
;         The start of the range of selected items.
;
;     SpecialItems:
;         The player's special items bitmask.
;
;     Joy1_ChangedButtonMask:
;         Changed button bitmask for controller 1.
;
; OUTPUTS:
;     Arg_StringsCount:
;     DataArray:
;     Temp_Int24:
;     Temp_Int24+1:
;     $ee:
;     TextBox_X:
;     TextBox_Y:
;     TextBox_Width:
;     TextBox_Height:
;     TextBox_ContentsX:
;     TextBox_ContentsY:
;         Clobbered.
;
; CALLS:
;     Screen_ResetSpritesForGamePlay
;     Player_GetInventoryBitForIndex
;     PPU_SetAddrForTextBoxPos
;     TextBox_Close
;     TextBox_DrawItemImage
;     TextBox_DrawItemName
;     TextBox_DrawZeroPaddedNumber
;     UI_DrawString
;     PlayerMenu_DrawStringLines
;     WaitForNextFrame
;
; XREFS:
;     PlayerMenu_Show
;============================================================================
PlayerMenu_ShowStatusMenu:                  ; [$8d5a]
    ;
    ; Position and open the textbox for the player status.
    ;
    LDA #$04
    STA a:TextBox_X                         ; Set textbox X coordinate to 4.
    LDA #$08
    STA a:TextBox_Y                         ; Set textbox Y coordinate to 8.
    LDA #$1a
    STA a:TextBox_Width                     ; Set textbox width to 26.
    LDA #$10
    STA a:TextBox_Height                    ; Set textbox height to 16.
    JSR TextBox_Open                        ; Open the textbox.


    ;
    ; Prepare to draw 7 strings from
    ; (PLAYER_STATUS_MENU_STRINGS)
    ; in the textbox.
    ;
    LDA #$07
    STA a:Arg_StringsCount                  ; Prepare to draw 7 rows of
                                            ; strings.
    LDA #$d3                                ; 0xD3 = lower byte of text
                                            ; strings.
    STA Temp_Int24                          ; Store it.
    LDA #$88                                ; 0x88 = upper byte of text
                                            ; strings.
    STA Temp_Int24_M                        ; Store it.
    LDX #$00                                ; X = 0 (index counter).
    STX a:DataArray                         ; Draw string 1 ("RANK:").
    INX
    STX a:DataArray_1_                      ; Draw string 2 ("NEXT EXP:").
    INX
    STX a:DataArray_2_                      ; Draw string 3 ("WEAPON:").
    INX
    STX a:DataArray_3_                      ; Draw string 4 ("ARMOR:").
    INX
    STX a:DataArray_4_                      ; Draw string 5 ("SHIELD:").
    INX
    STX a:DataArray_5_                      ; Draw string 6 ("MAGIC:").
    INX
    STX a:DataArray_6_                      ; Draw string 7 ("ITEM:").
    JSR PlayerMenu_DrawStringLines          ; Draw the strings in the
                                            ; textbox.


    ;
    ; Prepare to draw the player rank/title.
    ;
    ; Strings will be loaded from PLAYER_STATUS_MENU_TITLES.
    ;
    LDA a:TextBox_X                         ; Get the textbox X coordinate.
    CLC
    ADC #$0b                                ; Add 11.
    STA TextBox_ContentsX                   ; Set as the draw X coordinate.
    LDA a:TextBox_Y                         ; Get the textbox Y coordinate.
    CLC
    ADC #$02                                ; Add 2.
    STA TextBox_ContentsY                   ; Set as the draw Y coordinate.
    JSR PPU_SetAddrForTextBoxPos            ; Set this as the PPU draw
                                            ; position.
    LDA a:PlayerTitle                       ; Load the player title.
    JSR Math_MultiplyBy16                   ; Multiply by 16 to get an index
                                            ; into the strings.
    TAY                                     ; Y = A (result)
    LDA #$43                                ; 0x43 == lower byte of Player
                                            ; Title strings.
    STA Temp_Int24                          ; Store it.
    LDA #$89                                ; 0x89 == upper byte of Player
                                            ; Title strings.
    STA Temp_Int24_M                        ; Store it.
    JSR UI_DrawString                       ; Draw the string.


    ;
    ; Prepare to draw the player's experience.
    ;
    INC TextBox_ContentsY                   ; Go down to 2 rows.
    INC TextBox_ContentsY
    LDA a:NextPlayerTitle                   ; Load the next possible title.
    CMP #$0f                                ; Is it >= 15 (the last available
                                            ; title))?
    BCS @_drawSelectedItems                 ; If so, leave this blank and
                                            ; draw items.


    ;
    ; Look up the experience in the lookup table in bank 15.
    ;
    ; Note that we're starting our offset 2 bytes before the
    ; lookup table. This is because our X will actually be a
    ; 1-based index, normalized to 0-based in the lookup table.
    ; Each entry is a word.
    ;
    ASL A                                   ; Convert the title index to a
                                            ; word boundary.
    TAX                                     ; X = A (result).
    LDA $f749,X                             ; Load the lower byte of the
                                            ; amount of experience needed for
                                            ; the next level.
    STA Temp_Int24                          ; Store it.
    LDA $f74a,X                             ; Load the middle byte.
    STA Temp_Int24_M                        ; Store it.
    LDA #$00                                ; Upper byte is always 0.
    STA Temp_Int24_U                        ; Store it.
    LDY #$05                                ; 5 = Maximum number of digits.
    JSR TextBox_DrawZeroPaddedNumber        ; Draw the number zero-padded.


    ;
    ; Draw the selected items.
    ;
    ; In order, this will draw images and text for:
    ;
    ; 1. Weapon
    ; 2. Armor
    ; 3. Shield
    ; 4. Magic
    ;
  @_drawSelectedItems:                      ; [$8de3]
    LDX #$00                                ; X = 0 (loop counter).

  @_drawSelectedItemsLoop:                  ; [$8de5]
    TXA                                     ; A = X (loop counter)
    PHA                                     ; Push it to the stack.
    INC TextBox_ContentsY                   ; Increment the draw Y coordinate
                                            ; by 2.
    INC TextBox_ContentsY
    LDA SelectedWeapon,X                    ; Load the selected item for this
                                            ; type.
    BMI @_nextInventory                     ; If unset, advance to the next.


    ;
    ; There's a selected item of this type. Load the information.
    ;
    LDA a:TextBox_X                         ; Load the textbox X coordinate.
    CLC
    ADC #$09                                ; Add 9 (image X coordinate).
    STA TextBox_ContentsX                   ; Store as the draw X coordinate.
    TXA                                     ; A = X (loop counter).
    JSR Player_GetInventoryBitForIndex      ; Get the inventory bit for this
                                            ; index.
    ORA SelectedWeapon,X                    ; OR with the item value,
                                            ; yielding an inventory-backed
                                            ; item ID.
    PHA                                     ; Push it to the stack.


    ;
    ; Position the image and draw it.
    ;
    DEC TextBox_ContentsY                   ; Go up a row for the start of
                                            ; the image.
    JSR TextBox_DrawItemImage               ; Draw the image there.


    ;
    ; Position the item name text and draw it.
    ;
    INC TextBox_ContentsY                   ; Go down 1 rows.
    INC TextBox_ContentsX                   ; Go right 2 rows for the text.
    INC TextBox_ContentsX
    PLA                                     ; Pop the item ID.
    JSR TextBox_DrawItemName                ; Draw the name of the item.

  @_nextInventory:                          ; [$8e0f]
    PLA                                     ; Pop the X coordinate.
    TAX                                     ; Set it back on X.
    INX                                     ; X++
    CPX #$04                                ; Is it 4 (last inventory type)?
    BNE @_drawSelectedItemsLoop             ; If not, loop.


    ;
    ; Prepare to draw the special items (up to 8 in total).
    ;
    LDA a:TextBox_X                         ; Load the textbox's X location.
    CLC
    ADC #$09                                ; Add 9 (image X coordinate).
    STA TextBox_ContentsX                   ; Store it as the draw X
                                            ; coordinate.
    INC TextBox_ContentsY                   ; Increment the draw Y
                                            ; coordinate.
    LDX #$00                                ; X = 0 (loop counter)
    LDA a:SpecialItems                      ; A = Special items bitmask


    ;
    ; Draw in a loop.
    ;
  @_drawSpecialItemLoop:                    ; [$8e25]
    ASL A                                   ; Shift the left-most bit into C.
    BCC @_nextSpecialItem                   ; If not set, skip to the next
                                            ; item.
    PHA                                     ; Push the remaining bits to the
                                            ; stack.
    TXA                                     ; A = X (loop counter).
    PHA                                     ; Push the loop counter to the
                                            ; stack.
    LDA SPECIAL_ITEM_TILE_START_IDS,X       ; Load the tile start ID for this
                                            ; item.
    INX                                     ; X += 4 (number of item image
                                            ; tiles).
    INX
    INX
    INX
    JSR TextBox_DrawItemImage               ; Draw the image.
    PLA                                     ; Pop the loop counter.
    TAX                                     ; X = A (restore it)
    PLA                                     ; Pop the remaining bits.

  @_nextSpecialItem:                        ; [$8e38]
    INC TextBox_ContentsX                   ; Advance the X position by 2
                                            ; tiles.
    INC TextBox_ContentsX
    INX                                     ; X++ (loop counter)
    CPX #$08                                ; Is it 8?
    BNE @_drawSpecialItemLoop               ; If not, loop.


    ;
    ; Draw the menu, freezing gameplay until dismissed.
    ;
  @_waitForInputLoop:                       ; [$8e41]
    JSR WaitForNextFrame                    ; Wait for the next frame.
    JSR Screen_ResetSpritesForGamePlay      ; Draw with screen state paused.
    LDA Joy1_ChangedButtonMask              ; Load the changed button mask.
    ASL A                                   ; Shift the "A" button state into
                                            ; N.
    BPL @_waitForInputLoop                  ; If not pressed/set, loop.


    ;
    ; Close the Status textbox.
    ;
    LDA #$02
    STA a:TextBox_X                         ; Set the textbox X to 2.
    LDA #$06
    STA a:TextBox_Y                         ; Set the textbox Y to 6.
    LDA #$1c
    STA a:TextBox_Width                     ; Set the textbox width to 28.
    LDA #$12
    STA a:TextBox_Height                    ; Set the textbox height to 18.
    JMP TextBox_Close                       ; Close the textbox at those
                                            ; dimensions.


;============================================================================
; Start locations within loaded drawn item tiles in the PPU.
;
; XREFS:
;     PlayerMenu_ShowStatusMenu
;============================================================================

;
; XREFS:
;     PlayerMenu_ShowStatusMenu
;
SPECIAL_ITEM_TILE_START_IDS:                ; [$8e63]
    .byte $80                               ; [0]:
    .byte $81                               ; [1]:
    .byte $82                               ; [2]:
    .byte $83                               ; [3]:
    .byte $92                               ; [4]:
    .byte $8a                               ; [5]:
    .byte $93                               ; [6]:
    .byte $94                               ; [7]:

;============================================================================
; TODO: Document PlayerMenu_DrawStringLines
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PlayerMenu_Show
;     PlayerMenu_ShowStatusMenu
;============================================================================
PlayerMenu_DrawStringLines:                 ; [$8e6b]
    LDA a:TextBox_X
    CLC
    ADC #$02
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    CLC
    ADC #$02
    STA TextBox_ContentsY
    JSR PPU_SetAddrForTextBoxPos
    LDX #$00

  @_drawLinesLoop:                          ; [$8e80]
    TXA
    PHA
    LDA DataArray,X
    ASL A
    ASL A
    ASL A
    ASL A
    TAY
    JSR UI_DrawString
    LDA #$40
    JSR PPU_IncrementAddrBy
    PLA
    TAX
    INX
    CPX a:Arg_StringsCount
    BNE @_drawLinesLoop
    RTS


;============================================================================
; Draw a length-prefixed string to the PPU.
;
; This will draw a string stored in Temp_Int24. The
; first byte must be the length of the string, and the
; remaining are ASCII characters for the string.
;
; INPUTS:
;     X:
;         The PPU buffer offset to write to.
;
;     Y:
;         The starting offset into the loaded string buffer.
;
;     Temp_Int24:
;         The loaded address containing the string at the
;         offset.
;
; OUTPUTS:
;     PPUBuffer_WriteOffset:
;         The new upper bounds of the PPU buffer.
;
;     Temp_Int24:
;         Clobbered.
;
; CALLS:
;     Strings_ASCIIToIndex
;     PPUBuffer_Set
;     PPUBuffer_QueueCommandOrLength
;
; XREFS:
;     PlayerMenu_DrawStringLines
;     PlayerMenu_ShowStatusMenu
;     PlayerMenu_ShowSubmenu
;     TextBox_DrawItemName
;============================================================================
UI_DrawString:                              ; [$8e9b]
    ;
    ; Load the length of the string and prepare to draw.
    ;
    LDA (Temp_Int24),Y                      ; Load the length value from the
                                            ; loaded string.
    STA Temp_Int24_U                        ; Store it.
    INY                                     ; Y++ (character offset)
    JSR PPUBuffer_QueueCommandOrLength      ; Queue drawing up to the length.


    ;
    ; Begin drawing each character.
    ;
  @_drawLoop:                               ; [$8ea3]
    LDA (Temp_Int24),Y                      ; Load the next character.
    JSR Strings_ASCIIToIndex                ; Conver the ASCII value to a
                                            ; tile index.
    INY                                     ; Y++ (character offset)
    JSR PPUBuffer_Set                       ; Set that in the PPU buffer.
    DEC Temp_Int24_U                        ; Decrement loop counter.
    BNE @_drawLoop                          ; If we're not done, loop.
    STX PPUBuffer_WriteOffset               ; Store the new PPU buffer upper
                                            ; bounds.
    RTS


;============================================================================
; Return an alphanumeric/symbol tile index from an ASCII value.
;
; INPUTS:
;     A:
;         The ASCII value to normalize.
;
; OUTPUTS:
;     A:
;         The normalized value.
;
; XREFS:
;     UI_DrawString
;============================================================================
Strings_ASCIIToIndex:                       ; [$8eb3]
    CMP #$20                                ; Is this a space?
    BEQ @_isSpace                           ; If so, jump.
    CMP #$41                                ; Is this >= "A"?
    BCC @_return                            ; If not, return.
    SBC #$31                                ; Convert to an index.
    RTS

  @_isSpace:                                ; [$8ebe]
    LDA #$00                                ; Convert a space to an index of
                                            ; 0.

  @_return:                                 ; [$8ec0]
    RTS

;============================================================================
; TODO: Document IScriptAction_AddInventoryItem_ClearTextBox
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_AddInventoryItem
;============================================================================
IScriptAction_AddInventoryItem_ClearTextBox: ; [$8ec1]
    LDX a:TextBox_X
    INX
    STX TextBox_ContentsX
    LDX a:TextBox_Y
    INX
    STX TextBox_ContentsY
    JSR PPU_SetAddrForTextBoxPos
    LDX a:TextBox_Height

  @_clearLoop:                              ; [$8ed3]
    TXA
    PHA
    LDA a:TextBox_Width
    TAY
    SEC
    SBC #$02
    JSR PPUBuffer_QueueCommandOrLength
    LDA #$00
    JSR TextBox_FillPPUBufferForTextWidth
    STX PPUBuffer_WriteOffset
    JSR PPU_IncrementAddrBy32
    PLA
    TAX
    DEX
    CPX #$02
    BNE @_clearLoop
    RTS
;============================================================================
; TODO: Document TextBox_Open
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScripts_OpenForPortrait
;     PlayerMenu_Show
;     PlayerMenu_ShowStatusMenu
;     PlayerMenu_ShowSubmenu
;     Shop_Draw
;     TextBox_OpenForNPC
;============================================================================
TextBox_Open:                               ; [$8ef1]
    ;
    ; Draw the top row of the box's frame.
    ;
    LDA a:TextBox_X
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    STA TextBox_ContentsY
    JSR PPU_SetAddrForTextBoxPos
    JSR TextBox_QueuePPUBufferTextBoxLength
    LDA #$01
    JSR PPUBuffer_Set
    LDA #$02
    JSR TextBox_FillPPUBufferForTextWidth
    LDA #$03
    JSR PPUBuffer_Set
    STX PPUBuffer_WriteOffset
    JSR PPU_IncrementAddrBy32


    ;
    ; Draw the sides of the box's frame.
    ;
    LDY a:TextBox_Height

  @_drawFrameSides:                         ; [$8f18]
    TYA
    PHA
    JSR TextBox_QueuePPUBufferTextBoxLength
    LDA #$04
    JSR PPUBuffer_Set
    LDA #$00
    JSR TextBox_FillPPUBufferForTextWidth
    LDA #$04
    JSR PPUBuffer_Set
    STX PPUBuffer_WriteOffset
    JSR PPU_IncrementAddrBy32
    PLA
    TAY
    DEY
    CPY #$02
    BNE @_drawFrameSides


    ;
    ; Draw the bottom of the box's frame.
    ;
    JSR TextBox_QueuePPUBufferTextBoxLength
    LDA #$05
    JSR PPUBuffer_Set
    LDA #$02
    JSR TextBox_FillPPUBufferForTextWidth
    LDA #$06
    JSR PPUBuffer_Set
    STX PPUBuffer_WriteOffset
    LDA #$00


    ;
    ; Set state on the box and fill in the background.
    ;
    STA a:TextBox_Closed

    ;
    ; v-- Fall through --v
    ;

;============================================================================
; TODO: Document TextBox_FillBackground
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     TextBox_Close
;============================================================================
TextBox_FillBackground:                     ; [$8f51]
    LDA a:TextBox_X
    LSR A
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    LSR A
    STA TextBox_ContentsY
    LDY a:TextBox_Height

  @_fillYLoop:                              ; [$8f60]
    TYA
    PHA
    LDA TextBox_ContentsX
    PHA
    LDY a:TextBox_Width

  @_fillXLoop:                              ; [$8f68]
    JSR TextBox_GetBackgroundAttributeData
    JSR TextBox_SetNextAttributeData
    INC TextBox_ContentsX
    DEY
    DEY
    BNE @_fillXLoop
    PLA
    STA TextBox_ContentsX
    INC TextBox_ContentsY
    PLA
    TAY
    DEY
    DEY
    BNE @_fillYLoop
    LDA a:TextBox_X
    LSR A
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    LSR A
    STA TextBox_ContentsY
    JSR TextBox_GetNextAttributeDataOffset
    TAY
    AND #$3f
    ORA #$c0
    STA PPU_TargetAddr
    LDA PPU_ScrollScreen
    AND #$01
    ASL A
    ASL A
    ORA #$23
    STA PPU_TargetAddr_U
    LDA a:TextBox_X
    LSR A
    LSR A
    STA TextBox_ContentsX
    LDA a:TextBox_X
    CLC
    ADC a:TextBox_Width
    SEC
    SBC #$01
    LSR A
    LSR A
    SEC
    SBC TextBox_ContentsX
    STA TextBox_ContentsX
    INC TextBox_ContentsX
    LDA a:TextBox_Y
    LSR A
    LSR A
    STA TextBox_ContentsY
    LDA a:TextBox_Y
    CLC
    ADC a:TextBox_Height
    SEC
    SBC #$01
    LSR A
    LSR A
    SEC
    SBC TextBox_ContentsY
    STA TextBox_ContentsY
    INC TextBox_ContentsY


    ;
    ; Loop through all the rows of text.
    ;
  @_drawRowsLoop:                           ; [$8fd3]
    TYA
    PHA
    LDA TextBox_ContentsX
    STA Temp_Int24
    JSR PPUBuffer_QueueCommandOrLength


    ;
    ; Loop through all the columns of text.
    ;
  @_drawColsLoop:                           ; [$8fdc]
    LDA TextBox_AttributeData,Y
    INY
    JSR PPUBuffer_Set
    DEC Temp_Int24
    BNE @_drawColsLoop
    STX PPUBuffer_WriteOffset
    JSR PPU_IncrementAddrBy8
    PLA
    CLC
    ADC #$08
    TAY
    DEC TextBox_ContentsY
    BNE @_drawRowsLoop
    RTS


;============================================================================
; Return the background PPU attribute data for the textbox at an offset.
;
; If the textbox is closed, this will use the tile behind
; the textbox.
;
; If the textbox is open, it will use the HUD background.
;
; INPUTS:
;     Y:
;         The offset into the screen.
;
;     UI_AttributeDataIndex:
;         The attribute data for the HUD/textbox background.
;
;     TextBox_Closed:
;         Whether the textbox is closed.
;
; OUTPUTS:
;     A:
;         The attribute data to draw at the offset.
;
; CALLS:
;     TextBox_GetBackingAttributeData
;
; XREFS:
;     TextBox_FillBackground
;============================================================================
TextBox_GetBackgroundAttributeData:         ; [$8ff6]
    LDA a:TextBox_Closed                    ; Is the textbox open or closed?
    BEQ @_isOpen                            ; If open, jump.


    ;
    ; The textbox is closed. Return the attribute of the background
    ; area behind it.
    ;
    JMP TextBox_GetBackingAttributeData     ; Return the attribute data
                                            ; behind the textbox.


    ;
    ; The textbox is open. Return the attribute for the textbox
    ; background color.
    ;
  @_isOpen:                                 ; [$8ffe]
    LDA a:UI_AttributeDataIndex             ; Return the attribute data for
                                            ; the background of the textbox.
    RTS

;============================================================================
; TODO: Document TextBox_Close
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     DEADCODE_TextBox_ClosePortrait
;     IScriptAction_ShowSellMenu
;     IScripts_CloseCurrentTextBox
;     Maybe_Shop_DrawTextBox
;     PlayerMenu_Close
;     PlayerMenu_Show
;     PlayerMenu_ShowStatusMenu
;     TextBox_ClearForPortraitAndText
;============================================================================
TextBox_Close:                              ; [$9002]
    LDA #$01
    STA a:TextBox_Closed
    JSR TextBox_FillBackground
    LDA a:TextBox_X
    STA TextBox_ContentsX
    LDA a:TextBox_Y
    STA TextBox_ContentsY
    JSR PPU_SetAddrForTextBoxPos
    LDY a:TextBox_Height

  @_closeYLoop:                             ; [$901a]
    TYA
    PHA
    LDA TextBox_ContentsX
    PHA
    LDA a:TextBox_Width
    TAY
    JSR PPUBuffer_QueueCommandOrLength

  @_closeXLoop:                             ; [$9026]
    JSR Textbox_Maybe_GetAreaBehindTextbox
    JSR PPUBuffer_Set
    INC TextBox_ContentsX
    DEY
    BNE @_closeXLoop
    STX PPUBuffer_WriteOffset
    PLA
    STA TextBox_ContentsX
    PLA
    TAY
    INC TextBox_ContentsY
    JSR PPU_IncrementAddrBy32
    DEY
    BNE @_closeYLoop
    RTS


;============================================================================
; DEADCODE
;============================================================================
DEADCODE_FUN_PRG12__9041:                   ; [$9041]
    LDA #$05
    STA TextBox_ContentsX
    JSR PPUBuffer_QueueCommandOrLength

  @LAB_PRG12__9048:                         ; [$9048]
    LDA TextBox_AttributeData,Y
    INY
    JSR PPUBuffer_Set
    DEC TextBox_ContentsX
    BNE @LAB_PRG12__9048
    STX PPUBuffer_WriteOffset
    RTS

;============================================================================
; TODO: Document Menu_UpdateAndDraw
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_ShowBuySellMenu
;     IScripts_WaitForMenuInput
;     PlayerMenu_HandleInventoryMenuInput
;     PlayerMenu_Show
;============================================================================
Menu_UpdateAndDraw:                         ; [$9056]
    LDA Joy1_ChangedButtonMask              ; A = changed button mask.
    AND #$08                                ; Is Up pressed?
    BNE @_handleCursorUp                    ; If so, jump.


    ;
    ; Up was not pressed. Check Down.
    ;
    LDA Joy1_ChangedButtonMask              ; A = changed button mask.
    AND #$04                                ; Is Down pressed?
    BEQ @_showSelectionCursor               ; If so, jump.


    ;
    ; Neither Up nor Down was pressed.
    ;
    LDX a:Menu_CursorPos                    ; X = Menu cursor position.
    INX                                     ; X++
    CPX a:Arg_StringsCount                  ; Compare to the last available
                                            ; position.
    BNE @_moveCursor                        ; If it changed, jump.
    LDX #$00                                ; Move to the first item.

  @_moveCursor:                             ; [$906d]
    STX a:Menu_CursorPos                    ; Set the new cursor position.
    LDA #$0b                                ; 0xB = Cursor movement sound
                                            ; effect.
    JSR Sound_PlayEffect                    ; Play the sound effect.


    ;
    ; Draw the selection cursor for a shop.
    ;
    ; This will draw the selection cursor, pointing to the Buy/Sell
    ; item or the item in a shop.
    ;
    ; First, compute the X position of the cursor.
    ;
  @_showSelectionCursor:                    ; [$9075]
    JSR TextBox_GetXPixelCoord              ; Get the X pixel position of the
                                            ; textbox.
    ADC #$08                                ; Add 8 (offset).
    TAX                                     ; X = result.


    ;
    ; Compute the Y position of the cursor.
    ;
    ; This will be:
    ;
    ;     TextBox_Y_Pixels + (16 * CursorPos) - 32.
    ;
    JSR TextBox_GetYPixelCoord              ; Get the Y pixel position of the
                                            ; textbox.
    ADC #$10                                ; Add 16.
    STA Temp_Int24                          ; Store it temporarily.
    LDA a:Menu_CursorPos                    ; A = cursor position.
    JSR Math_MultiplyBy16                   ; A = A * 16 (2 tile height)
    ADC Temp_Int24                          ; A = A + our Y value.
    SBC #$20                                ; A = A - 32 (padding and nudging
                                            ; up a tile).
    TAY                                     ; Y = result.


    ;
    ; Draw the selection symbol.
    ;
    LDA #$ad                                ; A = 0xAD (right arrow symbol).
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.


    ;
    ; The player pressed the Up button on the controller.
    ; Move the cursor up.
    ;
  @_handleCursorUp:                         ; [$9092]
    LDX a:Menu_CursorPos                    ; X = Menu cursor position.


    ;
    ; Set up a loop to move the cursor to a viable spot.
    ;
    ; Note that we have two possibilities here, based on
    ; Arg_StringsCount:
    ;
    ; 1. It has a non-0 value, in which case we stay in this
    ;    cursor loop and handle cursor movement.
    ;
    ;    This is the case with textbox menus and shops.
    ;
    ; 2. It has a 0 value, in which case we're going to fall
    ;    through to more advanced input.
    ;
    ;    This is only used in the password screen.
    ;
  @_cursorLoop:                             ; [$9095]
    DEX                                     ; X--
    BPL @_moveCursor                        ; If < 0, jump.
    LDX a:Arg_StringsCount                  ; X = Last available position.
    BPL @_cursorLoop                        ; If < 0, loop. Else, fall
                                            ; through (only for the password
                                            ; screen).

    ;
    ; v-- Fall through --v
    ;

;============================================================================
; TODO: Document PasswordScreen_Show
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;============================================================================
PasswordScreen_Show:                        ; [$909d]
    JSR PPU_WaitUntilFlushed
    LDA #$10
    STA a:PPUADDR
    LDA #$00
    STA a:PPUADDR
    LDY #$10
    JSR PPU_FillData
    JSR PPU_LoadGlyphsForStrings
    LDY #$1f

  @LAB_PRG12__90b4:                         ; [$90b4]
    LDA PASSWORD_SCREEN_PALETTE,Y
    STA Screen_PaletteData_Tiles,Y
    DEY
    BPL @LAB_PRG12__90b4
    JSR PPUBuffer_WritePalette
    JSR PPU_ClearAllTilemaps


    ;
    ; Set the position to the first character of the first row of
    ; the password screen. This starts at $2128.
    ;
    ; Then draw the field (16 characters).
    ;
    LDA #$21
    STA a:PPUADDR
    LDA #$28
    STA a:PPUADDR
    LDA #$5f
    LDY #$10
    JSR PPU_FillData


    ;
    ; Now do the same for the second row of the password input at
    ; $2148.
    ;
    LDA #$21
    STA a:PPUADDR
    LDA #$48
    STA a:PPUADDR
    LDA #$5f
    LDY #$10
    JSR PPU_FillData


    ;
    ; Begin drawing all the available password characters.
    ;
    LDY #$00


    ;
    ; Set the cursor position for the start of the row of
    ; available password characters based on the first two
    ; bytes of the current offset into INPUT_CHARS.
    ;
  @_startRow:                               ; [$90e7]
    LDA INPUT_CHARS,Y
    STA a:PPUADDR
    INY
    LDA INPUT_CHARS,Y
    STA a:PPUADDR
    INY


    ;
    ; Every row has 25 characters (this includes spaces between
    ; visible characters). Loop through each character draw it
    ; on the current row.
    ;
    LDX #$19

  @_writePasswordCharsLoop:                 ; [$90f7]
    LDA INPUT_CHARS,Y
    STA a:PPUDATA
    INY
    DEX
    BNE @_writePasswordCharsLoop
    CPY #$a2
    BNE @_startRow


    ;
    ; Begin writing the top row: "Enter your mantra."
    ; This starts at PPU position $20A5.
    ;
    ; The string is at STRING_ENTER_YOUR_MANTRA.
    ;
    LDA #$20
    STA a:PPUADDR
    LDA #$a5
    STA a:PPUADDR
    LDA #$ec
    STA Temp_Int24
    LDA #$91
    STA Temp_Int24_M
    JSR UI_DrawText


    ;
    ; Set the initial password to 32 characters of empty (0xFF).
    ;
    ; This is in Password_EnteredChars.
    ;
    LDA #$20
    STA a:Password_MaxChars
    TAX
    DEX
    LDA #$ff

  @LAB_PRG12__9123:                         ; [$9123]
    STA ScreenBuffer,X
    DEX
    BPL @LAB_PRG12__9123
    LDA #$00
    STA a:Password_EnteredCharsLength
    STA a:Password_FieldCursorPos
    STA a:Password_CursorCol
    STA a:Password_CursorRow
    STA a:Password_DPadBits
    STA a:Password_CounterBeforeAutoRepeatMove


    ;
    ; Handle password input.
    ;
    JSR Screen_ResetForNonGame

    ;
    ; v-- Fall through --v
    ;

;============================================================================
; TODO: Document PasswordScreen_WaitForInput
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_9175
;     PasswordScreen_HandleInput
;     PasswordScreen_HandleWrongPasswordAndWaitForInput
;     PasswordScreen_WaitForInput
;============================================================================
PasswordScreen_WaitForInput:                ; [$9140]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR PasswordScreen_DrawAndHandleInputLoop
    BCC PasswordScreen_WaitForInput
    CMP #$83
    BNE PasswordScreen_HandleInput


    ;
    ; This is the END code.
    ;
    LDA a:Password_EnteredCharsLength
    BEQ PasswordScreen_9175
    JSR Password_Maybe_CheckPasswordLength
    BCS PasswordScreen_HandleWrongPasswordAndWaitForInput
    JSR Password_Load
    BCS PasswordScreen_HandleWrongPasswordAndWaitForInput
    RTS

;============================================================================
; TODO: Document PasswordScreen_HandleWrongPasswordAndWaitForInput
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
PasswordScreen_HandleWrongPasswordAndWaitForInput: ; [$915f]
    JSR Sound_PlayInputSound

  @_handleWrongPassword:                    ; [$9162]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR PasswordScreen_WriteWrongPassword
    LDA Joy1_ChangedButtonMask
    BPL @_handleWrongPassword
    JSR PasswordScreen_WriteEnterYourMantra
    JMP PasswordScreen_WaitForInput

;============================================================================
; TODO: Document PasswordScreen_9175
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
PasswordScreen_9175:                        ; [$9175]
    JSR Sound_PlayInputSound                ; Play the character input sound.
    JMP PasswordScreen_WaitForInput         ; Wait for input.

;============================================================================
; TODO: Document PasswordScreen_HandleInput
;
; INPUTS:
;     A
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
PasswordScreen_HandleInput:                 ; [$917b]
    JSR PasswordScreen_HandleInputChar      ; Handle the character.
    JMP PasswordScreen_WaitForInput         ; Wait again for input.


;============================================================================
; Write the "Enter your mantra" message.
;
; INPUTS:
;     X:
;         Destination offset into the PPU buffer.
;
;     InterruptCounter:
;         The game interrupt counter.
;
;     PASSWORD_MESSAGE_STRINGS_U:
;     PASSWORD_MESSAGE_STRINGS_U:
;         The lookup table of message strings.
;
; OUTPUTS:
;     PPUBuffer_WriteOffset:
;         New upper bounds of the PPU buffer.
;
;     PPU_TargetAddr:
;     PPU_TargetAddr+1:
;     Temp_Int24:
;     Temp_Int24+1:
;         Clobbered.
;
; CALLS:
;     PPUBuffer_QueueCommandOrLength
;     PPUBuffer_WriteFromTemp
;
; XREFS:
;     PasswordScreen_HandleWrongPasswordAndWaitForInput
;============================================================================
PasswordScreen_WriteEnterYourMantra:        ; [$9181]
    LDY #$02                                ; 2 = "Enter your mantra"
    BNE PasswordScreen_DrawMessage          ; Draw it.

    ;
    ; X-- We should never fall through here --X
    ;


;============================================================================
; Write the message stating that the password was wrong.
;
; This will display in a blinking form, alternating between
; empty spaces and the message.
;
; INPUTS:
;     X:
;         Destination offset into the PPU buffer.
;
;     InterruptCounter:
;         The game interrupt counter.
;
;     PASSWORD_MESSAGE_STRINGS_U:
;     PASSWORD_MESSAGE_STRINGS_U:
;         The lookup table of message strings.
;
; OUTPUTS:
;     PPU_TargetAddr:
;     PPU_TargetAddr+1:
;     Temp_Int24:
;     Temp_Int24+1:
;         Clobbered.
;
; CALLS:
;     PPUBuffer_QueueCommandOrLength
;     PPUBuffer_WriteFromTemp
;
; XREFS:
;     PasswordScreen_HandleWrongPasswordAndWaitForInput
;============================================================================
PasswordScreen_WriteWrongPassword:          ; [$9185]
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$1f                                ; Check if we're on an animation
                                            ; frame.
    BNE RETURN_91B7                         ; If not, return.


    ;
    ; Calculate the string index based on the frame.
    ;
    LDA InterruptCounter                    ; Load the interrupt counter
                                            ; again.
    LSR A                                   ; Compute a message index based
                                            ; on the interval.
    LSR A
    LSR A
    LSR A
    LSR A
    AND #$01
    TAY                                     ; Y = message string index

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Draw a message on the password screen.
;
; INPUTS:
;     Y:
;         The message ID. This is one of:
;
;         0 = "Mantra is in the wrong"
;         1 = Blank spaces (to blink a message)
;         2 = "  Enter your mantra.  "
;
;     PASSWORD_MESSAGE_STRINGS_L:
;     PASSWORD_MESSAGE_STRINGS_U:
;         The available message strings table.
;
; OUTPUTS:
;     PPUBuffer_WriteOffset:
;         The new write offset for the PPU buffer.
;
;     PPU_TargetAddr:
;     PPU_TargetAddr+1:
;         Clobbered.
;
; CALLS:
;     PPUBuffer_QueueCommandOrLength
;     PPUBuffer_WriteFromTemp
;
; XREFS:
;     PasswordScreen_WriteEnterYourMantra
;============================================================================
PasswordScreen_DrawMessage:                 ; [$9195]
    ;
    ; Load the message string.
    ;
    LDA PASSWORD_MESSAGE_STRINGS_L,Y        ; Load the lower byte of the
                                            ; string address.
    STA Temp_Int24                          ; Store that.
    LDA PASSWORD_MESSAGE_STRINGS_U,Y        ; Load the upper byte of the
                                            ; string address.
    STA Temp_Int24_M                        ; Store that.


    ;
    ; Set the PPU tile address to 0x20A5.
    ;
    LDA #$20
    STA PPU_TargetAddr_U                    ; Upper byte = 0x20
    LDA #$a5
    STA PPU_TargetAddr                      ; Lower byte = 0xA5


    ;
    ; Queue up a string of 23 characters.
    ;
    LDA #$17
    JSR PPUBuffer_QueueCommandOrLength      ; Queue 23 characters to draw.


    ;
    ; Begin the draw loop.
    ;
    LDY #$00                                ; Y = 0 (loop counter)

  @LAB_PRG12__91ae:                         ; [$91ae]
    JSR PPUBuffer_WriteFromTemp             ; Put the next character from our
                                            ; loaded string into the PPU
                                            ; buffer.
    CPY #$17                                ; Have we written 23 characters?
    BNE @LAB_PRG12__91ae                    ; If not, loop.
    STX PPUBuffer_WriteOffset               ; Store the new upper bounds of
                                            ; the PPU buffer.

    ;
    ; XREFS:
    ;     PasswordScreen_WriteWrongPassword
    ;
RETURN_91B7:                                ; [$91b7]
    RTS


;============================================================================
; Lookup table for password screen strings.
;
; XREFS:
;     PasswordScreen_DrawMessage
;============================================================================

;
; XREFS:
;     PasswordScreen_DrawMessage
;
PASSWORD_MESSAGE_STRINGS_L:                 ; [$91b8]
    .byte $be                               ; [0]:
    .byte $d5                               ; [1]:
    .byte $ec                               ; [2]:

;
; XREFS:
;     PasswordScreen_DrawMessage
;
PASSWORD_MESSAGE_STRINGS_U:                 ; [$91bb]
    .byte $91                               ; [0]:
    .byte $91                               ; [1]:
    .byte $91                               ; [2]:


;============================================================================
; String: "Mantra is in the wrong."
;
; This is used whenever an incorrect password was entered.
;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91b8]
;============================================================================

;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91b8]
;
STRING_MANTRA_IN_THE_WRONG:                 ; [$91be]
    .byte "Mantra i"                        ; [$91be] char
    .byte "s in the"                        ; [$91c6] char
    .byte " wrong."                         ; [$91ce] char


;============================================================================
; String: Empty spaces
;
; This is part of the blink animation for the invalid password text.
;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91b9]
;============================================================================

;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91b9]
;
STRING_PASSWORD_SPACES:                     ; [$91d5]
    .byte "        "                        ; [$91d5] char
    .byte "        "                        ; [$91dd] char
    .byte "       "                         ; [$91e5] char


;============================================================================
; String: "Enter your mantra."
;
; This is shown at the top of the password screen.
;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91ba]
;============================================================================

;
; XREFS:
;     PASSWORD_MESSAGE_STRINGS_L [$PRG12::91ba]
;
STRING_ENTER_YOUR_MANTRA:                   ; [$91ec]
    .byte "  Enter "                        ; [$91ec] char
    .byte "your man"                        ; [$91f4] char
    .byte "tra.   ",$00                     ; [$91fc] char


;============================================================================
; Palette data for the password screen.
;============================================================================
PASSWORD_SCREEN_PALETTE:                    ; [$9204]
    .byte $0f                               ; [0]:
    .byte $00                               ; [1]:
    .byte $10                               ; [2]:
    .byte $20                               ; [3]:
    .byte $0f                               ; [4]:
    .byte $00                               ; [5]:
    .byte $10                               ; [6]:
    .byte $20                               ; [7]:
    .byte $0f                               ; [8]:
    .byte $00                               ; [9]:
    .byte $10                               ; [10]:
    .byte $20                               ; [11]:
    .byte $0f                               ; [12]:
    .byte $0f                               ; [13]:
    .byte $0f                               ; [14]:
    .byte $0f                               ; [15]:
    .byte $0f                               ; [16]:
    .byte $0f                               ; [17]:
    .byte $27                               ; [18]:
    .byte $30                               ; [19]:
    .byte $0f                               ; [20]:
    .byte $06                               ; [21]:
    .byte $16                               ; [22]:
    .byte $26                               ; [23]:
    .byte $0f                               ; [24]:
    .byte $06                               ; [25]:
    .byte $16                               ; [26]:
    .byte $26                               ; [27]:
    .byte $0f                               ; [28]:
    .byte $0f                               ; [29]:

;
; XREFS:
;     PasswordScreen_Show
;
PASSWORD_SCREEN_PALETTE_30_:                ; [$9222]
    .byte $0f                               ; [30]:

;
; XREFS:
;     PasswordScreen_Show
;
PASSWORD_SCREEN_PALETTE_31_:                ; [$9223]
    .byte $0f                               ; [31]:


;============================================================================
; Available list of input characters for the password screen, broken down by
; row.
;
; XREFS:
;     PasswordScreen_Show
;============================================================================

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS:                                ; [$9224]
    .byte $21                               ; [0]: [0]:

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS_ppuAddr_1_:                     ; [$9225]
    .byte $c4                               ; [0]: [1]:

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS_chars:                          ; [$9226]
    .byte "A"                               ; [$9226] char

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS_chars_1_:                       ; [$9227]
    .byte " "                               ; [$9227] char

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS_chars_2_:                       ; [$9228]
    .byte "B"                               ; [$9228] char

;
; XREFS:
;     PasswordScreen_Show
;
INPUT_CHARS_chars_3_:                       ; [$9229]
    .byte " C D E F"                        ; [$9229] char
    .byte " G H I J"                        ; [$9231] char
    .byte " K L M"                          ; [$9239] char

    .byte $22                               ; [1]: [0]:
    .byte $04                               ; [1]: [1]:
    .byte "N O P Q "                        ; [$9241] char
    .byte "R S T U "                        ; [$9249] char
    .byte "V W X Y "                        ; [$9251] char
    .byte "Z"                               ; [$9259] char

    .byte $22                               ; [2]: [0]:
    .byte $44                               ; [2]: [1]:
    .byte "a b c d "                        ; [$925c] char
    .byte "e f g h "                        ; [$9264] char
    .byte "i j k l "                        ; [$926c] char
    .byte "m"                               ; [$9274] char

    .byte $22                               ; [3]: [0]:
    .byte $84                               ; [3]: [1]:
    .byte "n o p q "                        ; [$9277] char
    .byte "r s t u "                        ; [$927f] char
    .byte "v w x y "                        ; [$9287] char
    .byte "z"                               ; [$928f] char

    .byte $22                               ; [4]: [0]:
    .byte $c4                               ; [4]: [1]:
    .byte "0 1 2 3 "                        ; [$9292] char
    .byte "4 5 6 7 "                        ; [$929a] char
    .byte "8 9 , ? "                        ; [$92a2] char
    .byte " "                               ; [$92aa] char

    .byte $23                               ; [5]: [0]:
    .byte $04                               ; [5]: [1]:
    .byte "{|} ~|",$7f," "                  ; [$92ad] char
    .byte "DEL END "                        ; [$92b5] char
    .byte "        "                        ; [$92bd] char
    .byte " "                               ; [$92c5] char


;============================================================================
; PPU tile positions for each input character cursor position.
;
; XREFS:
;     PasswordScreen_WriteCharTile
;============================================================================

;
; XREFS:
;     PasswordScreen_WriteCharTile
;
PASSWORD_CURSOR_START_PPU_ADDRS_L:          ; [$92c6]
    .byte $28                               ; [0]:
    .byte $48                               ; [1]:

;
; XREFS:
;     PasswordScreen_WriteCharTile
;
PASSWORD_CURSOR_START_PPU_ADDRS_U:          ; [$92c8]
    .byte $21                               ; [0]:
    .byte $21                               ; [1]:
;============================================================================
; TODO: Document PasswordScreen_DrawPasswordFieldCursor
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_DrawAndHandleInputLoop
;============================================================================
PasswordScreen_DrawPasswordFieldCursor:     ; [$92ca]
    ;
    ; Only proceed if the interrupt counter's lower nibble is set.
    ;
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$0f                                ; Keep the lower nibble.
    BNE RETURN_9311                         ; If > 0, return.


    ;
    ; Check whether to draw the character or the cursor.
    ;
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$10                                ; Is bit 5 set?
    BEQ PasswordScreen_DrawAtCursorPosition ; If set, jump to write the
                                            ; character.


    ;
    ; Draw the cursor.
    ;
    LDA #$60                                ; 0x60 == Solid block (cursor)
    JMP PasswordScreen_WriteCharTile        ; Draw it.


;============================================================================
; Draw the character at the current cursor position.
;
; If the cursor's on a position without an inputted
; character, a "_" will be drawn instead.
;
; This jumps/falls through to
; PasswordScreen_WriteCharTile.
;
; INPUTS:
;     Password_FieldCursorPos:
;         The cursor position.
;
;     ScreenBuffer:
;         The entered characters buffer.
;
;     PASSWORD_ENTERED_CHARS:
;         The lookup table of character codes to display tiles.
;
; OUTPUTS:
;     See fall-through.
;
; CALLS:
;     PasswordScreen_WriteCharTile
;
; XREFS:
;     PasswordScreen_DrawPasswordFieldCursor
;     PasswordScreen_HandleDeleteAtCursor
;     PasswordScreen_HandleDeleteLastChar
;     PasswordScreen_HandleInputChar
;     PasswordScreen_HandleMoveCursorLeft
;     PasswordScreen_HandleMoveCursorRight
;============================================================================
PasswordScreen_DrawAtCursorPosition:        ; [$92db]
    ;
    ; Check the character at the cursor position.
    ;
    LDX a:Password_FieldCursorPos           ; X = Cursor position.
    LDA ScreenBuffer,X                      ; A = Character at that position.
    CMP #$ff                                ; Is it 0xFF (unset)?
    BEQ @_writeBlankChar                    ; If not, jump.


    ;
    ; There's no character at this position.
    ;
    TAX                                     ; X = A (character offset)
    LDA PASSWORD_ENTERED_CHARS,X            ; Get the character value for
                                            ; that offset.
    BPL PasswordScreen_WriteCharTile        ; Write it.

  @_writeBlankChar:                         ; [$92eb]
    LDA #$5f                                ; 0x5F == "_" (blank) character

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Write the tile for the given character to the PPU buffer.
;
; INPUTS:
;     A:
;         The index of the character in the password tiles
;         table.
;
;     Password_FieldCursorPos:
;         The 0-based index of the cursor in the password
;         field.
;
;     PASSWORD_CURSOR_START_PPU_ADDRS_U:
;     PASSWORD_CURSOR_START_PPU_ADDRS_L:
;         The address lookup tables for the character tiles.
;
; OUTPUTS:
;     PPUBuffer_WriteOffset:
;         The updated write offset for the PPU buffer.
;
;     PPU_TargetAddr:
;     PPU_TargetAddr+1:
;         Clobbered.
;
; CALLS:
;     PPUBuffer_QueueCommandOrLength
;     PPUBuffer_Set
;
; XREFS:
;     PasswordScreen_DrawAtCursorPosition
;     PasswordScreen_DrawPasswordFieldCursor
;============================================================================
PasswordScreen_WriteCharTile:               ; [$92ed]
    PHA                                     ; Push the tile value to the
                                            ; stack.


    ;
    ; Determine the index to draw to for the cursor position.
    ;
    LDA a:Password_FieldCursorPos           ; Load the cursor position in the
                                            ; password field.
    LSR A                                   ; Divide by 16.
    LSR A
    LSR A
    LSR A


    ;
    ; Look up the PPU address for that index.
    ;
    TAY                                     ; Y = A
    LDA PASSWORD_CURSOR_START_PPU_ADDRS_U,Y ; A = Upper byte of the PPU
                                            ; address for this position.
    STA PPU_TargetAddr_U                    ; Store it.
    LDA a:Password_FieldCursorPos           ; Load the cursor position again.
    AND #$0f                                ; Keep the lower nibble.
    CLC
    ADC PASSWORD_CURSOR_START_PPU_ADDRS_L,Y ; Add the lower byte of the PPU
                                            ; address.
    STA PPU_TargetAddr                      ; Store as the target address to
                                            ; write to.


    ;
    ; Write to the PPU buffer.
    ;
    LDA #$01                                ; A = 1 (write length)
    JSR PPUBuffer_QueueCommandOrLength      ; Queue the length.
    PLA                                     ; Pull the caller-provided tile
                                            ; value.
    JSR PPUBuffer_Set                       ; Write the tile to the buffer.
    STX PPUBuffer_WriteOffset               ; Update the write offset.

    ;
    ; XREFS:
    ;     PasswordScreen_DrawPasswordFieldCursor
    ;
RETURN_9311:                                ; [$9311]
    RTS

;============================================================================
; TODO: Document PasswordScreen_HandleInputChar
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleInput
;============================================================================
PasswordScreen_HandleInputChar:             ; [$9312]
    TAX                                     ; X = A
    BMI PasswordScreen_HandleMoveCursorOrDelete ; If a special character,
                                                ; jump to handle it.


    ;
    ; Place the character in the buffer.
    ;
    LDX a:Password_FieldCursorPos           ; X = Current cursor position.
    STA ScreenBuffer,X                      ; Store in the screen buffer.
    JSR PasswordScreen_DrawAtCursorPosition ; Write the character.


    ;
    ; Advance the cursor position by one.
    ;
    LDX a:Password_FieldCursorPos           ; X = Cursor position again.
    INX                                     ; X++


    ;
    ; Check if the maximum number of characters have been entered.
    ;
    CPX a:Password_MaxChars                 ; Has it reached the max number
                                            ; of characters?
    BEQ @_maxCharsReached                   ; If so, jump.
    DEX                                     ; X--
    CPX a:Password_EnteredCharsLength       ; Was the cursor at the end of
                                            ; the entered characters?
    BNE @_advanceCursorPos                  ; If not, jump.


    ;
    ; The cursor was at the end of the password. Advance the
    ; number of entered characters.
    ;
    INC a:Password_EnteredCharsLength       ; Increment the entered chars
                                            ; length.

  @_advanceCursorPos:                       ; [$9330]
    INC a:Password_FieldCursorPos           ; Increment the cursor position.
    JMP PasswordScreen_DrawAtCursorPosition ; Write the character.


    ;
    ; The max number of characters was reached. Move the cursor
    ; back to the start of the field and write the character.
    ;
  @_maxCharsReached:                        ; [$9336]
    STX a:Password_EnteredCharsLength       ; Store the new entered password
                                            ; length.
    LDA #$00
    STA a:Password_FieldCursorPos           ; Reset the cursor position to 0.
    JMP PasswordScreen_DrawAtCursorPosition ; Write the character.


;============================================================================
; Play the Character Input sound.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     None
;
; CALLS:
;     Sound_PlayEffect
;
; XREFS:
;     PasswordScreen_9175
;     PasswordScreen_HandleMoveCursorRight
;     PasswordScreen_HandleWrongPasswordAndWaitForInput
;============================================================================
Sound_PlayInputSound:                       ; [$9341]
    PHA                                     ; Push A to the stack.
    LDA #$0d                                ; 0xD == Character Input sound
    JSR Sound_PlayEffect                    ; Play the sound effect.
    PLA                                     ; Pop A from the stack.
    RTS


;============================================================================
; Play the Move Cursor sound.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     None
;
; CALLS:
;     Sound_PlayEffect
;
; XREFS:
;     Password_HandleDPadInput
;============================================================================
Sound_PlayMoveCursorSound:                  ; [$9349]
    PHA                                     ; Push A to the stack.
    LDA #$0b                                ; 0xB == Cursor Movement sound.
    JSR Sound_PlayEffect                    ; Play the sound effect.
    PLA                                     ; Pop A from the stack.

    ;
    ; XREFS:
    ;     PasswordScreen_HandleMoveCursorOrDelete
    ;
RETURN_9350:                                ; [$9350]
    RTS
;============================================================================
; TODO: Document PasswordScreen_HandleMoveCursorOrDelete
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleInputChar
;============================================================================
PasswordScreen_HandleMoveCursorOrDelete:    ; [$9351]
    ;
    ; Check if this is Move Left (0x81).
    ;
    CMP #$81                                ; Is this Move Left?
    BEQ PasswordScreen_HandleMoveCursorLeft ; If so, jump to handle Move
                                            ; Left.


    ;
    ; Check if this is Move Right (0x80).
    ;
    CMP #$80                                ; Is this Move Right?
    BEQ PasswordScreen_HandleMoveCursorRight ; If so, jump to handle Move
                                             ; Right.


    ;
    ; Check if this is Delete Character (0x82).
    ;
    CMP #$82                                ; Is this DEL?
    BNE RETURN_9350                         ; If not, return.
    JMP PasswordScreen_HandleDeleteAtCursor ; Else, jump to handle DEL.
;============================================================================
; TODO: Document PasswordScreen_HandleMoveCursorLeft
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleMoveCursorOrDelete
;============================================================================
PasswordScreen_HandleMoveCursorLeft:        ; [$9360]
    ;
    ; Check if there are any entered characters.
    ;
    LDA a:Password_EnteredCharsLength       ; Is the password field empty?
    BEQ Call_Sound_PlayInputSound           ; If so, play the input sound and
                                            ; return.


    ;
    ; There are entered characters. Check if we're at the
    ; beginning of the password.
    ;
    LDX a:Password_FieldCursorPos           ; Is the cursor position > 0?
    BNE @LAB_PRG12__937d                    ; If so, jump.


    ;
    ; The cursor is at the beginning of the password.
    ;
    JSR PasswordScreen_DrawAtCursorPosition
    LDA a:Password_EnteredCharsLength       ; Get the number of entered
                                            ; characters.
    STA a:Password_FieldCursorPos           ; Set the cursor position to the
                                            ; end of it.
    CMP a:Password_MaxChars
    BNE @LAB_PRG12__9383
    DEC a:Password_FieldCursorPos
    BNE @LAB_PRG12__9383

  @LAB_PRG12__937d:                         ; [$937d]
    JSR PasswordScreen_DrawAtCursorPosition
    DEC a:Password_FieldCursorPos

  @LAB_PRG12__9383:                         ; [$9383]
    JMP PasswordScreen_DrawAtCursorPosition

;============================================================================
; TODO: Document PasswordScreen_HandleMoveCursorRight
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleMoveCursorOrDelete
;============================================================================
PasswordScreen_HandleMoveCursorRight:       ; [$9386]
    LDA a:Password_EnteredCharsLength
    BEQ Call_Sound_PlayInputSound
    LDX a:Password_FieldCursorPos
    CPX a:Password_EnteredCharsLength
    BEQ @LAB_PRG12__939e
    INX
    CPX a:Password_EnteredCharsLength
    BNE @_writeAndAdvanceCursor
    CPX a:Password_MaxChars
    BNE @_writeAndAdvanceCursor

  @LAB_PRG12__939e:                         ; [$939e]
    JSR PasswordScreen_DrawAtCursorPosition
    LDA #$00
    STA a:Password_FieldCursorPos
    BEQ @_writeAtCursor

  @_writeAndAdvanceCursor:                  ; [$93a8]
    JSR PasswordScreen_DrawAtCursorPosition
    INC a:Password_FieldCursorPos

  @_writeAtCursor:                          ; [$93ae]
    JMP PasswordScreen_DrawAtCursorPosition

    ;
    ; XREFS:
    ;     PasswordScreen_HandleDeleteLastChar
    ;     PasswordScreen_HandleMoveCursorLeft
    ;     PasswordScreen_HandleMoveCursorRight
    ;
Call_Sound_PlayInputSound:                  ; [$93b1]
    JMP Sound_PlayInputSound

;============================================================================
; TODO: Document PasswordScreen_HandleDeleteAtCursor
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleMoveCursorOrDelete
;============================================================================
PasswordScreen_HandleDeleteAtCursor:        ; [$93b4]
    LDA a:Password_FieldCursorPos
    CMP a:Password_EnteredCharsLength
    BEQ PasswordScreen_HandleDeleteLastChar
    PHA

  @_loop:                                   ; [$93bd]
    LDX a:Password_FieldCursorPos
    INX
    CPX a:Password_EnteredCharsLength
    BEQ @LAB_PRG12__93d7
    LDX a:Password_FieldCursorPos
    LDA DAT_0601,X
    STA ScreenBuffer,X
    JSR PasswordScreen_DrawAtCursorPosition
    INC a:Password_FieldCursorPos
    BNE @_loop

  @LAB_PRG12__93d7:                         ; [$93d7]
    LDX a:Password_FieldCursorPos
    LDA #$ff
    STA ScreenBuffer,X
    JSR PasswordScreen_DrawAtCursorPosition
    DEC a:Password_EnteredCharsLength
    PLA
    STA a:Password_FieldCursorPos
    JMP PasswordScreen_DrawAtCursorPosition

;============================================================================
; TODO: Document PasswordScreen_HandleDeleteLastChar
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     PasswordScreen_HandleDeleteAtCursor
;============================================================================
PasswordScreen_HandleDeleteLastChar:        ; [$93ec]
    LDX a:Password_FieldCursorPos
    BEQ Call_Sound_PlayInputSound
    JSR PasswordScreen_DrawAtCursorPosition
    DEC a:Password_FieldCursorPos
    DEC a:Password_EnteredCharsLength
    LDX a:Password_FieldCursorPos
    LDA #$ff
    STA ScreenBuffer,X
    JMP PasswordScreen_DrawAtCursorPosition

;============================================================================
; TODO: Document PasswordScreen_DrawAndHandleInputLoop
;
; INPUTS:
;     X
;
; OUTPUTS:
;     C
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
PasswordScreen_DrawAndHandleInputLoop:      ; [$9405]
    JSR PasswordScreen_DrawPasswordFieldCursor
    JSR Password_HandleDPadInput
    JSR PasswordScreen_DrawSelectionCursor
    LDA Joy1_ChangedButtonMask
    BMI @LAB_PRG12__9416


    ;
    ; Return whether the "A" button was pressed.
    ;
    ASL A
    BMI @LAB_PRG12__9422
    RTS

  @LAB_PRG12__9416:                         ; [$9416]
    PHA
    LDA #$0e
    JSR Sound_PlayEffect
    PLA
    JSR PasswordScreen_IsCursorSpotInvalid
    SEC
    RTS

  @LAB_PRG12__9422:                         ; [$9422]
    LDA #$81
    SEC
    RTS


;============================================================================
; Return whether the cursor position is in an invalid spot.
;
; If the cursor is in a spot not containing an input
; character, this will set Carry to 1.
;
; INPUTS:
;     Password_CursorCol:
;         The current cursor column.
;
;     Password_CursorRow:
;         The current cursor row.
;
;     PASSWORD_VALUES_FOR_CURSOR_POS:
;         The password input values for each cursor
;         position.
;
; OUTPUTS:
;     C:
;         0 = The cursor spot is valid.
;         1 = The cursor spot is invalid.
;
; XREFS:
;     PasswordScreen_DrawAndHandleInputLoop
;     Password_HandleDPadInput
;============================================================================
PasswordScreen_IsCursorSpotInvalid:         ; [$9426]
    ;
    ; Calculate an offset into
    ; PASSWORD_VALUES_FOR_CURSOR_POS.
    ;
    ; This starts with:
    ;
    ;     offset = (row * 2) + (row * 4)
    ;
    ; There are 13 columns in a row. The above gives us an
    ; offset into the characters for that row. So:
    ;
    ;     0 * 12 == 0
    ;     1 * 12 == 12
    ;
    ; XXX TODO
    ;
    LDA a:Password_CursorRow                ; A = Cursor row.
    ASL A                                   ; A = A * 2
    ADC a:Password_CursorRow                ; A++
    ASL A
    ASL A
    ADC a:Password_CursorRow
    ADC a:Password_CursorCol


    ;
    ; Load the value from that entry in the table.
    ;
    TAX
    LDA PASSWORD_VALUES_FOR_CURSOR_POS,X


    ;
    ; See if that is 0xFF, which maps to values like DEL, END,
    ; arrows. If so, the result is false.
    ;
    CMP #$ff
    RTS

;
; XREFS:
;     PasswordScreen_IsCursorSpotInvalid
;
PASSWORD_VALUES_FOR_CURSOR_POS:             ; [$943c]
    .byte $00                               ; [0]:
    .byte $01                               ; [1]:
    .byte $02                               ; [2]:
    .byte $03                               ; [3]:
    .byte $04                               ; [4]:
    .byte $05                               ; [5]:
    .byte $06                               ; [6]:
    .byte $07                               ; [7]:
    .byte $08                               ; [8]:
    .byte $09                               ; [9]:
    .byte $0a                               ; [10]:
    .byte $0b                               ; [11]:
    .byte $0c                               ; [12]:
    .byte $0d                               ; [13]:
    .byte $0e                               ; [14]:
    .byte $0f                               ; [15]:
    .byte $10                               ; [16]:
    .byte $11                               ; [17]:
    .byte $12                               ; [18]:
    .byte $13                               ; [19]:
    .byte $14                               ; [20]:
    .byte $15                               ; [21]:
    .byte $16                               ; [22]:
    .byte $17                               ; [23]:
    .byte $18                               ; [24]:
    .byte $19                               ; [25]:
    .byte $1a                               ; [26]:
    .byte $1b                               ; [27]:
    .byte $1c                               ; [28]:
    .byte $1d                               ; [29]:
    .byte $1e                               ; [30]:
    .byte $1f                               ; [31]:
    .byte $20                               ; [32]:
    .byte $21                               ; [33]:
    .byte $22                               ; [34]:
    .byte $23                               ; [35]:
    .byte $24                               ; [36]:
    .byte $25                               ; [37]:
    .byte $26                               ; [38]:
    .byte $27                               ; [39]:
    .byte $28                               ; [40]:
    .byte $29                               ; [41]:
    .byte $2a                               ; [42]:
    .byte $2b                               ; [43]:
    .byte $2c                               ; [44]:
    .byte $2d                               ; [45]:
    .byte $2e                               ; [46]:
    .byte $2f                               ; [47]:
    .byte $30                               ; [48]:
    .byte $31                               ; [49]:
    .byte $32                               ; [50]:
    .byte $33                               ; [51]:
    .byte $34                               ; [52]:
    .byte $35                               ; [53]:
    .byte $36                               ; [54]:
    .byte $37                               ; [55]:
    .byte $38                               ; [56]:
    .byte $39                               ; [57]:
    .byte $3a                               ; [58]:
    .byte $3b                               ; [59]:
    .byte $3c                               ; [60]:
    .byte $3d                               ; [61]:
    .byte $3e                               ; [62]:
    .byte $3f                               ; [63]:
    .byte $ff                               ; [64]:
    .byte $80                               ; [65]:
    .byte $81                               ; [66]:
    .byte $82                               ; [67]:
    .byte $83                               ; [68]:
    .byte $ff                               ; [69]:
    .byte $ff                               ; [70]:
    .byte $ff                               ; [71]:
    .byte $ff                               ; [72]:
    .byte $ff                               ; [73]:
    .byte $ff                               ; [74]:
    .byte $ff                               ; [75]:
    .byte $ff                               ; [76]:
    .byte $ff                               ; [77]:


;============================================================================
; Get the DPad bits for cursor movement, with auto-repeat.
;
; This will return a bitmask of the DPad bits from
; controller 1. If a button is being held down, it
; will wait a short period of time and then begin
; auto-repeating input at regular intervals (but not
; continuously per-call).
;
; INPUTS:
;     Joy1_ButtonMask:
;         All the pressed buttons.
;
;     Joy1_ChangedButtonMask:
;         The newly-pressed buttons.
;
; OUTPUTS:
;     Password_CounterBeforeAutoRepeatMove:
;         A counter used to wait before auto-repeating
;         the next button.
;
;     A:
;     Password_DPadBits:
;         The current DPad bits.
;
; XREFS:
;     Password_HandleDPadInput
;============================================================================
PasswordScreen_GetDPadBits:                 ; [$948a]
    ;
    ; Check if there have been any changes to the directional
    ; button presses since we were last called.
    ;
    LDA Joy1_ChangedButtonMask
    AND #$0f
    BNE @_handleAutoRepeat


    ;
    ; There were no new changes to buttons. Check whether any
    ; directional buttons were already being held down.
    ;
    LDA Joy1_ButtonMask
    AND #$0f
    BEQ @_stopAutoRepeat
    CMP a:Password_DPadBits
    BNE @_stopAutoRepeat


    ;
    ; A direction key has been held down. We're now going to
    ; begin considering moving in that direction until the
    ; player changes directions or stops holding down the
    ; button.
    ;
    ; Here's how this works:
    ;
    ; 1. This will start at 0 and count up until it gets to 0x29.
    ;
    ; 2. Once it hits that, it will switch to 0x80 and immediately
    ;    return the directional button mask, telling the caller
    ;    it can move one space.
    ;
    ; 3. It will then count up until it hits 0x85. Until it hits
    ;    that, it won't return any directional button masks. This
    ;    serves as a delay between movements.
    ;
    ; 4. Once it hits 0x85, it'll drop back to 0x80 and begin again.
    ;
    LDX a:Password_CounterBeforeAutoRepeatMove
    BPL @_updateAndCheckAutoRepeatCounter
    INC a:Password_CounterBeforeAutoRepeatMove
    INX
    CPX #$86
    BNE @_incCounter

  @_resetAutoRepeatCounter:                 ; [$94a8]
    LDX #$80
    STX a:Password_CounterBeforeAutoRepeatMove
    RTS

  @_updateAndCheckAutoRepeatCounter:        ; [$94ae]
    INC a:Password_CounterBeforeAutoRepeatMove
    INX
    CPX #$2a
    BEQ @_resetAutoRepeatCounter

  @_incCounter:                             ; [$94b6]
    LDA #$00
    RTS


    ;
    ; A new direction has been held down. Store it and return it,
    ; moving the cursor.
    ;
  @_handleAutoRepeat:                       ; [$94b9]
    STA a:Password_DPadBits
    LDX #$00
    STX a:Password_CounterBeforeAutoRepeatMove
    RTS


    ;
    ; No direction buttons are being pressed, or the direction
    ; has changed. Stop moving the cursor.
    ;
  @_stopAutoRepeat:                         ; [$94c2]
    LDA #$00
    STA a:Password_DPadBits
    RTS


;============================================================================
; Handle DPad input on the password screen.
;
; This will listen for Up, Down, Left, or Right button
; presses, moving the cursor as appropriate.
;
; The cursor will be positioned to the correct spot on the
; new row or column, wrapping or repositioning if needed
; to ensure it's on a valid input location.
;
; There's special handling for the 5th row, which has
; the directional arrows, DEL, and END, all of which take
; up 2 tiles. All other rows have an input taking 1 tile and
; space between.
;
; INPUTS:
;     Password_CursorCol:
;         The current cursor column.
;
;     Password_CursorRow:
;         The current cursor row.
;
; OUTPUTS:
;     Password_CursorCol:
;         The updated cursor column.
;
;     Password_CursorRow:
;         The updated cursor row.
;
; CALLS:
;     PasswordScreen_GetDPadBits
;     PasswordScreen_IsCursorSpotInvalid
;     PasswordScreen_UpdateCursorMovedFromLastRow
;     PasswordScreen_UpdateCursorMovedToLastRow
;     Sound_PlayMoveCursorSound
;
; XREFS:
;     PasswordScreen_DrawAndHandleInputLoop
;============================================================================
Password_HandleDPadInput:                   ; [$94c8]
    JSR PasswordScreen_GetDPadBits          ; Get the DPad bits.


    ;
    ; Only consider the bitmask bits, which shouldn't be
    ; necessary since PasswordScreen_GetDPadBits
    ; already does this.
    ;
    AND #$0f                                ; Keep the lower nibble (DPad
                                            ; bits -- redundant).
    BEQ @_return                            ; If nothing is pressed, return.


    ;
    ; We can move in a direction. Play a sound and figure
    ; out which direction we're moving.
    ;
    JSR Sound_PlayMoveCursorSound           ; Play the cursor movement sound.


    ;
    ; Move the cursor right, handling wrapping.
    ;
    LSR A                                   ; Shift the "Right" bit into
                                            ; Carry.
    BCS @_moveRight                         ; If set, handle moving right.
    LSR A                                   ; Shift the "Left" bit into
                                            ; Carry.
    BCS @_moveLeft                          ; if set, handle moving left.
    LSR A                                   ; Shift the "Down" bit into
                                            ; Carry.
    BCS @_moveDown                          ; If set, handle moving down.


    ;
    ; We're moving one row up.
    ;
  @_moveUp:                                 ; [$94db]
    LDX a:Password_CursorRow                ; X = Cursor row
    DEX                                     ; X-- (move up)
    BPL @_checkRow4                         ; If the new row is <= 4, jump to
                                            ; handle it.


    ;
    ; The cursor wrapped up to row 5.
    ;
    JSR PasswordScreen_UpdateCursorMovedToLastRow ; Handle moving to row 5.
    LDX #$05                                ; Set the new row as 5.
    BNE @_updateCursorRow


    ;
    ; Check if this is row 4 (moving from arrows/DEL/END).
    ;
  @_checkRow4:                              ; [$94e8]
    CPX #$04                                ; Is the new row < 4?
    BNE @_updateCursorRow                   ; If so, move the cursor there.


    ;
    ; Cursor moved from row 5 to 4 (numeric, symbols).
    ;
    JSR PasswordScreen_UpdateCursorMovedFromLastRow ; Handle moving away from
                                                    ; row 5.


    ;
    ; Update the cursor row and check if the new spot is valid.
    ;
    ; This handles the case where we move to row 4, which has a
    ; blank spot in the last column. If we'd be putting the
    ; cursor there, move up again one more row.
    ;
  @_updateCursorRow:                        ; [$94ef]
    STX a:Password_CursorRow                ; Set the new cursor row.
    JSR PasswordScreen_IsCursorSpotInvalid  ; Check if the destination spot
                                            ; is valid.
    BCS @_moveUp                            ; If not, move up one row.

  @_return:                                 ; [$94f7]
    RTS


    ;
    ; We're moving one row down.
    ;
  @_moveDown:                               ; [$94f8]
    LDX a:Password_CursorRow                ; X = Cursor row
    INX                                     ; X++ (move down)
    CPX #$05                                ; Did we move to row 5?
    BEQ @_moveDownToRow5                    ; If so, jump to handle it
                                            ; specially.


    ;
    ; The cursor moved down to row < 5.
    ;
    BCC @_updateCursorRowDown               ; Move the cursor down a row.


    ;
    ; We've moved down past the last row. We'll be wrapping.
    ;
    JSR PasswordScreen_UpdateCursorMovedFromLastRow ; Handle moving from the
                                                    ; last row.
    LDX #$00                                ; X = 0 (new row)
    BEQ @_updateCursorRowDown               ; Move the cursor there.


    ;
    ; We're on the final row, with the arrows, DEL, and END.
    ; We have to ensure the cursor position is a multiple of 2,
    ; since each of these take 2 character positions.
    ;
  @_moveDownToRow5:                         ; [$9509]
    JSR PasswordScreen_UpdateCursorMovedToLastRow ; Handle moving to the last
                                                  ; row.


    ;
    ; Save the new row position.
    ;
  @_updateCursorRowDown:                    ; [$950c]
    STX a:Password_CursorRow                ; Store the new cursor row.


    ;
    ; Keep running this logic while the cursor is wrapping
    ; vertically so we end up with a proper row and column
    ; offset.
    ;
    JSR PasswordScreen_IsCursorSpotInvalid  ; Check if the new position is
                                            ; invalid.
    BCS @_moveDown                          ; If so, move down one more row
                                            ; (looping as necessary).
    RTS                                     ; And return.


    ;
    ; Move the cursor left, handling wrapping and repositioning
    ; if on an invalid spot.
    ;
  @_moveLeft:                               ; [$9515]
    LDX a:Password_CursorCol                ; X = Cursor column
    DEX                                     ; X-- (move left)
    BPL @_updateCursorColRight              ; If >= 0, jump to move right.


    ;
    ; We're wrapping from the left to the right.
    ;
    LDX #$0c                                ; Set the cursor to column 12.

  @_updateCursorColRight:                   ; [$951d]
    STX a:Password_CursorCol                ; Store the new cursor column.
    JSR PasswordScreen_IsCursorSpotInvalid  ; Check if the new position is
                                            ; invalid.
    BCS @_moveLeft                          ; If so, move left again.
    RTS                                     ; And return.


    ;
    ; Move the cursor right, handling wrapping and repositioning
    ; if on an invalid spot.
    ;
  @_moveRight:                              ; [$9526]
    LDX a:Password_CursorCol                ; X = Cursor column.
    INX                                     ; X++ (move right)
    CPX #$0d                                ; Is the new position < 13?
    BCC @_updateCursorColLeft               ; If so, jump to move left.


    ;
    ; We're wrapping from the right to the left.
    ;
    LDX #$00                                ; X = 0 (new cursor position).

  @_updateCursorColLeft:                    ; [$9530]
    STX a:Password_CursorCol                ; Store the new cursor position.
    JSR PasswordScreen_IsCursorSpotInvalid  ; Check if the new position is
                                            ; invalid.
    BCS @_moveRight                         ; If so, move right again
                                            ; (looping as needed).
    RTS                                     ; And return.


;============================================================================
; Update the cursor column for the bottom row of the password screen.
;
; When the cursor is on the bottom row, the cursor doesn't
; move one step at a time, it moves 2. The reason is that
; the arrows, DEL, and END are all 2 characters.
;
; INPUTS:
;     Password_CursorCol:
;         The current cursor column position.
;
; OUTPUTS:
;     Password_CursorCol:
;         The normalized cursor position.
;
; XREFS:
;     Password_HandleDPadInput
;============================================================================
PasswordScreen_UpdateCursorMovedToLastRow:  ; [$9539]
    LDA a:Password_CursorCol                ; Load the cursor column.
    CMP #$08                                ; Is it >= 8? (invalid position)
    BCS RETURN_9544                         ; If so, return.
    LSR A                                   ; Else, divide by 2 (each symbol
                                            ; is 2 tiles).

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Set the cursor column in the password input grid.
;
; INPUTS:
;     A:
;         The cursor column.
;
; OUTPUTS:
;     Password_CursorCol:
;         The updated cursor column.
;
; XREFS:
;     PasswordScreen_UpdateCursorMovedFromLastRow
;============================================================================
PasswordScreen_SetCursorCol:                ; [$9541]
    STA a:Password_CursorCol                ; Set the cursor position.

    ;
    ; XREFS:
    ;     PasswordScreen_UpdateCursorMovedFromLastRow
    ;     PasswordScreen_UpdateCursorMovedToLastRow
    ;
RETURN_9544:                                ; [$9544]
    RTS


;============================================================================
; Handle moving the cursor away from the last input row.
;
; This is called either when moving up from the row or down
; from the row (wrapping around to the top).
;
; The cursor position may be normalized to fit in a matching
; column on the destination row. The hand will then be
; redrawn.
;
; There's some protection against invalid positions, which
; in theory should not happen (at least with the US release).
;
; INPUTS:
;     Password_CursorCol:
;         The current cursor column.
;
; OUTPUTS:
;     Password_CursorCol:
;         The updated cursor column.
;
; CALLS:
;     UI_DrawPromptInputSymbol
;
; XREFS:
;     Password_HandleDPadInput
;============================================================================
PasswordScreen_UpdateCursorMovedFromLastRow: ; [$9545]
    LDA a:Password_CursorCol                ; Load the cursor column.
    CMP #$04                                ; Is it >= 4? (invalid position)
    BCS RETURN_9544                         ; If so, return.
    ASL A                                   ; Else, multiply by 2 (each
                                            ; symbol is 2 tiles).
    BCC PasswordScreen_SetCursorCol         ; If the new position is invalid,
                                            ; reset the cursor position.

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Draw the selection cursor on the password screen.
;
; This will draw the cursor at the given cursor position on
; the screen. This is drawn every frame.
;
; INPUTS:
;     InterruptCounter:
;         The current interrupt counter, used to rate limit
;         updates.
;
;     Password_CursorCol:
;         The tile X position of the cursor.
;
;     Password_CursorRow:
;         The tile Y position of the cursor.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     UI_DrawPromptInputSymbol
;
; XREFS:
;     PasswordScreen_DrawAndHandleInputLoop
;============================================================================
PasswordScreen_DrawSelectionCursor:         ; [$954f]
    LDA a:Password_CursorCol                ; A = cursor column.
    LDX a:Password_CursorRow                ; X = cursor row.
    CPX #$05                                ; Is the row 5 (arrows, delete,
                                            ; end)?
    BNE @_setSymbolPos                      ; If not, jump.


    ;
    ; This is row 5, containing the back/forward arrows,
    ; DEL, and END.
    ;
    ; Each symbol takes 2 columns, so we'll start by multiplying
    ; the cursor by 2 so we always jump 2 at a time.
    ;
    ASL A                                   ; Multiply the column by 2.


    ;
    ; Compute an X position for the symbol.
    ;
  @_setSymbolPos:                           ; [$955a]
    ASL A                                   ; Convert to pixel position (2
                                            ; tile width: 16).
    ASL A
    ASL A
    ASL A
    ADC #$20                                ; Add 32 (left padding).
    TAX                                     ; X = result.


    ;
    ; Compute a Y position for the symbol.
    ;
    LDA a:Password_CursorRow                ; A = cursor row.
    ASL A                                   ; Convert to pixel position (2
                                            ; tile height: 16).
    ASL A
    ASL A
    ASL A
    ADC #$55                                ; Add 85 (start of first row).
    TAY                                     ; Y = result.
    LDA #$e4                                ; A = 0xE4 (hand symbol)
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.


;============================================================================
; Set the starting game state for the player.
;
; This will place them in Eolis, with all basic stats,
; no gold, no experience, no inventory.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     TempleSpawnPoint:
;     PlayerTitle:
;     SpecialItems:
;     Quests:
;     NumberOfWeapons:
;     NumberOfArmors:
;     NumberOfShields:
;     NumberOfMagicSpells:
;     NumberOfItems:
;     NextPlayerTitle:
;     Gold:
;     Gold_M:
;     Gold_U:
;         0
;
;     SelectedWeapon:
;     SelectedArmor:
;     SelectedShield:
;     SelectedMagic:
;     SelectedItem:
;         0xFF
;
; XREFS:
;     Game_ShowStartScreen
;============================================================================
Player_SetStartGameState:                   ; [$9570]
    LDA #$00
    STA a:TempleSpawnPoint                  ; Set the temple spawn to 0.
    STA a:PlayerTitle                       ; Set the player title to 0
                                            ; (Novice).
    STA a:SpecialItems                      ; Clear the special items.
    STA a:Quests                            ; Clear the quests.
    LDX #$ff
    STX a:SelectedWeapon                    ; Clear the selected weapon.
    STA a:SelectedArmor                     ; Clear the selected armor.
    STX a:SelectedShield                    ; Clear the selected shield.
    STX a:SelectedMagic                     ; Clear the selected magic.
    STX a:SelectedItem                      ; Clear the selected item.
    STA a:NumberOfWeapons                   ; Set the number of weapons to 0.
    STA a:NumberOfArmors                    ; Set the number of armor to 0.
    STA a:NumberOfShields                   ; Set the number of shields to 0.
    STA a:NumberOfMagicSpells               ; Set the number of magic spells
                                            ; to 0.
    STA a:NumberOfItems                     ; Set the number of items to 0.
    STA a:Experience                        ; Set the experience to 0.
    STA a:Experience_U
    STA a:Gold                              ; Set the gold to 0.
    STA a:Gold_M
    STA a:Gold_U
    STA a:NextPlayerTitle                   ; Set the next player title to 0
                                            ; (Novice).
    RTS


;============================================================================
; Set the initial experience and gold based on the title.
;
; This will set initial experience and gold for the player
; based on their title. This is used after starting from a
; password.
;
; INPUTS:
;     PlayerTitle:
;         The player's title.
;
;     PLAYER_TITLE_EXP_NEEDED:
;         Lookup table for the experience, based on title
;         index.
;
;     PLAYER_TITLE_GOLD:
;         Lookup table for the gold, based on title index.
;
; OUTPUTS:
;     NextPlayerTitle:
;         The next player title.
;
;     Experience:
;     Experience_U:
;         The player's new starting experience.
;
;     Gold:
;     Gold_M:
;     Gold_U:
;          The player's new starting gold.
;
; XREFS:
;     Game_ShowStartScreen
;============================================================================
Player_SetInitialExpAndGold:                ; [$95b1]
    ;
    ; Set the next player title as the current.
    ;
    LDA a:PlayerTitle                       ; Load the current player title.
    STA a:NextPlayerTitle                   ; Set it as the next.
    BEQ @_isNovice                          ; If it's 0 (Novice), jump.


    ;
    ; Generate an offset into the gold and experience arrays.
    ;
    ASL A                                   ; Multiply by 2 to generate an
                                            ; offset into the lookup tables.
    TAX                                     ; X = A


    ;
    ; Set the player's experience.
    ;
    ; Note that this looks up starting at an offset 2 bytes
    ; *before* the lookup table. This is because this code
    ; is always working with an X starting at 2, which becomes
    ; effectively 0 in the lookup table.
    ;
    ; These tables are in bank 15.
    ;
    LDA $f747,X                             ; Load the lower byte of
                                            ; experience for the title.
    STA a:Experience                        ; Set it as the player's
                                            ; experience.
    LDA $f748,X                             ; Load the uper byte of
                                            ; experience for the title.
    STA a:Experience_U                      ; Set it as the player's
                                            ; experience.


    ;
    ; Set the player's gold.
    ;
    ; The same off-by-2 trick is being used for this lookup table.
    ;
    LDA $f765,X                             ; Load the lower byte of gold.
    STA a:Gold                              ; Set it.
    LDA $f766,X                             ; Load the middle byte of gold.
    STA a:Gold_M                            ; Set it.
    LDA #$00                                ; Set the upper byte to 0.
    STA a:Gold_U
    RTS


    ;
    ; The player is Novice. Set experience and gold to 0.
    ;
  @_isNovice:                               ; [$95d9]
    STA a:Experience                        ; Set experience to 0.
    STA a:Experience_U
    STA a:Gold                              ; Set gold to 0.
    STA a:Gold_M
    STA a:Gold_U
    RTS


;============================================================================
; Load from the calculated password state.
;
; This will decode all the state stored by the password into
; memory, performing validation to ensure that there's no
; corruption.
;
; If the state is invalid, C will be set to 1, triggering
; a Bad Password failure message.
;
; INPUTS:
;     None
;
; OUTPUTS:
;     C:
;         0 = Successfully loaded password state.
;         1 = Error with password state.
;
;     NumberOfArmors:
;     NumberOfItems:
;     NumberOfMagicSpells:
;     NumberOfShields:
;     NumberOfWeapons:
;     PlayerTitle:
;     Quests:
;     SelectedArmor:
;     SelectedMagic:
;     SelectedItem:
;     SelectedShield:
;     SelectedWeapon:
;     TempleSpawnPoint:
;     SpecialItems:
;         The new state loaded from the password.
;
;     Password_ByteCounter:
;     Password_BitCounter:
;     $ee:
;     Maybe_Temp4:
;         Clobbered.
;
; CALLS:
;     Password_DecodeValue
;     Password_DecodeValueList
;     Password_DecodeValueOrUnset
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
Password_Load:                              ; [$95e9]
    ;
    ; Clear the state counters.
    ;
    LDX #$00
    STX a:Password_ByteCounter              ; Clear the byte counter.
    STX a:Password_BitCounter               ; Clear the bit counter.


    ;
    ; Decode the start and checksum values (13 bits total) and throw
    ; them away.
    ;
    LDY #$0d                                ; Y = 13 bits
    JSR Password_DecodeValue                ; Decode the checksum.


    ;
    ; Decode the temple spawn point (3 bits).
    ;
    LDY #$03                                ; Y = 3 bits
    JSR Password_DecodeValue                ; Decode the spawn point.
    STA a:TempleSpawnPoint                  ; And store it.


    ;
    ; Decode the player title (4 bits).
    ;
    LDY #$04                                ; Y = 4 bits
    JSR Password_DecodeValue                ; Decode the player title.
    STA a:PlayerTitle                       ; And store it.


    ;
    ; Decode the special items bitmask (8 bits).
    ;
    LDY #$08                                ; Y = 8 bits
    JSR Password_DecodeValue                ; Decode the special items
                                            ; bitmask.
    STA a:SpecialItems                      ; And store it.


    ;
    ; Decode the quests bitmask (8 bits).
    ;
    LDY #$08                                ; Y = 8 bits
    JSR Password_DecodeValue                ; Decode the quests bitmask.
    STA a:Quests                            ; And store it.


    ;
    ; Decode the selected weapon (2 bits).
    ;
    LDY #$02                                ; Y = 2 bits
    JSR Password_DecodeValueOrUnset         ; Decode the selected weapon.
    STA a:SelectedWeapon                    ; And store it.


    ;
    ; Decode the selected armor (2 bits).
    ;
    LDY #$02                                ; Y = 2 bits
    JSR Password_DecodeValueOrUnset         ; Decode the selected armor.
    STA a:SelectedArmor                     ; And store it.


    ;
    ; Decode the selected shield (2 bits).
    ;
    LDY #$02                                ; Y = 2 bits
    JSR Password_DecodeValueOrUnset         ; Decode the selected shield.
    STA a:SelectedShield                    ; And store it.


    ;
    ; Decode the selected magic spell (3 bits).
    ;
    LDY #$03                                ; Y = 3 bits
    JSR Password_DecodeValueOrUnset         ; Decode the selected magic
                                            ; spell.
    STA a:SelectedMagic                     ; And store it.


    ;
    ; Decode the selected item (5 bits).
    ;
    LDY #$05                                ; Y = 5 bits
    JSR Password_DecodeValueOrUnset         ; Decode the selected item.
    STA a:SelectedItem                      ; And store it.


    ;
    ; Decode the weapon inventory into WeaponInventory.
    ;
    LDA #$9d                                ; 0x9D == Lower byte of
                                            ; inventory.
    STA Temp_Int24_U                        ; Store it.
    LDA #$03                                ; 0x03 == Upper byte of
                                            ; inventory.
    STA Maybe_Temp4                         ; Store it.
    LDY #$03                                ; Y = 3 bits for items.
    LDX #$02                                ; X = 2 bits for max count.
    JSR Password_DecodeValueList            ; Decode the weapon inventory.


    ;
    ; Check if under the allowed number of weapons. If too many,
    ; bail with error.
    ;
    CMP #$05                                ; Has this exceeded the inventory
                                            ; size?
    BCS @_returnTrue                        ; If so, return with failure.
    STA a:NumberOfWeapons                   ; Else, store the weapon count.


    ;
    ; Decode the armor inventory into ArmorInventory.
    ;
    LDA #$a1                                ; 0xA1 == Lower byte of
                                            ; inventory.
    STA Temp_Int24_U                        ; Store it.
    LDA #$03                                ; 0x03 == Upper byte of
                                            ; inventory.
    STA Maybe_Temp4                         ; Store it.
    LDY #$03                                ; Y = 3 bits for items.
    LDX #$02                                ; X = 2 bits for max count.
    JSR Password_DecodeValueList            ; Decode the armor inventory.


    ;
    ; Check if under the allowed number of armors. If too many,
    ; bail with error.
    ;
    CMP #$05                                ; Has this exceeded the inventory
                                            ; size?
    BCS @_returnTrue                        ; If so, return with failure.
    STA a:NumberOfArmors                    ; Else, store the armor count.


    ;
    ; Decode the shield inventory into ShieldInventory.
    ;
    LDA #$a5                                ; 0xA5 == Lower byte of
                                            ; inventory.
    STA Temp_Int24_U                        ; Store it.
    LDA #$03                                ; 0x03 == Upper byte of
                                            ; inventory.
    STA Maybe_Temp4                         ; Store it.
    LDY #$03                                ; Y = 3 bits for items.
    LDX #$02                                ; X = 2 bits for max count.
    JSR Password_DecodeValueList            ; Decode the shield inventory.


    ;
    ; Check if under the allowed number of shields. If too many,
    ; bail with error.
    ;
    CMP #$05                                ; Has this exceeded the inventory
                                            ; size?
    BCS @_returnTrue                        ; If so, return with failure.
    STA a:NumberOfShields                   ; Else, store the shield count.


    ;
    ; Decode the magic inventory into MagicInventory.
    ;
    LDA #$a9                                ; 0xA9 == Lower byte of
                                            ; inventory.
    STA Temp_Int24_U                        ; Store it.
    LDA #$03                                ; 0x03 == Upper byte of
                                            ; inventory.
    STA Maybe_Temp4                         ; Store it.
    LDY #$03                                ; Y = 3 bits for items.
    LDX #$03                                ; X = 3 bits for max count.
    JSR Password_DecodeValueList            ; Decode the magic inventory.


    ;
    ; Check if under the allowed number of magic spells. If too
    ; many, bail with error.
    ;
    CMP #$05                                ; Has this exceeded the inventory
                                            ; size?
    BCS @_returnTrue                        ; If so, return with failure.
    STA a:NumberOfMagicSpells               ; Else, store the magic count.


    ;
    ; Decode the items inventory into ItemInventory.
    ;
    LDA #$ad                                ; 0xAD == Lower byte of
                                            ; inventory.
    STA Temp_Int24_U                        ; Store it.
    LDA #$03                                ; 0x03 == Upper byte of
                                            ; inventory.
    STA Maybe_Temp4                         ; Store it.
    LDY #$04                                ; Y = 4 bits for items.
    LDX #$05                                ; X = 5 bits for max count.
    JSR Password_DecodeValueList            ; Decode the item inventory.


    ;
    ; Check if under the allowed number of items. If too many,
    ; bail with error.
    ;
    CMP #$09                                ; Has this exceeded the inventory
                                            ; size?
    BCS @_returnTrue                        ; If so, return with failure.
    STA a:NumberOfItems                     ; Else, store the item count.
    CLC                                     ; Set C = 0 for success.
    RTS                                     ; And return it.


    ;
    ; The state was corrupted or invalid. Return a fail result.
    ;
  @_returnTrue:                             ; [$96ae]
    SEC                                     ; Set C = 0 for failure.
    RTS                                     ; And return it.


;============================================================================
; Decode an optional value that may be unset.
;
; This will decode a 1 bit flag indicating if a value is
; set.
;
; If the flag is 1, a value is set, and will be decoded and
; returned.
;
; If the flag is 0, an unset value (0xFF) will be returned.
;
; INPUTS:
;     Y:
;         The storage size of the value in bits.
;
; OUTPUTS:
;     A:
;         The decoded value, or 0xFF if unset.
;
; CALLS:
;     Password_DecodeValue
;
; XREFS:
;     Password_Load
;============================================================================
Password_DecodeValueOrUnset:                ; [$96b0]
    TYA                                     ; A = Y (number of bits)
    PHA                                     ; Push it to the stack.
    LDY #$01                                ; Y = 1
    JSR Password_DecodeValue                ; Decode the set/unset flag.
    LSR A                                   ; Shift into Carry.
    PLA                                     ; Pop our saved Y (number of
                                            ; bits).
    TAY                                     ; Set back into Y.
    BCC @_returnUnset                       ; If the flag was 0, jump to
                                            ; return unset.


    ;
    ; The value is set. Decode it.
    ;
    JMP Password_DecodeValue                ; Decode the value and return it.


    ;
    ; The value was not set. Return 0xFF.
    ;
  @_returnUnset:                            ; [$96bf]
    LDA #$ff                                ; A = 0xFF (unset value).
    RTS                                     ; And return it.


;============================================================================
; Decode a list of values from a password.
;
; INPUTS:
;     X:
;         The number of bits used to store an item.
;
;     Y:
;         The number of bits used to store the list length.
;
; OUTPUTS:
;     A:
;         The number of items read.
;
;     $ee:
;         The decoded items.
;
;     Password_TempA:
;     Password_TempX:
;         Clobbered.
;
; CALLS:
;     Password_DecodeValue
;
; XREFS:
;     Password_Load
;============================================================================
Password_DecodeValueList:                   ; [$96c2]
    STX a:Password_TempX                    ; Store X temporarily.


    ;
    ; Decode the length count.
    ;
    JSR Password_DecodeValue                ; Decode the next value.
    STA a:Password_TempA                    ; Store the result temporarily.
    BEQ @_return                            ; If it's 0 (no items), return 0.


    ;
    ; The list has at least 1 item. Iterate through the items.
    ;
    LDY #$00                                ; Y = 0 (loop counter).

  @_loop:                                   ; [$96cf]
    TYA                                     ; A = Y
    PHA                                     ; Push the loop counter to the
                                            ; stack.


    ;
    ; Read an item from the list.
    ;
    LDY a:Password_TempX                    ; Y = number of item bits to
                                            ; read.
    JSR Password_DecodeValue                ; Decode the item value.
    TAX                                     ; X = resulting item value
    PLA                                     ; Pop the loop counter.
    TAY                                     ; Y = loop counter


    ;
    ; Store the resulting item in our buffer.
    ;
    TXA                                     ; A = item value
    STA (Temp_Int24_U),Y                    ; Store in our decode buffer.
    INY                                     ; Y++
    CPY a:Password_TempA                    ; Have we read all the items?
    BNE @_loop                              ; If not, loop.


    ;
    ; We're done! Return the number of items.
    ;
    TYA                                     ; A = Y (loop counter, result)

  @_return:                                 ; [$96e4]
    RTS                                     ; And return it.


;============================================================================
; Generate the full password byte state for the game and reset.
;
; This wraps Password_GenerateState and then resets
; counters.
; See that method for details and other outputs.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     Password_EncodedState:
;         The resulting computed password state.
;
;     Password_ByteCounter:
;     Password_BitCounter:
;         Internal, and clobbered.
;
; CALLS:
;     Password_GenerateState
;
; XREFS:
;     IScriptAction_ShowPassword
;============================================================================
Password_GenerateStateAndReset:             ; [$96e5]
    JSR Password_GenerateState              ; Generate the password state.


    ;
    ; Reset the state.
    ;
    LDX #$00
    STX a:Password_ByteCounter              ; Reset byte counter to 0.
    STX a:Password_BitCounter               ; Reset bit counter to 0.
    RTS


;============================================================================
; Return the next 6 bits from the encoded password state.
;
; INPUTS:
;     Password_6BitCount:
;         The number of 6 bit values remaining.
;
; OUTPUTS:
;     A:
;         The decoded value.
;
;     C:
;         0 = Data remaining to read.
;         1 = Data has been read.
;
;     Password_6BitCount:
;         The decremented number of 6 bit values remaining.
;
; CALLS:
;     Password_DecodeValue
;
; XREFS:
;     PasswordScreen_ShowNextChar
;============================================================================
Password_GetNext6Bits:                      ; [$96f1]
    LDY #$06
    JSR Password_DecodeValue                ; Decode the next 6 bits.
    CLC
    DEC a:Password_6BitCount                ; Decrement the 6 bit counter.
    BNE @_return                            ; If > 0, set C=0 and jump to
                                            ; return.
    SEC                                     ; Set C=1.

  @_return:                                 ; [$96fd]
    RTS


;============================================================================
; Generate the full password byte state for the game.
;
; This generates the password state based on the game state,
; prior to building the readable alphanumeric/symbolic
; password.
;
; This is done by encoding an initial but incomplete
; password state, which contains all the saved game
; elements (spawn point, items, weapons, armor, etc.)
; but does not contain some of the initial validation
; state (checksum and a 6-bit-length data counter).
;
; Then it calculates the 6-bit length data counter based
; on that, which will go into the final password.
;
; The state is reset and password state is generated again.
; This time, the first 5 bits of the second byte is
; populated with the 6-bit data counter, following by the
; game state, followed by padding bits to round up to the
; nearest byte.
;
; The checksum is then stored in the first byte.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     Password_EncodedState:
;         The resulting computed password state.
;
;     Password_ByteCounter:
;     Password_BitCounter:
;     Password_Checksum:
;         Internal, and clobbered.
;
; CALLS:
;     Password_EncodeValue
;     Password_EncodeGameState
;
; XREFS:
;     Password_GenerateStateAndReset
;============================================================================
Password_GenerateState:                     ; [$96fe]
    ;
    ; Reset all the encoding state.
    ;
    LDX #$00
    STX a:Password_ByteCounter              ; Reset byte counter to 0.
    STX a:Password_BitCounter               ; Reset bit counter to 0.
    STX a:Password_Checksum                 ; Reset checksum to 0.


    ;
    ; Place 0x00 in the first byte.
    ;
    LDY #$08                                ; Y = 8 (value storage size in
                                            ; bits)
    LDA #$00                                ; A = 0 (value)
    JSR Password_EncodeValue                ; Encode it.


    ;
    ; Place 0x00 in the first 5 bits of the second byte.
    ;
    LDY #$05                                ; Y = 5 (value storage size in
                                            ; bits)
    LDA #$00                                ; A = 0 (value)
    JSR Password_EncodeValue                ; Encode it.


    ;
    ; Save all the game state into the remaining bits and
    ; progress the checksum.
    ;
    JSR Password_EncodeGameState            ; Encode the game state.


    ;
    ; Begin resetting state again for another run, but now using
    ; the calculated values as part of the final state.
    ;
    ; First, generate the total bits placed in the state as:
    ;
    ;     total_bits = total_bytes * 8 + remaining_bits;
    ;
    ;     If total_bytes == 32:  // End of password state
    ;         total_bits--;
    ;
    LDA a:Password_ByteCounter              ; Multiply the current state byte
                                            ; index by 8, and track carry.
    ASL A
    ASL A
    ASL A
    ADC a:Password_BitCounter               ; Add the current bit counter
                                            ; within the final byte - the
                                            ; carry.


    ;
    ; Begin our 6-bit count loop.
    ;
    ; Roughly:
    ;
    ;     result = ceil(total_bits / 6)
    ;
    LDX #$00                                ; X = 0 (Loop counter)

  @_6BitCountLoop:                          ; [$9725]
    INX                                     ; X++
    SEC                                     ; X = 1
    SBC #$06                                ; A -= 6
    BEQ @_resetLoop                         ; If 0, break out of the loop.
    BCS @_6BitCountLoop                     ; Else, loop.


    ;
    ; Store the final expected 6 bit counter for the password state.
    ;
  @_resetLoop:                              ; [$972d]
    STX a:Password_6BitCount                ; X = 6-bit counter


    ;
    ; Reset for a new password generation using the counter.
    ;
    LDX #$00
    STX a:Password_ByteCounter              ; Reset byte counter to 0.
    STX a:Password_BitCounter               ; Reset bit counter to 0.
    STX a:Password_Checksum                 ; Reset checksum to 0.


    ;
    ; Encode the blank checksum.
    ;
    LDY #$08                                ; Y = 8 (value storage size in
                                            ; bits)
    LDA #$00                                ; A = 0 (checksum value)
    JSR Password_EncodeValue                ; Encode the checksum value.


    ;
    ; Encode the 6-bit counter.
    ;
    LDY #$05                                ; Y = 5 (value storage size in
                                            ; bits)
    LDA a:Password_6BitCount                ; A = 6 bit count value
    JSR Password_EncodeValue                ; Encode the value.


    ;
    ; Encode the game state again.
    ;
    JSR Password_EncodeGameState            ; Encode the game state.
    JMP @_fillPaddedBits


    ;
    ; Encode a padding bits for any remaining bits.
    ;
  @_fillPaddedBitsLoop:                     ; [$9750]
    LDY #$01                                ; Y = 1 (value storage size in
                                            ; bits)
    LDA #$00                                ; A = 0 (value)
    JSR Password_EncodeValue                ; Encode the padding.

  @_fillPaddedBits:                         ; [$9757]
    LDA a:Password_BitCounter               ; A = current bit offset
    BNE @_fillPaddedBitsLoop                ; If not 0, add our padding bit.


    ;
    ; Set the last byte to 0.
    ;
    LDX a:Password_ByteCounter              ; X = byte counter
    LDA #$00                                ; A = 0
    STA Password_EncodedState,X             ; Store as the final byte value.


    ;
    ; Set the checksum.
    ;
    SEC
    SBC a:Password_Checksum                 ; Negate the checksum.
    STA a:Password_EncodedState             ; Store as the first byte of the
                                            ; encoded state.
    RTS


;============================================================================
; Encode game state for the new password.
;
; INPUTS:
;     NumberOfArmors:
;         The number of armor items to encode.
;
;     NumberOfItems:
;         The number of items to encode.
;
;     NumberOfMagicSpells:
;         The number of magic spells to encode.
;
;     NumberOfShields:
;         The number of shields to encode.
;
;     NumberOfWeapons:
;         The number of weapons to encode.
;
;     PlayerTitle:
;         The player title to encode.
;
;     Quests:
;         The quests to encode.
;
;     SelectedArmor:
;         The selected armor to encode.
;
;     SelectedItem:
;         The selected item to encode.
;
;     SelectedMagic:
;         The selected magic to encode.
;
;     SelectedShield:
;         The selected shield to encode.
;
;     SelectedWeapon:
;         The selected weapon to encode.
;
;     SpecialItems:
;         The special items to encode.
;
;     TempleSpawnPoint:
;         The temple spawn point to encode.
;
;     ArmorInventory:
;         The armor inventory items to encode.
;
;     ItemInventory:
;         The consumable inventory items to encode.
;
;     MagicInventory:
;         The magic inventory items to encode.
;
;     ShieldInventory:
;         The shield inventory items to encode.
;
;     WeaponInventory:
;         The weapon inventory items to encode.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     Password_EncodeValue
;     Password_EncodeValueList
;     Password_EncodeValueOrUnset
;
; XREFS:
;     Password_GenerateState
;============================================================================
Password_EncodeGameState:                   ; [$976c]
    ;
    ; Encode the temple spawn point.
    ;
    LDA a:TempleSpawnPoint                  ; A = Temple spawn point.
    LDY #$03                                ; Y = 3 (storage size in bits)
    JSR Password_EncodeValue                ; Encode the spawn point.


    ;
    ; Encode the player's title.
    ;
    LDA a:PlayerTitle                       ; A = Player title.
    LDY #$04                                ; Y = 4 (storage size in bits)
    JSR Password_EncodeValue                ; Encode the title.


    ;
    ; Encode the player's special items bitmask.
    ;
    LDA a:SpecialItems                      ; A = Special items bitmask.
    LDY #$08                                ; Y = 8 (storage size in bits)
    JSR Password_EncodeValue                ; Encode the special items
                                            ; bitmask.


    ;
    ; Encode the completed quests.
    ;
    LDA a:Quests                            ; A = Quests bitmask.
    LDY #$08                                ; Y = 8 (storage size in bits)
    JSR Password_EncodeValue                ; Encode the quests bitmask.


    ;
    ; Encode the selected weapon.
    ;
    LDA a:SelectedWeapon                    ; A = Selected weapon.
    LDY #$02                                ; Y = 2 (storage size in bits)
    JSR Password_EncodeValueOrUnset         ; Encode the selected weapon.


    ;
    ; Encode the selected armor.
    ;
    LDA a:SelectedArmor                     ; A = Selected armor.
    LDY #$02                                ; Y = 2 (storage size in bits)
    JSR Password_EncodeValueOrUnset         ; Encode the selected armor.


    ;
    ; Encode the selected shield.
    ;
    LDA a:SelectedShield                    ; A = Selected shield.
    LDY #$02                                ; Y = 2 (storage size in bits)
    JSR Password_EncodeValueOrUnset         ; Encode the selected shield.


    ;
    ; Encode the selected magic spell.
    ;
    LDA a:SelectedMagic                     ; A = Selected magic.
    LDY #$03                                ; Y = 3 (storage size in bits)
    JSR Password_EncodeValueOrUnset         ; Encode the selected magic.


    ;
    ; Encode the selected item.
    ;
    LDA a:SelectedItem                      ; A = Selected item.
    LDY #$05                                ; Y = 5 (storage size in bits)
    JSR Password_EncodeValueOrUnset         ; Encode the selected item.


    ;
    ; Set the value to write to the address of
    ; Player_ShieldPositionY+1
    ;
    ; This hard-codes $039D.
    ;
    LDA #$9d
    STA Temp_Int24_U
    LDA #$03
    STA Maybe_Temp4


    ;
    ; Encode the weapon inventory.
    ;
    LDY #$03                                ; Y = 3 (storage size in bits)
    LDX #$02                                ; X = 2 (start offset)
    LDA a:NumberOfWeapons                   ; A = Number of weapons.
    JSR Password_EncodeValueList            ; Encode the weapon inventory.


    ;
    ; Set the value to write to the address of 0x3a1.
    ;
    ; This hard-codes $03A1.
    ;
    LDA #$a1
    STA Temp_Int24_U
    LDA #$03
    STA Maybe_Temp4


    ;
    ; Encode the armor inventory.
    ;
    LDY #$03                                ; Y = 3 (storage size in bits)
    LDX #$02                                ; X = 2 (start offset)
    LDA a:NumberOfArmors                    ; A = Number of armors.
    JSR Password_EncodeValueList            ; Encode the armor inventory.


    ;
    ; Set the value to write to the address of 0x3a5.
    ;
    ; This hard-codes $03A5.
    ;
    LDA #$a5
    STA Temp_Int24_U
    LDA #$03
    STA Maybe_Temp4


    ;
    ; Encode the shield inventory.
    ;
    LDY #$03                                ; Y = 3 (storage size in bits)
    LDX #$02                                ; X = 2 (start offset)
    LDA a:NumberOfShields                   ; A = Number of shields.
    JSR Password_EncodeValueList            ; Encode the shield inventory.


    ;
    ; Set the value to write to the address of 0x3a9.
    ;
    ; This hard-codes $03A9.
    ;
    LDA #$a9
    STA Temp_Int24_U
    LDA #$03
    STA Maybe_Temp4


    ;
    ; Encode the magic inventory.
    ;
    LDY #$03                                ; Y = 3 (storage size in bits)
    LDX #$03                                ; X = 3 (start offset)
    LDA a:NumberOfMagicSpells               ; A = Number of magic spells.
    JSR Password_EncodeValueList            ; Encode the magic inventory.


    ;
    ; Set the value to write to the address of 0x3ad.
    ;
    ; This hard-codes $03AD.
    ;
    LDA #$ad
    STA Temp_Int24_U
    LDA #$03
    STA Maybe_Temp4


    ;
    ; Encode the item inventory.
    ;
    LDY #$04                                ; Y = 4 (storage size in bits)
    LDX #$05                                ; X = 5 (start offset)
    LDA a:NumberOfItems                     ; A = Number of items.
    JSR Password_EncodeValueList            ; Encode the item inventory.
    RTS


;============================================================================
; Encode a Set/Unset state and a value if set.
;
; If the value is 0xFF, this will encode just 1 bit, an Unset
; value (0).
;
; Otherwise, this will encode a Set bit (1) and the value.
;
; INPUTS:
;     A:
;         The value to encode (or 0xFF).
;
;     X:
;         The start offset.
;
;     Y:
;         The storage size of the value in bits.
;
; OUTPUTS:
;     X:
;         The new offset.
;
; CALLS:
;     Password_EncodeValue
;
; XREFS:
;     Password_EncodeGameState
;============================================================================
Password_EncodeValueOrUnset:                ; [$980f]
    CMP #$ff                                ; Is the value to encode 0xFF?
    BEQ @_isUnset                           ; If so, then jump.


    ;
    ; The value is set. First, push our value and storage size
    ; to the stack.
    ;
    PHA                                     ; Push the value to the stack.
    TYA                                     ; A = Y (storage size in bits)
    PHA                                     ; Push the value to the stack.


    ;
    ; Encode the Set flag.
    ;
    LDY #$01                                ; Y = 1 (storage size in bits)
    LDA #$01                                ; A = 1 (set)
    JSR Password_EncodeValue                ; Encode the value.


    ;
    ; Encode the value.
    ;
    PLA                                     ; Pop the storage size in bits.
    TAY                                     ; Y = result
    PLA                                     ; Pop the value.
    JMP Password_EncodeValue                ; Encode the value.


    ;
    ; The value is unset. Encode only the unset state.
    ;
  @_isUnset:                                ; [$9823]
    LDY #$01                                ; Y = 1 (storage size in bits)
    LDA #$00                                ; A = 0 (unset)
    JMP Password_EncodeValue                ; Encode the value.


;============================================================================
; Encode a list of values for state in the password.
;
; INPUTS:
;     A:
;         The number of values to encode.
;
;     Y:
;         The number of bits of storage used to encode
;         the state.
;
; OUTPUTS:
;     Password_TempA:
;     Password_TempX:
;     Password_TempY:
;         Clobbered.
;
; CALLS:
;     Password_EncodeValue
;
; XREFS:
;     Password_EncodeGameState
;============================================================================
Password_EncodeValueList:                   ; [$982a]
    BEQ @_encodeValue                       ; If empty, just encode the value
                                            ; directly.


    ;
    ; Store A, X, and Y so we can work with these variables.
    ;
    STA a:Password_TempA                    ; Password_TempA
                                            ; = A
    STY a:Password_TempY                    ; Password_TempY
                                            ; = Y
    STX a:Password_TempX                    ; Password_TempX
                                            ; = X


    ;
    ; Encode the number of entries as a value. Roughly:
    ;
    ; Password_EncodeValue(numEntries, startOffset, numBits)
    ;
    JSR Password_EncodeValue                ; Encode that value.


    ;
    ; Prepare for the loop.
    ;
    ; Y is our counter.
    ; Password_TempA is our upper bounds.
    ;
    LDY #$00                                ; Y = 0 (loop counter)

  @_loop:                                   ; [$983a]
    TYA                                     ; A = Y
    PHA                                     ; Push A to stack


    ;
    ; Encode a value from the list. Roughly:
    ;
    ; Password_EncodeValue(entryList[Y], X, numBits)
    ;
    LDA (Temp_Int24_U),Y                    ; A = value at bits offset
    LDY a:Password_TempX                    ; Y =
                                            ; Password_TempX
                                            ; (num bits)
    JSR Password_EncodeValue                ; Encode this value.


    ;
    ; We're done encoding. See if we've reached the end
    ; of the encoding loop.
    ;
    PLA                                     ; Pop A from stack
    TAY                                     ; Y = A
    INY                                     ; Y++
    CPY a:Password_TempA                    ; If Y !=
                                            ; Password_TempA
                                            ; ...
    BNE @_loop                              ; ... Loop.
    RTS

  @_encodeValue:                            ; [$984d]
    JMP Password_EncodeValue

;============================================================================
; TODO: Document Password_Maybe_CheckPasswordLength
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     PasswordScreen_WaitForInput
;============================================================================
Password_Maybe_CheckPasswordLength:         ; [$9850]
    LDX #$00
    STX a:Password_ByteCounter
    STX a:Password_BitCounter
    STX a:Password_Checksum
    LDY #$06
    LDA ScreenBuffer,X
    JSR Password_EncodeValue
    INX
    LDY #$06
    LDA ScreenBuffer,X
    JSR Password_EncodeValue
    INX
    LDY #$06
    LDA ScreenBuffer,X
    JSR Password_EncodeValue
    INX
    LDA a:Password_EncodedState_1_
    LSR A
    LSR A
    LSR A
    CMP a:Password_EnteredCharsLength
    BNE @_returnTrue

  @LAB_PRG12__9881:                         ; [$9881]
    LDY #$06
    LDA ScreenBuffer,X
    JSR Password_EncodeValue
    INX
    CPX a:Password_EnteredCharsLength
    BNE @LAB_PRG12__9881

  @LAB_PRG12__988f:                         ; [$988f]
    LDA a:Password_BitCounter
    BEQ @LAB_PRG12__989e
    LDY #$01
    LDA #$00
    JSR Password_EncodeValue
    JMP @LAB_PRG12__988f

  @LAB_PRG12__989e:                         ; [$989e]
    LDA a:Password_Checksum
    BNE @_returnTrue
    CLC
    RTS

  @_returnTrue:                             ; [$98a5]
    SEC
    RTS

;============================================================================
; TODO: Document Password_EncodeValue
;
; INPUTS:
;     A
;     Y
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     Password_EncodeGameState
;     Password_EncodeValueList
;     Password_EncodeValueOrUnset
;     Password_GenerateState
;     Password_Maybe_CheckPasswordLength
;============================================================================
Password_EncodeValue:                       ; [$98a7]
    STA Temp_Int24                          ; Temp_Int24 =
                                            ; A (character code value)
    TXA                                     ; A = X (character code offset)
    PHA                                     ; Push A to stack, saving it.


    ;
    ; Determine the number of bits we'll be using as an
    ; offset in our math below.
    ;
    ; This will be 8 - Y.
    ;
    ; If that is > 0, we'll do looped math below to
    ; calculate a source bit offset, storing in Temp_Int24.
    ;
    ; If it's 0, we'll skip the math and keep
    ; Temp_Int24 = A (the character code value).
    ;
    STY Temp_Int24_M                        ; Temp_Int24+1
                                            ; = Y (number of bits)
    LDA #$08                                ; A = 8 (bits in a byte)
    SEC                                     ; C = 1
    SBC Temp_Int24_M                        ; A = 8 -
                                            ; Temp_Int24+1
                                            ; - (1 - C)   = 8 -
                                            ; Temp_Int24+1
                                            ; = 8 - Y  If overflow, C = 0
    BEQ @_loop2                             ; If A == 0, skip the bit offset
                                            ; math.
    STA Temp_Int24_M                        ; Temp_Int24+1
                                            ; = A (our loop counter;
                                            ; remaining bits)


    ;
    ; Do:
    ;
    ; Temp_Int24 = Temp_Int24 * (2 to the
    ; power of Temp_Int24+1)
    ;
    ; Or, rather:
    ;
    ; bitPos = charCode * (2 to the power of (8 - numBits))
    ;
    ; We're effectively taking a 0-based character code (A-Za-z0-9)
    ; into the entered password and we're getting a source bit offset
    ; using increments of (8 - numBits), which for value-to-ASCII
    ; encoding (for example) will be 8 - 6 = 2.
    ;
  @_loop1:                                  ; [$98b6]
    ASL Temp_Int24                          ; Temp_Int24 *=
                                            ; 2 If overflow, C = 1
    DEC Temp_Int24_M                        ; Temp_Int24+1--
    BNE @_loop1                             ; If
                                            ; Temp_Int24+1
                                            ; != 0, loop.


    ;
    ; Encode the character.
    ;
  @_loop2:                                  ; [$98bc]
    LDX a:Password_ByteCounter              ; X = index of the character to
                                            ; encode


    ;
    ; Advance our source bit position, multipying by 2 and
    ; OR'ing the carry flag from above.
    ;
    ROL Temp_Int24                          ; Temp_Int24 =
                                            ; Temp_Int24 *
                                            ; 2 | C If overflow, C = 1


    ;
    ; Store a new computed value at the dest offset (X, or
    ; Password_ByteCounter). This will be the stored value * 2,
    ; OR'd with the carry bit from the calculation above.
    ;
    ROL Password_EncodedState,X             ; Dest value = Dest value * 2 | C
                                            ; If overflow, C = 1


    ;
    ; Advance the bit position.
    ;
    ; If we're at the end of the byte, jump to advance
    ; the destination byte position and reset the bit counter.
    ;
    INC a:Password_BitCounter               ; Password_BitCounter++
    LDX a:Password_BitCounter               ; X =
                                            ; Password_BitCounter
    CPX #$08                                ; If X != 8...
    BNE @_nextLoop                          ; ... Jump


    ;
    ; We finished processing the byte. We can now update the
    ; checksum, reset the destination byte, and reset the dest
    ; bit counter.
    ;
    LDX a:Password_ByteCounter              ; X = Computed byte index
    LDA Password_EncodedState,X             ; A = Dest value


    ;
    ; Update the checksum value.
    ;
    ; The checksum is the sum of the character values computed.
    ;
    CLC                                     ; C = 0
    ADC a:Password_Checksum                 ; Password_Checksum
                                            ; += A (dest value) If overflow,
                                            ; C = 1
    STA a:Password_Checksum


    ;
    ; Increment the destination index and reset the bit counter.
    ;
    INC a:Password_ByteCounter
    LDX #$00
    STX a:Password_BitCounter

  @_nextLoop:                               ; [$98e3]
    DEY                                     ; Y--
    BNE @_loop2                             ; If not 0, loop.


    ;
    ; Restore the original value for X. This won't be modified.
    ;
    PLA                                     ; Pull A from stack.
    TAX                                     ; X = A. This is our result.
    RTS

;============================================================================
; TODO: Document Password_DecodeValue
;
; INPUTS:
;     Y
;
; OUTPUTS:
;     A
;
; XREFS:
;     Password_DecodeValueList
;     Password_DecodeValueOrUnset
;     Password_GetNext6Bits
;     Password_Load
;============================================================================
Password_DecodeValue:                       ; [$98e9]
    TXA
    PHA
    LDA #$00

  @LAB_PRG12__98ed:                         ; [$98ed]
    LDX a:Password_ByteCounter
    ASL Password_EncodedState,X
    ROL A
    INC a:Password_BitCounter
    LDX a:Password_BitCounter
    CPX #$08
    BNE @LAB_PRG12__9906
    INC a:Password_ByteCounter
    LDX #$00
    STX a:Password_BitCounter

  @LAB_PRG12__9906:                         ; [$9906]
    DEY
    BNE @LAB_PRG12__98ed
    STA Temp_Int24
    PLA
    TAX
    LDA Temp_Int24
    RTS


;============================================================================
; Fill a textbox with 4 lines of placeholder text.
;
; This will first clear any existing text tiles and then
; place 4 rows of placeholder text (letters and characters),
; ensuring the size and coordinates of the finished textbox.
;
; The text will not be displayed.
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     TextBox_ClearTextTiles
;     TextBox_FillPlaceholderTextAtLineWithStartChar
;     PPU_SetAddrForTextBoxPos
;
; XREFS:
;     IScripts_PositionAndFillPlaceholderText
;============================================================================
IScripts_FillPlaceholderText:               ; [$9910]
    ;
    ; Clear the textbox and prepare to write to it.
    ;
    JSR TextBox_ClearTextTiles              ; Clear the existing text tiles.
    JSR PPU_SetAddrForTextBoxPos            ; Set the PPU address for the
                                            ; text position to write to.


    ;
    ; Write 4 lines of arbitrary characters.
    ;
    LDY #$40
    JSR TextBox_FillPlaceholderTextAtLineWithStartChar ; Write
                                                       ; "@ABCDEFGHIJKLMNO"
    LDY #$50
    JSR TextBox_FillPlaceholderTextAtLineWithStartChar ; Write
                                                       ; "PQRSTUVWXYZ[\]^_"
    LDY #$60
    JSR TextBox_FillPlaceholderTextAtLineWithStartChar ; Write
                                                       ; "`abcdefghijklmno"
    LDY #$70
    JMP TextBox_FillPlaceholderTextAtLineWithStartChar ; Write
                                                       ; "pqrstuvwxyz{|}~."

;============================================================================
; TODO: Document TextBox_CheckShouldContinue
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     IScriptAction_ShowUnskippableMessage
;============================================================================
TextBox_CheckShouldContinue:                ; [$992a]
    LDA a:MessageID
    BNE @LAB_PRG12__9938


    ;
    ; There is no message ID set.
    ;
    JSR TextBox_DrawUpArrowTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BPL @LAB_PRG12__9947
    SEC
    RTS

  @LAB_PRG12__9938:                         ; [$9938]
    LDA a:TextBox_MessagePaused
    BEQ @LAB_PRG12__9947


    ;
    ; An existing message has ended.
    ;
    JSR TextBox_DrawDownArrowTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BPL @LAB_PRG12__9947
    JSR TextBox_PrepareContinueMessage

  @LAB_PRG12__9947:                         ; [$9947]
    CLC
    RTS

;============================================================================
; TODO: Document TextBox_PrepareContinueMessage
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     TextBox_CheckForDismiss
;     TextBox_CheckShouldContinue
;     TextBox_CheckShouldContinueOrDismissQuestion
;============================================================================
TextBox_PrepareContinueMessage:             ; [$9949]
    LDA #$00
    STA a:TextBox_MessagePaused
    LDA #$04
    STA a:Unused_Arg_Text_NumLines
    JMP TextBox_ShowMessage_Prepare4Lines

;============================================================================
; TODO: Document TextBox_CheckShouldContinueOrDismissMessage
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_ShowMessage
;     IScriptAction_ShowSellMenu
;     IScripts_ShowFinalMessage
;============================================================================
TextBox_CheckShouldContinueOrDismissMessage: ; [$9956]
    LDA a:MessageID
    BNE TextBox_CheckForDismiss
    JSR TextBox_DrawUpArrowTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BMI IScripts_ReturnFalse

    ;
    ; v-- Fall through --v
    ;


;============================================================================
; Return whether the B button was pressed.
;
; This is used to dismiss textboxes.
;
; INPUTS:
;     Joy1_ChangedButtonMask:
;         The changed buttons on controller 1.
;
; OUTPUTS:
;     A:
;         Set to 1.
;
;     C:
;         0 = Not pressed.
;         1 = Pressed.
;
; XREFS:
;     TextBox_CheckForDismiss
;     TextBox_CheckShouldContinueOrDismissQuestion
;============================================================================
TextBox_IsBPressed:                         ; [$9962]
    LDA Joy1_ChangedButtonMask              ; Load the changed button mask.
    ASL A                                   ; Shift B into Carry.
    ASL A
    LDA #$01                                ; A = 1
    RTS                                     ; Return.

;============================================================================
; TODO: Document TextBox_CheckForDismiss
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     TextBox_CheckShouldContinueOrDismissMessage
;============================================================================
TextBox_CheckForDismiss:                    ; [$9969]
    LDA a:TextBox_MessagePaused
    BEQ TextBox_IsBPressed
    JSR TextBox_DrawDownArrowTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BPL TextBox_IsBPressed
    JSR TextBox_PrepareContinueMessage
    CLC
    LDA #$01
    RTS

;============================================================================
; TODO: Document IScripts_ReturnFalse
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     TextBox_CheckShouldContinueOrDismissMessage
;     TextBox_CheckShouldContinueOrDismissQuestion
;============================================================================
IScripts_ReturnFalse:                       ; [$997c]
    CLC
    LDA #$00
    RTS

;============================================================================
; TODO: Document TextBox_CheckShouldContinueOrDismissQuestion
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     C
;
; XREFS:
;     IScriptAction_ShowQuestionMessage
;     IScriptAction_ShowQuestionMessageCheckIfDismissed
;============================================================================
TextBox_CheckShouldContinueOrDismissQuestion: ; [$9980]
    LDA a:MessageID
    BNE @LAB_PRG12__998e
    JSR TextBox_DrawQuestionMarkTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BMI IScripts_ReturnFalse
    BPL TextBox_IsBPressed

  @LAB_PRG12__998e:                         ; [$998e]
    LDA a:TextBox_MessagePaused
    BEQ TextBox_IsBPressed
    JSR TextBox_DrawDownArrowTerminatorSymbol
    LDA Joy1_ChangedButtonMask
    BPL TextBox_IsBPressed
    JSR TextBox_PrepareContinueMessage
    CLC
    LDA #$01

    ;
    ; XREFS:
    ;     TextBox_DrawDownArrowTerminatorSymbol
    ;     TextBox_DrawQuestionMarkTerminatorSymbol
    ;     TextBox_DrawUpArrowTerminatorSymbol
    ;
RETURN_99A0:                                ; [$99a0]
    RTS


;============================================================================
; Draw the down arrow terminator symbol.
;
; This will draw the down arrow symbol at the bottom of the
; textbox.
;
; The symbol will appear to flash due to the textbox being
; redrawn in-between viable interrupt-based updates.
;
; INPUTS:
;     InterruptCounter:
;         The current interrupt counter, used to rate limit
;         updates.
;
;     TextBox_X:
;         The tile X position of the textbox.
;
;     TextBox_Y:
;         The tile Y position of the textbox.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     UI_DrawPromptInputSymbol
;
; XREFS:
;     TextBox_CheckForDismiss
;     TextBox_CheckShouldContinue
;     TextBox_CheckShouldContinueOrDismissQuestion
;============================================================================
TextBox_DrawDownArrowTerminatorSymbol:      ; [$99a1]
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$10                                ; Is bit 5 set?
    BEQ RETURN_99A0                         ; If not, return (allowing it to
                                            ; clear).


    ;
    ; Compute an X position for the symbol.
    ;
    LDA a:TextBox_X                         ; Load the textbox X coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$4c                                ; Add 76.
    TAX                                     ; X = result.


    ;
    ; Compute a Y position for the symbol.
    ;
    LDA a:TextBox_Y                         ; Load the textbox Y coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$10                                ; Add 16.
    TAY                                     ; Y = result.


    ;
    ; Draw the symbol.
    ;
    LDA #$e5                                ; A = 0xE5 (animation frame
                                            ; offset).
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.


;============================================================================
; Draw the up arrow terminator symbol.
;
; This will draw the up arrow symbol at the bottom-right of
; the textbox. This is used for the Guru, Add Inventory Item,
; and other textboxes.
;
; The symbol will appear to flash due to the textbox being
; redrawn in-between viable interrupt-based updates.
;
; INPUTS:
;     InterruptCounter:
;         The current interrupt counter, used to rate limit
;         updates.
;
;     TextBox_X:
;         The tile X position of the textbox.
;
;     TextBox_Y:
;         The tile Y position of the textbox.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     UI_DrawPromptInputSymbol
;
; XREFS:
;     IScriptAction_AddInventoryItem
;     IScriptAction_ShowPassword
;     TextBox_CheckShouldContinue
;     TextBox_CheckShouldContinueOrDismissMessage
;============================================================================
TextBox_DrawUpArrowTerminatorSymbol:        ; [$99be]
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$10                                ; Is bit 5 set?
    BEQ RETURN_99A0                         ; If not, return (allowing it to
                                            ; clear).


    ;
    ; Compute an X position for the symbol.
    ;
    LDA a:TextBox_X                         ; Load the textbox X coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$8e                                ; Add 142.
    TAX                                     ; X = result.


    ;
    ; Compute a Y position for the symbol.
    ;
    LDA a:TextBox_Y                         ; Load the textbox Y coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$0e                                ; Add 14.
    TAY                                     ; Y = result.


    ;
    ; Draw the symbol.
    ;
    LDA #$e6                                ; A = 0xE6 (up arrow symbol).
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.


;============================================================================
; Draw the question mark terminator symbol.
;
; This will draw the question mark symbol at the
; bottom-right of the textbox. This is used for the Guru,
; Add Inventory Item, and other textboxes.
;
; The symbol will appear to flash due to the textbox being
; redrawn in-between viable interrupt-based updates.
;
; INPUTS:
;     InterruptCounter:
;         The current interrupt counter, used to rate limit
;         updates.
;
;     TextBox_X:
;         The tile X position of the textbox.
;
;     TextBox_Y:
;         The tile Y position of the textbox.
;
; OUTPUTS:
;     None.
;
; CALLS:
;     UI_DrawPromptInputSymbol
;
; XREFS:
;     TextBox_CheckShouldContinueOrDismissQuestion
;============================================================================
TextBox_DrawQuestionMarkTerminatorSymbol:   ; [$99db]
    LDA InterruptCounter                    ; Load the interrupt counter.
    AND #$10                                ; Is bit 5 set?
    BEQ RETURN_99A0                         ; If not, return (allowing it to
                                            ; clear).


    ;
    ; Compute an X position for the symbol.
    ;
    LDA a:TextBox_X                         ; Load the textbox X coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$4c                                ; Add 76.
    TAX                                     ; X = result.


    ;
    ; Compute a Y position for the symbol.
    ;
    LDA a:TextBox_Y                         ; Load the textbox Y coordinate.
    ASL A                                   ; Convert to a pixel position.
    ASL A
    ASL A
    ADC #$10                                ; Add 16.
    TAY                                     ; Y = result.


    ;
    ; Draw the symbol.
    ;
    LDA #$e7                                ; A = 0xE7 (question mark symbol)
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.

;============================================================================
; TODO: Document Shop_Draw
;
; INPUTS:
;     Y
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_OpenShop
;     IScriptAction_ShowSellMenu
;============================================================================
Shop_Draw:                                  ; [$99f8]
    LDA #$0a
    STA a:TextBox_X
    LDA #$08
    STA a:TextBox_Y
    LDA #$14
    STA a:TextBox_Width
    LDA #$14
    STA a:TextBox_Height
    JSR TextBox_Open
    LDA a:TextBox_Y
    CLC
    ADC #$02
    STA TextBox_ContentsY
    LDX #$00
    STX a:Menu_CursorPos

  @LAB_PRG12__9a1c:                         ; [$9a1c]
    TXA
    PHA
    LDA a:TextBox_X
    CLC
    ADC #$02
    STA TextBox_ContentsX
    TXA
    PHA
    LDA DataArray,X
    JSR TextBox_DrawItemImage
    PLA
    TAX
    LDA ShopItemCostsU,X
    PHA
    LDA ShopItemCostsL,X
    PHA
    LDA a:TextBox_X
    CLC
    ADC #$05
    STA TextBox_ContentsX
    LDA DataArray,X
    JSR TextBox_DrawItemName
    PLA
    STA Temp_Int24
    PLA
    STA Temp_Int24_M
    LDA #$00
    STA Temp_Int24_U
    LDA a:TextBox_X
    CLC
    ADC #$0d
    STA TextBox_ContentsX
    INC TextBox_ContentsY
    LDY #$05
    JSR UI_DrawDigitsNoLeadingZeroes
    INC TextBox_ContentsY
    PLA
    TAX
    INX
    CPX a:Arg_StringsCount
    BNE @LAB_PRG12__9a1c
    RTS

;============================================================================
; TODO: Document Player_RemoveItem
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_ConsumeItem
;     IScriptAction_ShowSellMenu
;     Player_Equip
;============================================================================
Player_RemoveItem:                          ; [$9a6a]
    LDX #$00
    CMP #$80
    BEQ @_isSpecialItem
    INX
    CMP #$81
    BEQ @_isSpecialItem
    INX
    CMP #$82
    BEQ @_isSpecialItem
    INX
    CMP #$83
    BEQ @_isSpecialItem
    INX
    CMP #$92
    BEQ @_isSpecialItem
    INX
    CMP #$8a
    BEQ @_isSpecialItem
    INX
    CMP #$93
    BEQ @_isSpecialItem
    INX
    CMP #$94
    BEQ @_isSpecialItem
    STA Temp_Int24_U
    JSR Player_GetInventoryIndexForItem
    TAX
    LDA NumberOfWeapons,X
    BEQ @_return
    STA Maybe_Temp4
    LDA INVENTORY_CATEGORY_L,X
    STA Temp_Int24
    LDA INVENTORY_CATEGORY_U,X
    STA Temp_Int24_M
    LDY #$00
    LDA Temp_Int24_U
    AND #$1f

  @_inventoryCheckLoop:                     ; [$9ab0]
    CMP (Temp_Int24),Y
    BEQ @_moveInventoryLoop
    INY
    CPY Maybe_Temp4
    BNE @_inventoryCheckLoop
    RTS

  @_moveInventoryLoop:                      ; [$9aba]
    INY
    CPY Maybe_Temp4
    BEQ @_updateCountAndReturn
    LDA (Temp_Int24),Y
    DEY
    STA (Temp_Int24),Y
    INY
    BNE @_moveInventoryLoop

  @_updateCountAndReturn:                   ; [$9ac7]
    DEC NumberOfWeapons,X

  @_return:                                 ; [$9aca]
    RTS

  @_isSpecialItem:                          ; [$9acb]
    LDA a:SpecialItems
    AND SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS,X
    STA a:SpecialItems
    RTS

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS:       ; [$9ad5]
    .byte $7f                               ; [0]: Clear Ring of Elf

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_1_:    ; [$9ad6]
    .byte $bf                               ; [1]: Clear Ring of Ruby

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_2_:    ; [$9ad7]
    .byte $df                               ; [2]: Clear Ring of Dworf

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_3_:    ; [$9ad8]
    .byte $ef                               ; [3]: Clear Demon's Ring

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_4_:    ; [$9ad9]
    .byte $f7                               ; [4]: Clear Elixir

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_5_:    ; [$9ada]
    .byte $fb                               ; [5]: Clear Magical Rod

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_6_:    ; [$9adb]
    .byte $fd                               ; [6]: Clear Pendant

;
; XREFS:
;     Player_RemoveItem
;
SHOP_ITEM_TO_CLEAR_SPECIAL_ITEM_BITS_7_:    ; [$9adc]
    .byte $fe                               ; [7]: Clear Black Onyx

SPECIAL_ITEM_IDS:                           ; [$9add]
    .byte SPECIAL_RING_OF_ELF               ; [0]:
    .byte SPECIAL_RING_OF_RUBY              ; [1]:
    .byte SPECIAL_RING_OF_DWORF             ; [2]:
    .byte SPECIAL_DEMONS_RING               ; [3]:
    .byte SPECIAL_ELIXIR                    ; [4]:
    .byte SPECIAL_MAGICAL_ROD               ; [5]:

;
; XREFS:
;     Player_AddToInventory
;
SPECIAL_ITEM_IDS_6_:                        ; [$9ae3]
    .byte SPECIAL_PENDANT                   ; [6]:

;
; XREFS:
;     Player_AddToInventory
;
SPECIAL_ITEM_IDS_7_:                        ; [$9ae4]
    .byte SPECIAL_BLACK_ONYX                ; [7]:

SPECIAL_ITEM_BITMASKS:                      ; [$9ae5]
    .byte $80                               ; [0]:
    .byte $40                               ; [1]:
    .byte $20                               ; [2]:
    .byte $10                               ; [3]:
    .byte $08                               ; [4]:
    .byte $04                               ; [5]:
    .byte $02                               ; [6]:

;
; XREFS:
;     Player_AddSpecialItem
;
BYTE_PRG12__9aec:                           ; [$9aec]
    .byte $01                               ; [$9aec] byte

;============================================================================
; TODO: Document Player_AddSpecialItem
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     Player_AddToInventory
;============================================================================
Player_AddSpecialItem:                      ; [$9aed]
    LDA a:SpecialItems
    ORA SPECIAL_ITEM_BITMASKS,X
    STA a:SpecialItems
    RTS

;============================================================================
; TODO: Document Player_AddToInventory
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_AddInventoryItem
;     IScriptAction_OpenShop
;     Player_Equip
;============================================================================
Player_AddToInventory:                      ; [$9af7]
    LDX #$07                                ; i = 7; Loop through item bits.

  @_checkSpecialItems:                      ; [$9af9]
    CMP SPECIAL_ITEM_IDS,X                  ; Check if this is a special,
                                            ; non-consumable item
    BEQ Player_AddSpecialItem               ; If this is a special item...
    DEX                                     ; Next i
    BPL @_checkSpecialItems
    STA Temp_Int24_U
    JSR Player_GetInventoryIndexForItem     ; Convert the item ID to a
                                            ; category.
    TAX
    LDA INVENTORY_CATEGORY_L,X
    STA Temp_Int24
    LDA INVENTORY_CATEGORY_U,X
    STA Temp_Int24_M


    ;
    ; Check if the maximum has been reached for the inventory category.
    ;
    LDA NumberOfWeapons,X                   ; Load the number of items in the
                                            ; inventory category
    CMP MAX_INVENTORY_SLOTS,X               ; Check if the max has been hit
    BNE @_addItem
    DEC NumberOfWeapons,X                   ; The max has been hit. Remove
                                            ; one.

  @_addItem:                                ; [$9b1c]
    LDY NumberOfWeapons,X
    LDA Temp_Int24_U
    AND #$1f
    STA (Temp_Int24),Y
    INC NumberOfWeapons,X                   ; Increase the length of the
                                            ; inventory
    RTS


;============================================================================
; Lower nibble lookup table for inventory category addresses
;
; XREFS:
;     PlayerMenu_ShowInventoryMenu
;     Player_AddToInventory
;     Player_LacksItem
;     Player_RemoveItem
;     Shop_GetPlayerHasSelectedItem
;============================================================================

;
; XREFS:
;     PlayerMenu_ShowInventoryMenu
;     Player_AddToInventory
;     Player_LacksItem
;     Player_RemoveItem
;     Shop_GetPlayerHasSelectedItem
;
INVENTORY_CATEGORY_L:                       ; [$9b29]
    .byte $9d                               ; [0]: Weapons
    .byte $a1                               ; [1]: Armor
    .byte $a5                               ; [2]: Shields
    .byte $a9                               ; [3]: Magic

;
; XREFS:
;     IScriptAction_ShowSellMenu
;
INVENTORY_CATEGORY_L_4_:                    ; [$9b2d]
    .byte $ad                               ; [4]: Items


;============================================================================
; Upper nibble lookup table for inventory category addresses
;
; XREFS:
;     PlayerMenu_ShowInventoryMenu
;     Player_AddToInventory
;     Player_LacksItem
;     Player_RemoveItem
;     Shop_GetPlayerHasSelectedItem
;============================================================================

;
; XREFS:
;     PlayerMenu_ShowInventoryMenu
;     Player_AddToInventory
;     Player_LacksItem
;     Player_RemoveItem
;     Shop_GetPlayerHasSelectedItem
;
INVENTORY_CATEGORY_U:                       ; [$9b2e]
    .byte $03                               ; [0]: Weapons
    .byte $03                               ; [1]: Armor
    .byte $03                               ; [2]: Shields
    .byte $03                               ; [3]: Magic

;
; XREFS:
;     IScriptAction_ShowSellMenu
;
INVENTORY_CATEGORY_U_4_:                    ; [$9b32]
    .byte $03                               ; [4]: Special

;
; XREFS:
;     TextBox_DrawItemName
;
ITEM_NAME_CATEGORIES_L:                     ; [$9b33]
    .byte <ITEM_NAMES_WEAPONS               ; [0]:
    .byte <ITEM_NAMES_ARMOR                 ; [1]:
    .byte <ITEM_NAMES_SHIELDS               ; [2]:
    .byte <ITEM_NAMES_MAGIC                 ; [3]:
    .byte <ITEM_NAMES_KEYS                  ; [4]:

;
; XREFS:
;     TextBox_DrawItemName
;
ITEM_NAME_CATEGORIES_U:                     ; [$9b38]
    .byte >ITEM_NAMES_WEAPONS               ; [0]:
    .byte >ITEM_NAMES_ARMOR                 ; [1]:
    .byte >ITEM_NAMES_SHIELDS               ; [2]:
    .byte >ITEM_NAMES_MAGIC                 ; [3]:
    .byte >ITEM_NAMES_KEYS                  ; [4]:

;
; XREFS:
;     ITEM_NAME_CATEGORIES_L [$PRG12::9b33]
;     ITEM_NAME_CATEGORIES_U [$PRG12::9b38]
;
ITEM_NAMES_WEAPONS:                         ; [$9b3d]
    .byte $0d,"HAND DA"                     ; [$9b3d] char
    .byte "GGER    "                        ; [$9b45] char
    .byte $0d,"LONG SW"                     ; [$9b4d] char
    .byte "ORD     "                        ; [$9b55] char
    .byte $0d,"GIANT B"                     ; [$9b5d] char
    .byte "LADE    "                        ; [$9b65] char
    .byte $0d,"DRAGON "                     ; [$9b6d] char
    .byte "SLAYER  "                        ; [$9b75] char

;
; XREFS:
;     ITEM_NAME_CATEGORIES_L [$PRG12::9b34]
;     ITEM_NAME_CATEGORIES_U [$PRG12::9b39]
;
ITEM_NAMES_ARMOR:                           ; [$9b7d]
    .byte $0d,"LEATHER"                     ; [$9b7d] char
    .byte " ARMOR  "                        ; [$9b85] char
    .byte $0d,"STUDDED"                     ; [$9b8d] char
    .byte " MAIL   "                        ; [$9b95] char
    .byte $0d,"FULL PL"                     ; [$9b9d] char
    .byte "ATE     "                        ; [$9ba5] char
    .byte $0d,"BATTLE "                     ; [$9bad] char
    .byte "SUIT    "                        ; [$9bb5] char

;
; XREFS:
;     ITEM_NAME_CATEGORIES_L [$PRG12::9b35]
;     ITEM_NAME_CATEGORIES_U [$PRG12::9b3a]
;
ITEM_NAMES_SHIELDS:                         ; [$9bbd]
    .byte $0d,"SMALL S"                     ; [$9bbd] char
    .byte "HIELD   "                        ; [$9bc5] char
    .byte $0d,"LARGE S"                     ; [$9bcd] char
    .byte "HIELD   "                        ; [$9bd5] char
    .byte $0d,"MAGIC S"                     ; [$9bdd] char
    .byte "HIELD   "                        ; [$9be5] char
    .byte $0d,"BATTLE "                     ; [$9bed] char
    .byte "HELMET  "                        ; [$9bf5] char

;
; XREFS:
;     ITEM_NAME_CATEGORIES_L [$PRG12::9b36]
;     ITEM_NAME_CATEGORIES_U [$PRG12::9b3b]
;
ITEM_NAMES_MAGIC:                           ; [$9bfd]
    .byte $0d,"DELUGE "                     ; [$9bfd] char
    .byte "        "                        ; [$9c05] char
    .byte $0d,"THUNDER"                     ; [$9c0d] char
    .byte "        "                        ; [$9c15] char
    .byte $0d,"FIRE   "                     ; [$9c1d] char
    .byte "        "                        ; [$9c25] char
    .byte $0d,"DEATH  "                     ; [$9c2d] char
    .byte "        "                        ; [$9c35] char
    .byte $0d,"TILTE  "                     ; [$9c3d] char
    .byte "        "                        ; [$9c45] char

;
; XREFS:
;     ITEM_NAME_CATEGORIES_L [$PRG12::9b37]
;     ITEM_NAME_CATEGORIES_U [$PRG12::9b3c]
;
ITEM_NAMES_KEYS:                            ; [$9c4d]
    .byte $0d,"RING OF"                     ; [$9c4d] char
    .byte " ELF    "                        ; [$9c55] char
    .byte $0d,"RUBY RI"                     ; [$9c5d] char
    .byte "NG      "                        ; [$9c65] char
    .byte $0d,"RING OF"                     ; [$9c6d] char
    .byte " DWORF  "                        ; [$9c75] char
    .byte $0d,"DEMONS "                     ; [$9c7d] char
    .byte "RING    "                        ; [$9c85] char
    .byte $0d,"KEY A  "                     ; [$9c8d] char
    .byte "        "                        ; [$9c95] char
    .byte $0d,"KEY K  "                     ; [$9c9d] char
    .byte "        "                        ; [$9ca5] char
    .byte $0d,"KEY Q  "                     ; [$9cad] char
    .byte "        "                        ; [$9cb5] char
    .byte $0d,"KEY J  "                     ; [$9cbd] char
    .byte "        "                        ; [$9cc5] char
    .byte $0d,"KEY JO "                     ; [$9ccd] char
    .byte "        "                        ; [$9cd5] char
    .byte $0d,"MATTOCK"                     ; [$9cdd] char
    .byte "        "                        ; [$9ce5] char
    .byte $0d,"ROD    "                     ; [$9ced] char
    .byte "        "                        ; [$9cf5] char
    .byte $0d,"CRYSTAL"                     ; [$9cfd] char
    .byte "        "                        ; [$9d05] char
    .byte $0d,"LAMP   "                     ; [$9d0d] char
    .byte "        "                        ; [$9d15] char
    .byte $0d,"HOUR GL"                     ; [$9d1d] char
    .byte "ASS     "                        ; [$9d25] char
    .byte $0d,"BOOK   "                     ; [$9d2d] char
    .byte "        "                        ; [$9d35] char
    .byte $0d,"WING BO"                     ; [$9d3d] char
    .byte "OTS     "                        ; [$9d45] char
    .byte $0d,"RED POT"                     ; [$9d4d] char
    .byte "ION     "                        ; [$9d55] char
    .byte $0d,"BLACK P"                     ; [$9d5d] char
    .byte "OTION   "                        ; [$9d65] char
    .byte $0d,"ELIXIR "                     ; [$9d6d] char
    .byte "        "                        ; [$9d75] char
    .byte $0d,"PENDANT"                     ; [$9d7d] char
    .byte "        "                        ; [$9d85] char
    .byte $0d,"BLACK O"                     ; [$9d8d] char
    .byte "NIX     "                        ; [$9d95] char
    .byte $0d,"FIRE CR"                     ; [$9d9d] char
    .byte "YSTAL   "                        ; [$9da5] char

STARTSCREEEN_PALETTE_SPRITES:               ; [$9dad]
    .byte $0f                               ; [0]:
    .byte $00                               ; [1]:
    .byte $10                               ; [2]:
    .byte $20                               ; [3]:
    .byte $0f                               ; [4]:
    .byte $00                               ; [5]:
    .byte $10                               ; [6]:
    .byte $20                               ; [7]:
    .byte $0f                               ; [8]:
    .byte $00                               ; [9]:
    .byte $10                               ; [10]:
    .byte $20                               ; [11]:
    .byte $0f                               ; [12]:
    .byte $00                               ; [13]:

;
; XREFS:
;     StartScreen_Draw
;
STARTSCREEEN_PALETTE_SPRITES_14_:           ; [$9dbb]
    .byte $10                               ; [14]:

;
; XREFS:
;     StartScreen_Draw
;
STARTSCREEEN_PALETTE_SPRITES_15_:           ; [$9dbc]
    .byte $20                               ; [15]:

TEXT_TILES_START:                           ; [$9dbd]
    .byte $f2                               ; [0]: S
    .byte $f3                               ; [1]: T
    .byte $e0                               ; [2]: A
    .byte $f1                               ; [3]: R
    .byte $f3                               ; [4]: T
    .byte $00                               ; [5]: \0

TEXT_TILES_CONTINUE:                        ; [$9dc3]
    .byte $e2                               ; [0]: C
    .byte $ee                               ; [1]: O
    .byte $ed                               ; [2]: N
    .byte $f3                               ; [3]: T
    .byte $e8                               ; [4]: I
    .byte $ed                               ; [5]: N
    .byte $f4                               ; [6]: U
    .byte $e4                               ; [7]: E
    .byte $00                               ; [8]: \0

TEXT_TILES_COPYRIGHT_1998_HUDSON_SOFT:      ; [$9dcc]
    .byte $fa                               ; [0]: (C)
    .byte $20                               ; [1]:
    .byte $d7                               ; [2]: 1
    .byte $df                               ; [3]: 9
    .byte $de                               ; [4]: 9
    .byte $de                               ; [5]: 8
    .byte $20                               ; [6]:
    .byte $e7                               ; [7]: H
    .byte $f4                               ; [8]: U
    .byte $e3                               ; [9]: D
    .byte $f2                               ; [10]: S
    .byte $ee                               ; [11]: O
    .byte $ed                               ; [12]: N
    .byte $20                               ; [13]:
    .byte $f2                               ; [14]: S
    .byte $ee                               ; [15]: O
    .byte $e5                               ; [16]: F
    .byte $f3                               ; [17]: T
    .byte $00                               ; [18]: \0

TEXT_TILES_UNDER_LICENSE_FROM_FALCOM:       ; [$9ddf]
    .byte $f4                               ; [0]: U
    .byte $ed                               ; [1]: N
    .byte $e3                               ; [2]: D
    .byte $e4                               ; [3]: E
    .byte $f1                               ; [4]: R
    .byte $20                               ; [5]:
    .byte $eb                               ; [6]: L
    .byte $e8                               ; [7]: I
    .byte $e2                               ; [8]: C
    .byte $e4                               ; [9]: E
    .byte $ed                               ; [10]: N
    .byte $f2                               ; [11]: S
    .byte $e4                               ; [12]: E
    .byte $20                               ; [13]:
    .byte $e5                               ; [14]: F
    .byte $f1                               ; [15]: R
    .byte $ee                               ; [16]: O
    .byte $ec                               ; [17]: M
    .byte $20                               ; [18]:
    .byte $e5                               ; [19]: F
    .byte $e0                               ; [20]: A
    .byte $eb                               ; [21]: L
    .byte $e2                               ; [22]: C
    .byte $ee                               ; [23]: O
    .byte $ec                               ; [24]: M
    .byte $00                               ; [25]: \0

TEXT_TILES_LICENSED_TO_NINTENDO:            ; [$9df9]
    .byte $eb                               ; [0]: L
    .byte $e8                               ; [1]: I
    .byte $e2                               ; [2]: C
    .byte $e4                               ; [3]: E
    .byte $ed                               ; [4]: N
    .byte $f2                               ; [5]: S
    .byte $e4                               ; [6]: E
    .byte $e3                               ; [7]: D
    .byte $20                               ; [8]:
    .byte $f3                               ; [9]: T
    .byte $ee                               ; [10]: O
    .byte $20                               ; [11]:
    .byte $ed                               ; [12]: N
    .byte $e8                               ; [13]: I
    .byte $ed                               ; [14]: N
    .byte $f3                               ; [15]: T
    .byte $e4                               ; [16]: E
    .byte $ed                               ; [17]: N
    .byte $e3                               ; [18]: D
    .byte $ee                               ; [19]: O
    .byte $00                               ; [20]: \0

;============================================================================
; TODO: Document UI_DrawText
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     A
;
; XREFS:
;     PasswordScreen_Show
;     StartScreen_Draw
;============================================================================
UI_DrawText:                                ; [$9e0e]
    LDY #$00

  @_loop:                                   ; [$9e10]
    LDA (Temp_Int24),Y
    BEQ @_return
    CMP #$20
    BNE @_writePPUData
    LDA #$00

  @_writePPUData:                           ; [$9e1a]
    STA a:PPUDATA
    INY
    BNE @_loop

  @_return:                                 ; [$9e20]
    RTS

;============================================================================
; TODO: Document StartScreen_Draw
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;============================================================================
StartScreen_Draw:                           ; [$9e21]
    JSR PPU_WaitUntilFlushed


    ;
    ; Write 224 Faxanadu logo tiles
    ;
    ; From: CHR ROM: Bank 10, 0x8E00: CHR_FAXANADU_LOGO
    ; To:   CHR RAM: 0x1000
    ;
    LDA #$00
    STA IScriptOrCHRAddr
    LDA #$8e
    STA IScriptOrCHRAddr_U
    LDA #$00
    STA PPU_TargetAddr
    LDA #$10
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$e0
    JSR PPU_WriteTilesFromCHRRAM


    ;
    ; Write 27 letter tiles:
    ;
    ; From: CHR ROM: Bank 10, 0x8240: CHR_LETTERS
    ; To:   CHR RAM: 0x1E00
    ;
    LDA #$40
    STA IScriptOrCHRAddr
    LDA #$82
    STA IScriptOrCHRAddr_U
    LDA #$00
    STA PPU_TargetAddr
    LDA #$1e
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$1b
    JSR PPU_WriteTilesFromCHRRAM


    ;
    ; Write 10 number tiles:
    ;
    ; From: CHR ROM: Bank 10, 0x8440: CHR_NUMBERS
    ; To:   CHR RAM: 0x1D60
    ;
    LDA #$40
    STA IScriptOrCHRAddr
    LDA #$84
    STA IScriptOrCHRAddr_U
    LDA #$60
    STA PPU_TargetAddr
    LDA #$1d
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$0a
    JSR PPU_WriteTilesFromCHRRAM
    JSR PPU_ClearAllTilemaps


    ;
    ; Write 4 attribute values
    ;
    ; From: Bank 10, 0x9B60: PRG10:9B60
    ; To:   Attribute table: 0x23C0
    ;
    LDA #$60
    STA IScriptOrCHRAddr
    LDA #$9b
    STA IScriptOrCHRAddr_U
    LDA #$c0
    STA PPU_TargetAddr
    LDA #$23
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$04
    JSR PPU_WriteTilesFromCHRRAM


    ;
    ; Set to top-left of bordered Faxanadu logo (0x2042) and draw
    ; the tiles.
    ;
    ; Copy from the CHR RAM we populated earlier, drawing from the
    ; bottom row to the top.
    ;
    LDA #$20
    STA a:PPUADDR
    LDA #$42
    STA a:PPUADDR
    LDA #$00
    STA Temp_Int24
    LDA #$80
    STA Temp_Int24_M
    LDY #$00
    LDA #$10
    STA Temp_Int24_U

  @LAB_PRG12__9e9b:                         ; [$9e9b]
    LDX #$1c

  @LAB_PRG12__9e9d:                         ; [$9e9d]
    LDA (Temp_Int24),Y
    STA a:PPUDATA
    INY
    BNE @LAB_PRG12__9ea7
    INC Temp_Int24_M

  @LAB_PRG12__9ea7:                         ; [$9ea7]
    DEX
    BNE @LAB_PRG12__9e9d
    LDA #$00
    STA a:PPUDATA
    STA a:PPUDATA
    STA a:PPUDATA
    STA a:PPUDATA
    DEC Temp_Int24_U
    BNE @LAB_PRG12__9e9b
    LDA #$00
    STA a:DAT_0687


    ;
    ; Set position to the start of "START" (0x2288) and
    ; draw the text tiles.
    ;
    LDA #$22
    STA a:PPUADDR
    LDA #$88
    STA a:PPUADDR
    LDA #$bd
    STA Temp_Int24
    LDA #$9d
    STA Temp_Int24_M
    JSR UI_DrawText


    ;
    ; Set position to the start of "CONTINUE" (0x2290) and
    ; draw the text tiles.
    ;
    LDA #$22
    STA a:PPUADDR
    LDA #$90
    STA a:PPUADDR
    LDA #$c3
    STA Temp_Int24
    LDA #$9d
    STA Temp_Int24_M
    JSR UI_DrawText


    ;
    ; Set position to the start of "(C) 1988 Hudson Soft" (0x22E7)
    ; and draw the text tiles.
    ;
    LDA #$22
    STA a:PPUADDR
    LDA #$e7
    STA a:PPUADDR
    LDA #$cc
    STA Temp_Int24
    LDA #$9d
    STA Temp_Int24_M
    JSR UI_DrawText


    ;
    ; Set position to the start of "Under license from Falcom" (0x2423)
    ; and draw the text tiles.
    ;
    LDA #$23
    STA a:PPUADDR
    LDA #$24
    STA a:PPUADDR
    LDA #$df
    STA Temp_Int24
    LDA #$9d
    STA Temp_Int24_M
    JSR UI_DrawText


    ;
    ; Set position to the start of "Licensed to Nintendo" (0x2366)
    ; and draw the text tiles.
    ;
    LDA #$23
    STA a:PPUADDR
    LDA #$66
    STA a:PPUADDR
    LDA #$f9
    STA Temp_Int24
    LDA #$9d
    STA Temp_Int24_M
    JSR UI_DrawText
    LDA #$10
    JSR Screen_LoadUIPalette
    LDX #$0f

  @LAB_PRG12__9f31:                         ; [$9f31]
    LDA STARTSCREEEN_PALETTE_SPRITES,X
    STA Screen_PaletteData_Sprites,X
    DEX
    BPL @LAB_PRG12__9f31
    JSR PPUBuffer_WritePalette
    LDA #$01
    STA Music_Current
    JMP Screen_ResetForNonGame

;============================================================================
; TODO: Document StartScreen_CheckHandleInput
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;============================================================================
StartScreen_CheckHandleInput:               ; [$9f44]
    LDA Joy1_ChangedButtonMask
    AND #$20
    BEQ @LAB_PRG12__9f57
    LDA a:DAT_0687
    EOR #$01
    STA a:DAT_0687
    LDA #$0b
    JSR Sound_PlayEffect

  @LAB_PRG12__9f57:                         ; [$9f57]
    LDY #$00
    LDA a:DAT_0687
    BEQ @_drawCurrentItemSymbol
    INY


    ;
    ; Draw the symbol used to show the current menu item selection.
    ;
  @_drawCurrentItemSymbol:                  ; [$9f5f]
    LDX BYTE_ARRAY_PRG12__9f69,Y            ; X = menu item X position.
    LDY #$7e                                ; Y = 126.
    LDA #$ad                                ; A = 0xAD (right arrow symbol)
    JMP UI_DrawPromptInputSymbol            ; Draw the symbol.

;
; XREFS:
;     StartScreen_CheckHandleInput
;
BYTE_ARRAY_PRG12__9f69:                     ; [$9f69]
    .byte $34                               ; [0]:

;
; XREFS:
;     StartScreen_CheckHandleInput
;
BYTE_ARRAY_PRG12__9f69_1_:                  ; [$9f6a]
    .byte $74                               ; [1]:


;============================================================================
; Lower bytes of IScript addresses by entrypoint index.
;============================================================================
ISCRIPT_ADDRS_L:                            ; [$9f6b]
    .byte $9f                               ; [0]:
    .byte $a3                               ; [1]:
    .byte $ad                               ; [2]:
    .byte $b1                               ; [3]:
    .byte $bc                               ; [4]:
    .byte $c9                               ; [5]:
    .byte $d3                               ; [6]:
    .byte $dd                               ; [7]:
    .byte $50                               ; [8]:
    .byte $ee                               ; [9]:
    .byte $f8                               ; [10]:
    .byte $a1                               ; [11]:
    .byte $fc                               ; [12]:
    .byte $7a                               ; [13]:
    .byte $5d                               ; [14]:
    .byte $02                               ; [15]:
    .byte $0b                               ; [16]:
    .byte $16                               ; [17]:
    .byte $21                               ; [18]:
    .byte $2c                               ; [19]:
    .byte $37                               ; [20]:
    .byte $a2                               ; [21]:
    .byte $3b                               ; [22]:
    .byte $46                               ; [23]:
    .byte $51                               ; [24]:
    .byte $8c                               ; [25]:
    .byte $0e                               ; [26]:
    .byte $55                               ; [27]:
    .byte $03                               ; [28]:
    .byte $9e                               ; [29]:
    .byte $9f                               ; [30]:

;
; XREFS:
;     IScripts_Begin
;
ISCRIPT_ADDRS_L_31_:                        ; [$9f8a]
    .byte $9b                               ; [31]:
    .byte $57                               ; [32]:
    .byte $62                               ; [33]:
    .byte $6d                               ; [34]:
    .byte $78                               ; [35]:
    .byte $8a                               ; [36]:
    .byte $9e                               ; [37]:
    .byte $ab                               ; [38]:
    .byte $c3                               ; [39]:
    .byte $b0                               ; [40]:
    .byte $0c                               ; [41]:
    .byte $b1                               ; [42]:
    .byte $20                               ; [43]:
    .byte $ae                               ; [44]:
    .byte $9f                               ; [45]:
    .byte $9f                               ; [46]:
    .byte $9f                               ; [47]:
    .byte $d9                               ; [48]:
    .byte $e4                               ; [49]:
    .byte $ef                               ; [50]:
    .byte $fa                               ; [51]:
    .byte $05                               ; [52]:
    .byte $10                               ; [53]:
    .byte $1b                               ; [54]:
    .byte $26                               ; [55]:
    .byte $c0                               ; [56]:
    .byte $c2                               ; [57]:
    .byte $bb                               ; [58]:
    .byte $32                               ; [59]:
    .byte $d4                               ; [60]:
    .byte $15                               ; [61]:
    .byte $9f                               ; [62]:
    .byte $9f                               ; [63]:
    .byte $31                               ; [64]:
    .byte $3c                               ; [65]:
    .byte $47                               ; [66]:
    .byte $52                               ; [67]:
    .byte $66                               ; [68]:
    .byte $71                               ; [69]:
    .byte $7c                               ; [70]:
    .byte $cf                               ; [71]:
    .byte $e6                               ; [72]:
    .byte $c8                               ; [73]:
    .byte $44                               ; [74]:
    .byte $68                               ; [75]:
    .byte $1e                               ; [76]:
    .byte $9f                               ; [77]:
    .byte $9f                               ; [78]:
    .byte $9f                               ; [79]:
    .byte $90                               ; [80]:
    .byte $9b                               ; [81]:
    .byte $a6                               ; [82]:
    .byte $b8                               ; [83]:
    .byte $c3                               ; [84]:
    .byte $27                               ; [85]:
    .byte $de                               ; [86]:
    .byte $f8                               ; [87]:
    .byte $d5                               ; [88]:
    .byte $9f                               ; [89]:
    .byte $9f                               ; [90]:
    .byte $9f                               ; [91]:
    .byte $9f                               ; [92]:
    .byte $9f                               ; [93]:
    .byte $9f                               ; [94]:
    .byte $9f                               ; [95]:
    .byte $ce                               ; [96]:
    .byte $d9                               ; [97]:
    .byte $e4                               ; [98]:
    .byte $ef                               ; [99]:
    .byte $fa                               ; [100]:
    .byte $05                               ; [101]:
    .byte $0a                               ; [102]:
    .byte $e2                               ; [103]:
    .byte $56                               ; [104]:
    .byte $3d                               ; [105]:
    .byte $9f                               ; [106]:
    .byte $9f                               ; [107]:
    .byte $9f                               ; [108]:
    .byte $9f                               ; [109]:
    .byte $9f                               ; [110]:
    .byte $9f                               ; [111]:
    .byte $10                               ; [112]:
    .byte $1b                               ; [113]:
    .byte $26                               ; [114]:
    .byte $31                               ; [115]:
    .byte $3c                               ; [116]:
    .byte $1c                               ; [117]:
    .byte $ef                               ; [118]:
    .byte $68                               ; [119]:
    .byte $46                               ; [120]:
    .byte $4f                               ; [121]:
    .byte $ed                               ; [122]:
    .byte $54                               ; [123]:
    .byte $58                               ; [124]:
    .byte $5c                               ; [125]:
    .byte $60                               ; [126]:
    .byte $64                               ; [127]:
    .byte $68                               ; [128]:
    .byte $6c                               ; [129]:
    .byte $70                               ; [130]:
    .byte $74                               ; [131]:
    .byte $78                               ; [132]:
    .byte $7c                               ; [133]:
    .byte $80                               ; [134]:
    .byte $84                               ; [135]:
    .byte $88                               ; [136]:
    .byte $8c                               ; [137]:
    .byte $90                               ; [138]:
    .byte $94                               ; [139]:
    .byte $98                               ; [140]:
    .byte $9c                               ; [141]:
    .byte $a0                               ; [142]:
    .byte $a4                               ; [143]:
    .byte $a8                               ; [144]:
    .byte $ac                               ; [145]:
    .byte $b0                               ; [146]:
    .byte $b4                               ; [147]:
    .byte $b8                               ; [148]:
    .byte $bc                               ; [149]:
    .byte $c0                               ; [150]:
    .byte $c4                               ; [151]:


;============================================================================
; Upper bytes of IScript addresses by entrypoint index.
;============================================================================
ISCRIPT_ADDRS_U:                            ; [$a003]
    .byte $a0                               ; [0]:
    .byte $a0                               ; [1]:
    .byte $a0                               ; [2]:
    .byte $a0                               ; [3]:
    .byte $a0                               ; [4]:
    .byte $a0                               ; [5]:
    .byte $a0                               ; [6]:
    .byte $a0                               ; [7]:
    .byte $a3                               ; [8]:
    .byte $a0                               ; [9]:
    .byte $a0                               ; [10]:
    .byte $a4                               ; [11]:
    .byte $a4                               ; [12]:
    .byte $a3                               ; [13]:
    .byte $a3                               ; [14]:
    .byte $a1                               ; [15]:
    .byte $a1                               ; [16]:
    .byte $a1                               ; [17]:
    .byte $a1                               ; [18]:
    .byte $a1                               ; [19]:
    .byte $a1                               ; [20]:
    .byte $a5                               ; [21]:
    .byte $a1                               ; [22]:
    .byte $a1                               ; [23]:
    .byte $a1                               ; [24]:
    .byte $a3                               ; [25]:
    .byte $a5                               ; [26]:
    .byte $a1                               ; [27]:
    .byte $a6                               ; [28]:
    .byte $a3                               ; [29]:
    .byte $a0                               ; [30]:

;
; XREFS:
;     IScripts_Begin
;
ISCRIPT_ADDRS_U_31_:                        ; [$a022]
    .byte $a0                               ; [31]:
    .byte $a1                               ; [32]:
    .byte $a1                               ; [33]:
    .byte $a1                               ; [34]:
    .byte $a1                               ; [35]:
    .byte $a1                               ; [36]:
    .byte $a1                               ; [37]:
    .byte $a1                               ; [38]:
    .byte $a1                               ; [39]:
    .byte $a3                               ; [40]:
    .byte $a6                               ; [41]:
    .byte $a5                               ; [42]:
    .byte $a5                               ; [43]:
    .byte $a4                               ; [44]:
    .byte $a0                               ; [45]:
    .byte $a0                               ; [46]:
    .byte $a0                               ; [47]:
    .byte $a1                               ; [48]:
    .byte $a1                               ; [49]:
    .byte $a1                               ; [50]:
    .byte $a1                               ; [51]:
    .byte $a2                               ; [52]:
    .byte $a2                               ; [53]:
    .byte $a2                               ; [54]:
    .byte $a2                               ; [55]:
    .byte $a5                               ; [56]:
    .byte $a3                               ; [57]:
    .byte $a4                               ; [58]:
    .byte $a5                               ; [59]:
    .byte $a3                               ; [60]:
    .byte $a6                               ; [61]:
    .byte $a0                               ; [62]:
    .byte $a0                               ; [63]:
    .byte $a2                               ; [64]:
    .byte $a2                               ; [65]:
    .byte $a2                               ; [66]:
    .byte $a2                               ; [67]:
    .byte $a2                               ; [68]:
    .byte $a2                               ; [69]:
    .byte $a2                               ; [70]:
    .byte $a5                               ; [71]:
    .byte $a3                               ; [72]:
    .byte $a4                               ; [73]:
    .byte $a5                               ; [74]:
    .byte $a3                               ; [75]:
    .byte $a6                               ; [76]:
    .byte $a0                               ; [77]:
    .byte $a0                               ; [78]:
    .byte $a0                               ; [79]:
    .byte $a2                               ; [80]:
    .byte $a2                               ; [81]:
    .byte $a2                               ; [82]:
    .byte $a2                               ; [83]:
    .byte $a2                               ; [84]:
    .byte $a6                               ; [85]:
    .byte $a5                               ; [86]:
    .byte $a3                               ; [87]:
    .byte $a4                               ; [88]:
    .byte $a0                               ; [89]:
    .byte $a0                               ; [90]:
    .byte $a0                               ; [91]:
    .byte $a0                               ; [92]:
    .byte $a0                               ; [93]:
    .byte $a0                               ; [94]:
    .byte $a0                               ; [95]:
    .byte $a2                               ; [96]:
    .byte $a2                               ; [97]:
    .byte $a2                               ; [98]:
    .byte $a2                               ; [99]:
    .byte $a2                               ; [100]:
    .byte $a3                               ; [101]:
    .byte $a4                               ; [102]:
    .byte $a4                               ; [103]:
    .byte $a5                               ; [104]:
    .byte $a6                               ; [105]:
    .byte $a0                               ; [106]:
    .byte $a0                               ; [107]:
    .byte $a0                               ; [108]:
    .byte $a0                               ; [109]:
    .byte $a0                               ; [110]:
    .byte $a0                               ; [111]:
    .byte $a3                               ; [112]:
    .byte $a3                               ; [113]:
    .byte $a3                               ; [114]:
    .byte $a3                               ; [115]:
    .byte $a3                               ; [116]:
    .byte $a4                               ; [117]:
    .byte $a4                               ; [118]:
    .byte $a5                               ; [119]:
    .byte $a6                               ; [120]:
    .byte $a6                               ; [121]:
    .byte $a5                               ; [122]:
    .byte $a6                               ; [123]:
    .byte $a6                               ; [124]:
    .byte $a6                               ; [125]:
    .byte $a6                               ; [126]:
    .byte $a6                               ; [127]:
    .byte $a6                               ; [128]:
    .byte $a6                               ; [129]:
    .byte $a6                               ; [130]:
    .byte $a6                               ; [131]:
    .byte $a6                               ; [132]:
    .byte $a6                               ; [133]:
    .byte $a6                               ; [134]:
    .byte $a6                               ; [135]:
    .byte $a6                               ; [136]:
    .byte $a6                               ; [137]:
    .byte $a6                               ; [138]:
    .byte $a6                               ; [139]:
    .byte $a6                               ; [140]:
    .byte $a6                               ; [141]:
    .byte $a6                               ; [142]:
    .byte $a6                               ; [143]:
    .byte $a6                               ; [144]:
    .byte $a6                               ; [145]:
    .byte $a6                               ; [146]:
    .byte $a6                               ; [147]:
    .byte $a6                               ; [148]:
    .byte $a6                               ; [149]:
    .byte $a6                               ; [150]:
    .byte $a6                               ; [151]:


;============================================================================
; Death screen.
;
; "Don't have negative thoughts. Remember your mantra."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8a]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8a]
;
ISCRIPT_REMEMBER_YOUR_MANTRA:               ; [$a09b]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_REMEMBER_YOUR_MANTRA.
    .byte MESSAGEID_REMEMBER_YOUR_MANTRA    ; [$a09d] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; The intro message at the start of the game.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6b]
;     ISCRIPT_ADDRS_L [$PRG12::9f89]
;     ISCRIPT_ADDRS_L [$PRG12::9f98]
;     ISCRIPT_ADDRS_L [$PRG12::9f99]
;     ISCRIPT_ADDRS_L [$PRG12::9f9a]
;     ISCRIPT_ADDRS_L [$PRG12::9fa9]
;     ISCRIPT_ADDRS_L [$PRG12::9faa]
;     ISCRIPT_ADDRS_L [$PRG12::9fb8]
;     ISCRIPT_ADDRS_L [$PRG12::9fb9]
;     ISCRIPT_ADDRS_L [$PRG12::9fba]
;     ISCRIPT_ADDRS_L [$PRG12::9fc4]
;     ISCRIPT_ADDRS_L [$PRG12::9fc5]
;     ISCRIPT_ADDRS_L [$PRG12::9fc6]
;     ISCRIPT_ADDRS_L [$PRG12::9fc7]
;     ISCRIPT_ADDRS_L [$PRG12::9fc8]
;     ISCRIPT_ADDRS_L [$PRG12::9fc9]
;     ISCRIPT_ADDRS_L [$PRG12::9fca]
;     ISCRIPT_ADDRS_L [$PRG12::9fd5]
;     ISCRIPT_ADDRS_L [$PRG12::9fd6]
;     ISCRIPT_ADDRS_L [$PRG12::9fd7]
;     ISCRIPT_ADDRS_L [$PRG12::9fd8]
;     ISCRIPT_ADDRS_L [$PRG12::9fd9]
;     ISCRIPT_ADDRS_L [$PRG12::9fda]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6b]
;     ISCRIPT_ADDRS_L [$PRG12::9f89]
;     ISCRIPT_ADDRS_L [$PRG12::9f98]
;     ISCRIPT_ADDRS_L [$PRG12::9f99]
;     ISCRIPT_ADDRS_L [$PRG12::9f9a]
;     ISCRIPT_ADDRS_L [$PRG12::9fa9]
;     ISCRIPT_ADDRS_L [$PRG12::9faa]
;     ISCRIPT_ADDRS_L [$PRG12::9fb8]
;     ISCRIPT_ADDRS_L [$PRG12::9fb9]
;     ISCRIPT_ADDRS_L [$PRG12::9fba]
;     ISCRIPT_ADDRS_L [$PRG12::9fc4]
;     ISCRIPT_ADDRS_L [$PRG12::9fc5]
;     ISCRIPT_ADDRS_L [$PRG12::9fc6]
;     ISCRIPT_ADDRS_L [$PRG12::9fc7]
;     ISCRIPT_ADDRS_L [$PRG12::9fc8]
;     ISCRIPT_ADDRS_L [$PRG12::9fc9]
;     ISCRIPT_ADDRS_L [$PRG12::9fca]
;     ISCRIPT_ADDRS_L [$PRG12::9fd5]
;     ISCRIPT_ADDRS_L [$PRG12::9fd6]
;     ISCRIPT_ADDRS_L [$PRG12::9fd7]
;     ISCRIPT_ADDRS_L [$PRG12::9fd8]
;     ISCRIPT_ADDRS_L [$PRG12::9fd9]
;     ISCRIPT_ADDRS_L [$PRG12::9fda]
;
ISCRIPT_INTRO:                              ; [$a09f]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic textbox.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_INTRO.
    .byte MESSAGEID_INTRO                   ; [$a0a1] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Walking man shown when you enter the first town.
;
; If the player has no gold, they'll be told to see
; the king. Otherwise, they're given directions to
; Apolune.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6c]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6c]
;
ISCRIPT_EOLIS_WALKING_MAN_1:                ; [$a0a3]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic textbox.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_NPC_FIRST_WALKING_MAN_GO_TO_APOLUNE ; If yes, then jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_GO_SEE_KING.
    .byte MESSAGEID_GO_SEE_KING             ; [$a0a8] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_NPC_FIRST_WALKING_MAN_GO_TO_APOLUNE: ; [$a0aa]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DIRECTIONS_APOLUNE.
    .byte MESSAGEID_DIRECTIONS_APOLUNE      ; [$a0ab] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; "There is a mark of Jack by the key hole."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6d]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6d]
;
ISCRIPT_MARK_OF_JACK:                       ; [$a0ad]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic textbox.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MARK_OF_JACK.
    .byte MESSAGEID_MARK_OF_JACK            ; [$a0af] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6e]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6e]
;
ISCRIPT_EOLIS_WALKING_WOMAN_1:              ; [$a0b1]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic textbox.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Elf.
    .byte SPECIAL_RING_OF_ELF               ; [$a0b3] InventoryItem
    .word @_ISCRIPT_A081_HAS_RING           ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THIS_IS_EOLIS.
    .byte MESSAGEID_THIS_IS_EOLIS           ; [$a0b7] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A081_HAS_RING:                  ; [$a0b9]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_LOOK_FOR_RINGS.
    .byte MESSAGEID_LOOK_FOR_RINGS          ; [$a0ba] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the guru in Eolis.
;
; If the player does not have the Ring of Elf, they will
; be given the ring and told to talk to the King.
;
; If they do have it, they will be told to talk to gurus
; to get a title.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6f]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f6f]
;
ISCRIPT_EOLIS_GURU:                         ; [$a0bc]
    .byte ISCRIPT_ENTITY_GURU               ; Show the Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Elf.
    .byte SPECIAL_RING_OF_ELF               ; [$a0be] InventoryItem
    .word @_ISCRIPT_GURU_EOLIS_HAS_RING     ; If yes, then jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_TAKE_RING_TO_KING.
    .byte MESSAGEID_TAKE_RING_TO_KING       ; [$a0c2] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the Ring of Elf to the
                                            ; inventory.
    .byte SPECIAL_RING_OF_ELF               ; [$a0c4] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_GURU_EOLIS_HAS_RING:            ; [$a0c6]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_VISIT_GURUS_GET_TITLE.
    .byte MESSAGEID_VISIT_GURUS_GET_TITLE   ; [$a0c7] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f70]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f70]
;
ISCRIPT_EOLIS_WALKING_WOMAN_2:              ; [$a0c9]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_A0C9_HAS_GOLD           ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_LAST_WELL_ALMOST_DRY.
    .byte MESSAGEID_LAST_WELL_ALMOST_DRY    ; [$a0ce] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A0C9_HAS_GOLD:                  ; [$a0d0]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THIS_IS_FOREPAW.
    .byte MESSAGEID_THIS_IS_FOREPAW         ; [$a0d1] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the smoking man in Eolis.
;
; If the player has any gold, they'll be asked if they
; have a weapon.
;
; If they don't have gold, they'll be told that there
; are dwarves here in town.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f71]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f71]
;
ISCRIPT_EOLIS_SMOKING_MAN:                  ; [$a0d3]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_NPC_SMOKING_MAN_HAS_GOLD ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DWARVES_ARE_HERE.
    .byte MESSAGEID_DWARVES_ARE_HERE        ; [$a0d8] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_NPC_SMOKING_MAN_HAS_GOLD:       ; [$a0da]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_HAVE_WEAPON.
    .byte MESSAGEID_DO_YOU_HAVE_WEAPON      ; [$a0db] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the King's guard.
;
; If the player does not have the Ring of Elf, he'll
; say the player can't go in.
;
; If the player does have it, but no gold, he'll say the
; King is waiting.
;
; If they have the ring and gold, he'll wish the player
; luck.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f72]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f72]
;
ISCRIPT_EOLIS_KINGS_GUARD:                  ; [$a0dd]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Elf.
    .byte SPECIAL_RING_OF_ELF               ; [$a0df] InventoryItem
    .word @_ISCRIPT_KINGS_GUARD_HAS_RING    ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_CANT_LET_YOU_GO.
    .byte MESSAGEID_CANT_LET_YOU_GO         ; [$a0e3] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_KINGS_GUARD_HAS_RING:           ; [$a0e5]
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_KINGS_GUARD_HAS_GOLD    ; If yes, then jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_KING_IS_WAITING.
    .byte MESSAGEID_KING_IS_WAITING         ; [$a0e9] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_KINGS_GUARD_HAS_GOLD:           ; [$a0eb]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_GOOD_LUCK.
    .byte MESSAGEID_GOOD_LUCK               ; [$a0ec] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f74]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f74]
;
ISCRIPT_A0EE:                               ; [$a0ee]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_A0EE_HAS_GOLD           ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DWARVES_ROBBING_ELVES.
    .byte MESSAGEID_DWARVES_ROBBING_ELVES   ; [$a0f3] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A0EE_HAS_GOLD:                  ; [$a0f5]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_METEORITE_EXPOSITION.
    .byte MESSAGEID_METEORITE_EXPOSITION    ; [$a0f6] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f75]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f75]
;
ISCRIPT_A0F8:                               ; [$a0f8]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has any
                                            ; gold.
    .word @_ISCRIPT_A0F8_HAS_GOLD           ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_LISTEN_TO_PEOPLE.
    .byte MESSAGEID_LISTEN_TO_PEOPLE        ; [$a0fd] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A0F8_HAS_GOLD:                  ; [$a0ff]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD_2.
    .byte MESSAGEID_DONT_TRY_TOO_HARD_2     ; [$a100] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Eolis Martial Artist.
;
; The player will be offered 40HP for 200G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7a]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7a]
;
ISCRIPT_EOLIS_MARTIAL_ARTIST:               ; [$a102]
    .byte ISCRIPT_ENTITY_MARTIAL_ARTIST     ; Show a Martial Artist portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_MARTIAL_ARTS_200G.
    .byte MESSAGEID_MARTIAL_ARTS_200G       ; [$a104] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 200G.
    .word $00c8                             ; [$a106] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 40HP.
    .byte $28                               ; [$a109] byte

    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7b]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7b]
;
ISCRIPT_A10B:                               ; [$a10b]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Small Shield.
    .byte SHIELD_SMALL                      ; [$a10d] InventoryItem
    .word @_ISCRIPT_A10B_HAS_SMALL_SHIELD   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_APOLUNE.
    .byte MESSAGEID_WELCOME_TO_APOLUNE      ; [$a111] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A10B_HAS_SMALL_SHIELD:          ; [$a113]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DIRECTIONS_FOREPAW.
    .byte MESSAGEID_DIRECTIONS_FOREPAW      ; [$a114] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7c]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7c]
;
ISCRIPT_A116:                               ; [$a116]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Small Shield.
    .byte SHIELD_SMALL                      ; [$a118] InventoryItem
    .word @_ISCRIPT_A116_HAS_SMALL_SHIELD   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DIRECTIONS_TO_TRUNK.
    .byte MESSAGEID_DIRECTIONS_TO_TRUNK     ; [$a11c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A116_HAS_SMALL_SHIELD:          ; [$a11e]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_GOOD_LUCK_2.
    .byte MESSAGEID_GOOD_LUCK_2             ; [$a11f] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7d]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7d]
;
ISCRIPT_A121:                               ; [$a121]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Small Shield.
    .byte SHIELD_SMALL                      ; [$a123] InventoryItem
    .word @_ISCRIPT_A121_HAS_SMALL_SHIELD   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_SHOULD_HAVE_SHIELD.
    .byte MESSAGEID_SHOULD_HAVE_SHIELD      ; [$a127] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A121_HAS_SMALL_SHIELD:          ; [$a129]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MATTOCK_IN_TOWER.
    .byte MESSAGEID_MATTOCK_IN_TOWER        ; [$a12a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7e]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7e]
;
ISCRIPT_A12C:                               ; [$a12c]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Small Shield.
    .byte SHIELD_SMALL                      ; [$a12e] InventoryItem
    .word @_ISCRIPT_A12C_HAS_SMALL_SHIELD   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_BLOCKED_PASSAGE.
    .byte MESSAGEID_BLOCKED_PASSAGE         ; [$a132] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A12C_HAS_SMALL_SHIELD:          ; [$a134]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MATTOCK_BREAKS_WALL.
    .byte MESSAGEID_MATTOCK_BREAKS_WALL     ; [$a135] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7f]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f7f]
;
ISCRIPT_A137:                               ; [$a137]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_YOU_NEED_KEY.
    .byte MESSAGEID_YOU_NEED_KEY            ; [$a139] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f81]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f81]
;
ISCRIPT_A13B:                               ; [$a13b]
    .byte ISCRIPT_ENTITY_NURSE              ; [$a13b] IScriptEntity
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Small Shield.
    .byte SHIELD_SMALL                      ; [$a13d] InventoryItem
    .word @_ISCRIPT_A13B_HAS_SMALL_SHIELD   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DOCTOR_CAN_HELP.
    .byte MESSAGEID_DOCTOR_CAN_HELP         ; [$a141] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A13B_HAS_SMALL_SHIELD:          ; [$a143]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_POISON_IS_BAD.
    .byte MESSAGEID_POISON_IS_BAD           ; [$a144] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f82]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f82]
;
ISCRIPT_A146:                               ; [$a146]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_PLAYER_RANK  ; Check if the player has reached
                                            ; Aspirant yet.
    .byte RANK_ASPIRANT                     ; [$a148] PlayerTitle
    .word @_ISCRIPT_A146_HAS_ASPIRANT       ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_LEARN_MANTRAS.
    .byte MESSAGEID_LEARN_MANTRAS           ; [$a14c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A146_HAS_ASPIRANT:              ; [$a14e]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_SECRET_GURU_IN_TOWER.
    .byte MESSAGEID_SECRET_GURU_IN_TOWER    ; [$a14f] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f83]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f83]
;
ISCRIPT_A151:                               ; [$a151]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_CARRY_ITEMS.
    .byte MESSAGEID_CARRY_ITEMS             ; [$a153] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; An empty interaction.
;
; This immediately terminates.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f86]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f86]
;
ISCRIPT_A155:                               ; [$a155]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8b]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8b]
;
ISCRIPT_FOREPAW_GREETER:                    ; [$a157]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the player has
                                            ; completed the Spring of Trunk
                                            ; quest.
    .byte QUEST_SPRING_OF_TRUNK             ; [$a159] Quests
    .word @_ISCRIPT_FOREPAW_GREETER_SPRING_OF_TRUNK_COMPLETE ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_FOREPAW.
    .byte MESSAGEID_WELCOME_TO_FOREPAW      ; [$a15d] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_FOREPAW_GREETER_SPRING_OF_TRUNK_COMPLETE: ; [$a15f]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_FOUNTAIN_WILL_FLOW_TO_TOWN.
    .byte MESSAGEID_FOUNTAIN_WILL_FLOW_TO_TOWN ; [$a160] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8c]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8c]
;
ISCRIPT_A162:                               ; [$a162]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Ruby.
    .byte SPECIAL_RING_OF_RUBY              ; [$a164] InventoryItem
    .word @_ISCRIPT_A162_HAS_RING_OF_RUBY   ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_FIND_3_SPRINGS.
    .byte MESSAGEID_FIND_3_SPRINGS          ; [$a168] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A162_HAS_RING_OF_RUBY:          ; [$a16a]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_WATER_IS_FLOWING.
    .byte MESSAGEID_WATER_IS_FLOWING        ; [$a16b] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8d]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8d]
;
ISCRIPT_A16D:                               ; [$a16d]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the player has
                                            ; completed the Spring of Trunk
                                            ; quest.
    .byte QUEST_SPRING_OF_TRUNK             ; [$a16f] Quests
    .word @_ISCRIPT_A175                    ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_FOUNTAIN_IN_SKY.
    .byte MESSAGEID_FOUNTAIN_IN_SKY         ; [$a173] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A175:                           ; [$a175]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_PUSH_FOUNTAIN_ROCK.
    .byte MESSAGEID_PUSH_FOUNTAIN_ROCK      ; [$a176] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8e]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8e]
;
ISCRIPT_A178:                               ; [$a178]
    .byte ISCRIPT_ENTITY_NURSE              ; [$a178] IScriptEntity
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the player has
                                            ; completed the Spring of Trunk
                                            ; quest.
    .byte QUEST_SPRING_OF_TRUNK             ; [$a17a] Quests
    .word @_ISCRIPT_A178_SPRING_OF_TRUNK_COMPLETED ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_SPRING_IN_TOWER.
    .byte MESSAGEID_SPRING_IN_TOWER         ; [$a17e] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A178_SPRING_OF_TRUNK_COMPLETED: ; [$a180]
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the player has
                                            ; completed the Spring of Sky
                                            ; quest.
    .byte QUEST_SPRING_OF_SKY               ; [$a181] Quests
    .word @_ISCRIPT_A178_SPRING_OF_SKY_COMPLETED ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WINGBOOTS_IN_TOWER.
    .byte MESSAGEID_WINGBOOTS_IN_TOWER      ; [$a185] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A178_SPRING_OF_SKY_COMPLETED:   ; [$a187]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DIRECTIONS_TO_MASCON.
    .byte MESSAGEID_DIRECTIONS_TO_MASCON    ; [$a188] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8f]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f8f]
;
ISCRIPT_A18A:                               ; [$a18a]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the Spring of Sky
                                            ; quest is complete.
    .byte QUEST_SPRING_OF_SKY               ; [$a18c] Quests
    .word @_ISCRIPT_A18A_IS_COMPLETE        ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_FOUNTAIN_IN_SKY_HINT.
    .byte MESSAGEID_FOUNTAIN_IN_SKY_HINT    ; [$a190] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A18A_IS_COMPLETE:               ; [$a192]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Joker key.
    .byte KEY_JO                            ; [$a193] InventoryItem
    .word @_ISCRIPT_A192_HAS_JOKER          ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_USE_THIS_KEY_FOR_FIRST_SPRING.
    .byte MESSAGEID_USE_THIS_KEY_FOR_FIRST_SPRING ; [$a197] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the Joker key to the
                                            ; inventory.
    .byte KEY_JO                            ; [$a199] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A192_HAS_JOKER:                 ; [$a19b]
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_GET_JOKER_OR_COME_BACK.
    .byte MESSAGEID_GET_JOKER_OR_COME_BACK  ; [$a19c] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Spring of Sky man.
;
; He's asleep. Must talk to him twice to wake him up, which
; completes that quest.
;
; With a second interaction, he'll tell you to find a key
; and reach the fountain.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f90]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f90]
;
ISCRIPT_SPRING_OF_SKY:                      ; [$a19e]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the Spring of Sky
                                            ; quest is complete.
    .byte QUEST_SPRING_OF_SKY               ; [$a1a0] Quests
    .word @_ISCRIPT_SPRING_OF_SKY_IS_COMPLETE ; If it has, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_HO_HO_HO_ZZZ.
    .byte MESSAGEID_HO_HO_HO_ZZZ            ; [$a1a4] Message
    .byte ISCRIPT_ACTION_SET_QUEST_COMPLETE ; Mark the Springs man as woken
                                            ; up.
    .byte QUEST_SPRING_OF_SKY               ; [$a1a6] Quests
    .byte ISCRIPT_ACTION_END                ; End

  @_ISCRIPT_SPRING_OF_SKY_IS_COMPLETE:      ; [$a1a8]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_GET_KEY_FIND_FOUNTAIN.
    .byte MESSAGEID_GET_KEY_FIND_FOUNTAIN   ; [$a1a9] Message
    .byte ISCRIPT_ACTION_END                ; End


;============================================================================
; Interaction with the Spring of Trunk man.
;
; If the quest was not complete, he'll explain that you
; need the Elixir. If the player already has it, it will
; get consumed and the quest will be complete. Otherwise,
; he'll say to come back with the medicine.
;
; If the quest was already complete, he'll say to find the
; poison in Mascon.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f91]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f91]
;
ISCRIPT_SPRING_OF_TRUNK:                    ; [$a1ab]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if the Spring of Trunk
                                            ; quest is complete.
    .byte QUEST_SPRING_OF_TRUNK             ; [$a1ad] Quests
    .word @_ISCRIPT_SPRING_OF_TRUNK_IS_COMPLETE ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Else, show
                                               ; MESSAGE_THIS_IS_SPRING_OF_TRUNK_GET_ELIXIR.
    .byte MESSAGEID_THIS_IS_SPRING_OF_TRUNK_GET_ELIXIR ; [$a1b1] Message
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Elixir.
    .byte SPECIAL_ELIXIR                    ; [$a1b3] InventoryItem
    .word @_ISCRIPT_SPRING_OF_TRUNK_HAS_ELIXIR ; If yes, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_COME_BACK_WITH_MEDICINE.
    .byte MESSAGEID_COME_BACK_WITH_MEDICINE ; [$a1b7] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_SPRING_OF_TRUNK_HAS_ELIXIR:     ; [$a1b9]
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_2_MORE_SPRINGS.
    .byte MESSAGEID_2_MORE_SPRINGS          ; [$a1ba] Message
    .byte ISCRIPT_ACTION_CONSUME_ITEM       ; Consume the player's Elixir.
    .byte SPECIAL_ELIXIR                    ; [$a1bc] InventoryItem
    .byte ISCRIPT_ACTION_SET_QUEST_COMPLETE ; Mark the Spring of Trunk as
                                            ; complete.
    .byte QUEST_SPRING_OF_TRUNK             ; [$a1be] Quests
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_SPRING_OF_TRUNK_IS_COMPLETE:    ; [$a1c0]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_FIND_POISON_IN_MASCON.
    .byte MESSAGEID_FIND_POISON_IN_MASCON   ; [$a1c1] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f92]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f92]
;
ISCRIPT_A1C3:                               ; [$a1c3]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box
    .byte ISCRIPT_ACTION_CHECK_QUEST        ; Check if all spring quests are
                                            ; complete.
    .byte $03                               ; [$a1c5] Quests
    .word @_ISCRIPT_A1C3_COMPLETED_SPRINGS  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_WILL_REVIVE_SPRING
    .byte MESSAGEID_WILL_REVIVE_SPRING      ; [$a1c9] Message
    .byte ISCRIPT_ACTION_SET_QUEST_COMPLETE ; Mark all spring quests as
                                            ; complete.
    .byte $03                               ; [$a1cb] Quests
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1C3_COMPLETED_SPRINGS:         ; [$a1cd]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Ruby.
    .byte SPECIAL_RING_OF_RUBY              ; [$a1ce] InventoryItem
    .word @_ISCRIPT_A1CD_HAS_RING_OF_RUBY   ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_GIVING_RING_OF_RUBY
    .byte MESSAGEID_GIVING_RING_OF_RUBY     ; [$a1d2] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Give the player the Ring of
                                            ; Ruby.
    .byte SPECIAL_RING_OF_RUBY              ; [$a1d4] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1CD_HAS_RING_OF_RUBY:          ; [$a1d6]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_TRUST_YOUR_POWER
    .byte MESSAGEID_TRUST_YOUR_POWER        ; [$a1d7] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9b]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9b]
;
ISCRIPT_A1D9:                               ; [$a1d9]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Large Shield.
    .byte SHIELD_LARGE                      ; [$a1db] InventoryItem
    .word @_ISCRIPT_A1D9_HAS_LARGE_SHIELD   ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_MASCON
    .byte MESSAGEID_WELCOME_TO_MASCON       ; [$a1df] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1D9_HAS_LARGE_SHIELD:          ; [$a1e1]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_PREPARE_BEFORE_FOREPAW.
    .byte MESSAGEID_PREPARE_BEFORE_FOREPAW  ; [$a1e2] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9c]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9c]
;
ISCRIPT_A1E4:                               ; [$a1e4]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Pendant.
    .byte SPECIAL_PENDANT                   ; [$a1e6] InventoryItem
    .word @_ISCRIPT_A1E4_HAS_PENDANT        ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_METEORITE_BECOMES_POISON
    .byte MESSAGEID_METEORITE_BECOMES_POISON ; [$a1ea] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1E4_HAS_PENDANT:               ; [$a1ec]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DID_YOU_GET_PENDANT.
    .byte MESSAGEID_DID_YOU_GET_PENDANT     ; [$a1ed] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9d]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9d]
;
ISCRIPT_A1EF:                               ; [$a1ef]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Large Shield.
    .byte SHIELD_LARGE                      ; [$a1f1] InventoryItem
    .word @_ISCRIPT_A1EF_HAS_SHIELD         ; If so, branch.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_STORES_OUTSIDE_TOWN
    .byte MESSAGEID_STORES_OUTSIDE_TOWN     ; [$a1f5] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1EF_HAS_SHIELD:                ; [$a1f7]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THIS_IS_LARGE_SHIELD.
    .byte MESSAGEID_THIS_IS_LARGE_SHIELD    ; [$a1f8] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9e]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9e]
;
ISCRIPT_A1FA:                               ; [$a1fa]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Fire magic.
    .byte MAGIC_FIRE                        ; [$a1fc] InventoryItem
    .word @_ISCRIPT_A1FA_HAS_FIRE           ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DIRECTIONS_TO_SUFFER.
    .byte MESSAGEID_DIRECTIONS_TO_SUFFER    ; [$a200] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A1FA_HAS_FIRE:                  ; [$a202]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_NEED_WING_BOOTS_FOR_MIST.
    .byte MESSAGEID_NEED_WING_BOOTS_FOR_MIST ; [$a203] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9f]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f9f]
;
ISCRIPT_A205:                               ; [$a205]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Fire magic.
    .byte MAGIC_FIRE                        ; [$a207] InventoryItem
    .word @_ISCRIPT_A205_HAS_FIRE           ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_MIST
    .byte MESSAGEID_WELCOME_TO_MIST         ; [$a20b] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A205_HAS_FIRE:                  ; [$a20d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_HOUSE_OUTSIDE_ABANDONED.
    .byte MESSAGEID_HOUSE_OUTSIDE_ABANDONED ; [$a20e] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with a man sitting in a house in the Mist part of the
; Overworld.
;
; This house is nested in the bottom-right of the
; overworld part of the Mist area.
;
; If the player has the Fire magic, he'll say that it's
; best you keep the pendant. Otherwise, he'll say you'll
; reach the town of Suffer soon.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa0]
;
ISCRIPT_OVERWORLD_MIST_HOUSE_MAN:           ; [$a210]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Pendant.
    .byte SPECIAL_PENDANT                   ; [$a212] InventoryItem
    .word @_ISCRIPT_OVERWORLD_MIST_HOUSE_MAN_HAS_PENDANT ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_TOWER_OF_SUFFER_SOON.
    .byte MESSAGEID_TOWER_OF_SUFFER_SOON    ; [$a216] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_OVERWORLD_MIST_HOUSE_MAN_HAS_PENDANT: ; [$a218]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_KEEP_PENDANT.
    .byte MESSAGEID_KEEP_PENDANT            ; [$a219] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with a woman walking in a house in the Mist part of the
; Overworld.
;
; This house is nested in the bottom-right of the
; overworld part of the Mist area.
;
; If the player has the Pendant, she'll say that the
; Meteorite has moved. Otherwise, she'll say that the
; dwarves are chanting to the meteorite.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa1]
;
ISCRIPT_OVERWORLD_MIST_HOUSE_WOMAN:         ; [$a21b]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Pendant.
    .byte SPECIAL_PENDANT                   ; [$a21d] InventoryItem
    .word @_ISCRIPT_OVERWORLD_MIST_HOUSE_WOMAN_HAS_PENDANT ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DWARVES_CHANTING.
    .byte MESSAGEID_DWARVES_CHANTING        ; [$a221] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_OVERWORLD_MIST_HOUSE_WOMAN_HAS_PENDANT: ; [$a223]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_METEORITE_WAS_MOVED.
    .byte MESSAGEID_METEORITE_WAS_MOVED     ; [$a224] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa2]
;
ISCRIPT_A226:                               ; [$a226]
    .byte ISCRIPT_ENTITY_NURSE              ; XXX Show a portrait box
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Hour Glass.
    .byte ITEM_HOUR_GLASS                   ; [$a228] InventoryItem
    .word @_ISCRIPT_A226_HAS_HOURGLASS      ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_HOUR_GLASS.
    .byte MESSAGEID_HOUR_GLASS              ; [$a22c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A226_HAS_HOURGLASS:             ; [$a22e]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_HOUR_GLASS_USES_ENERGY.
    .byte MESSAGEID_HOUR_GLASS_USES_ENERGY  ; [$a22f] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fab]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fab]
;
ISCRIPT_A231:                               ; [$a231]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Thunder magic.
    .byte MAGIC_THUNDER                     ; [$a233] InventoryItem
    .word @_ISCRIPT_A231_HAS_THUNDER        ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_VICTIM.
    .byte MESSAGEID_WELCOME_TO_VICTIM       ; [$a237] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A231_HAS_THUNDER:               ; [$a239]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DANGEROUS_WITHOUT_MAGIC.
    .byte MESSAGEID_DANGEROUS_WITHOUT_MAGIC ; [$a23a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fac]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fac]
;
ISCRIPT_A23C:                               ; [$a23c]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Thunder magic.
    .byte MAGIC_THUNDER                     ; [$a23e] InventoryItem
    .word @_ISCRIPT_A23C_HAS_THUNDER        ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_MAGIC_CONSUMES_POWER.
    .byte MESSAGEID_MAGIC_CONSUMES_POWER    ; [$a242] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A23C_HAS_THUNDER:               ; [$a244]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_METEORITE_BECOMES_BLACK_ONYX.
    .byte MESSAGEID_METEORITE_BECOMES_BLACK_ONYX ; [$a245] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fad]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fad]
;
ISCRIPT_A247:                               ; [$a247]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Thunder magic.
    .byte MAGIC_THUNDER                     ; [$a249] InventoryItem
    .word @_ISCRIPT_A247_HAS_THUNDER        ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_MAGIC_HALL_OUTSIDE_TOWN.
    .byte MESSAGEID_MAGIC_HALL_OUTSIDE_TOWN ; [$a24d] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A247_HAS_THUNDER:               ; [$a24f]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MAGIC_CANE.
    .byte MESSAGEID_MAGIC_CANE              ; [$a250] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fae]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fae]
;
ISCRIPT_A252:                               ; [$a252]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_PLAYER_RANK  ; Check if the Player has at
                                            ; least the Soldier rank.
    .byte RANK_SOLDIER                      ; [$a254] PlayerTitle
    .word @_ISCRIPT_A252_HAS_RANK           ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_GO_TO_CAPITAL.
    .byte MESSAGEID_GO_TO_CAPITAL           ; [$a258] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A252_HAS_RANK:                  ; [$a25a]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Full Plate armor.
    .byte ARMOR_FULL_PLATE                  ; [$a25b] InventoryItem
    .word @_ISCRIPT_A252_HAS_ARMOR          ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_GOT_ARMOR_FOR_BOTTLE.
    .byte MESSAGEID_GOT_ARMOR_FOR_BOTTLE    ; [$a25f] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the full plate to the
                                            ; inventory.
    .byte ARMOR_FULL_PLATE                  ; [$a261] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A252_HAS_ARMOR:                 ; [$a263]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_ILL_HAVE_DRINK.
    .byte MESSAGEID_ILL_HAVE_DRINK          ; [$a264] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9faf]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9faf]
;
ISCRIPT_A266:                               ; [$a266]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Thunder magic.
    .byte MAGIC_THUNDER                     ; [$a268] InventoryItem
    .word @_ISCRIPT_A266_HAS_THUNDER        ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_IM_LOST.
    .byte MESSAGEID_IM_LOST                 ; [$a26c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A266_HAS_THUNDER:               ; [$a26e]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_IM_LOST_MAGIC_DOES_NOT_WORK.
    .byte MESSAGEID_IM_LOST_MAGIC_DOES_NOT_WORK ; [$a26f] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb0]
;
ISCRIPT_A271:                               ; [$a271]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Thunder magic.
    .byte MAGIC_THUNDER                     ; [$a273] InventoryItem
    .word @_ISCRIPT_A271_HAS_THUNDER        ; If so, branch.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_MAGIC_OF_JUSTICE_OR_DESTRUCTION.
    .byte MESSAGEID_MAGIC_OF_JUSTICE_OR_DESTRUCTION ; [$a277] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A271_HAS_THUNDER:               ; [$a279]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MAGIC_INDIVIDUAL_POWERS.
    .byte MESSAGEID_MAGIC_INDIVIDUAL_POWERS ; [$a27a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb1]
;
ISCRIPT_A27C:                               ; [$a27c]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Black Onyx.
    .byte SPECIAL_BLACK_ONYX                ; [$a27e] InventoryItem
    .word @_ISCRIPT_A27C_HAS_BLACK_ONYX     ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DIRECTIONS_TO_TOWER_OF_MIST.
    .byte MESSAGEID_DIRECTIONS_TO_TOWER_OF_MIST ; [$a282] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A27C_HAS_BLACK_ONYX:            ; [$a284]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the "A"
                                            ; key.
    .byte KEY_A                             ; [$a285] InventoryItem
    .word @_ISCRIPT_A27C_HAS_KEY            ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_USE_KEY_FOR_CONFLATE.
    .byte MESSAGEID_USE_KEY_FOR_CONFLATE    ; [$a289] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the "A" key to the
                                            ; inventory.
    .byte KEY_A                             ; [$a28b] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A27C_HAS_KEY:                   ; [$a28d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_YOU_NEED_KEY_ACE.
    .byte MESSAGEID_YOU_NEED_KEY_ACE        ; [$a28e] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbb]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbb]
;
ISCRIPT_A290:                               ; [$a290]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic textbox.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Giant Blade.
    .byte WEAPON_GIANT_BLADE                ; [$a292] InventoryItem
    .word @_ISCRIPT_A290_HAS_GIANT_BLADE    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WELCOME_TO_CONFLATE.
    .byte MESSAGEID_WELCOME_TO_CONFLATE     ; [$a296] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A290_HAS_GIANT_BLADE:           ; [$a298]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_LEGENDARY_SHIELD_HELMET.
    .byte MESSAGEID_LEGENDARY_SHIELD_HELMET ; [$a299] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbc]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbc]
;
ISCRIPT_A29B:                               ; [$a29b]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Giant Blade.
    .byte WEAPON_GIANT_BLADE                ; [$a29d] InventoryItem
    .word @_ISCRIPT_A29B_HAS_GIANT_BLADE    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_TOWN_SURROUNDED_BY_DOORS.
    .byte MESSAGEID_TOWN_SURROUNDED_BY_DOORS ; [$a2a1] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A29B_HAS_GIANT_BLADE:           ; [$a2a3]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_SEE_GURU_AFTER_SHIELD_HELMET.
    .byte MESSAGEID_SEE_GURU_AFTER_SHIELD_HELMET ; [$a2a4] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbd]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbd]
;
ISCRIPT_A2A6:                               ; [$a2a6]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Dworf.
    .byte SPECIAL_RING_OF_DWORF             ; [$a2a8] InventoryItem
    .word @_ISCRIPT_A2A6_HAS_RING_OF_DWORF  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_GUARDIAN_OF_GURU.
    .byte MESSAGEID_GUARDIAN_OF_GURU        ; [$a2ac] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2A6_HAS_RING_OF_DWORF:         ; [$a2ae]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Magical Rod.
    .byte SPECIAL_MAGICAL_ROD               ; [$a2af] InventoryItem
    .word @_ISCRIPT_A2A6_HAS_MAGICAL_ROD    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_SOMETHING_YOU_CAN_GET.
    .byte MESSAGEID_SOMETHING_YOU_CAN_GET   ; [$a2b3] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2A6_HAS_MAGICAL_ROD:           ; [$a2b5]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_RELY_ON_MAGIC_FINAL_BATTLE.
    .byte MESSAGEID_DONT_RELY_ON_MAGIC_FINAL_BATTLE ; [$a2b6] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbe]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbe]
;
ISCRIPT_A2B8:                               ; [$a2b8]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Helmet.
    .byte SHIELD_BATTLE_HELMET              ; [$a2ba] InventoryItem
    .word @_ISCRIPT_A2B8_HAS_BATTLE_HELMET  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_USED_TO_TRADE_WITH_DWARVES.
    .byte MESSAGEID_USED_TO_TRADE_WITH_DWARVES ; [$a2be] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2B8_HAS_BATTLE_HELMET:         ; [$a2c0]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_USED_TO_BE_SKILLED.
    .byte MESSAGEID_USED_TO_BE_SKILLED      ; [$a2c1] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbf]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fbf]
;
ISCRIPT_A2C3:                               ; [$a2c3]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Helmet.
    .byte SHIELD_BATTLE_HELMET              ; [$a2c5] InventoryItem
    .word @_ISCRIPT_A2C3_HAS_BATTLE_HELMET  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_USED_TO_VISIT_DWARVES.
    .byte MESSAGEID_USED_TO_VISIT_DWARVES   ; [$a2c9] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2C3_HAS_BATTLE_HELMET:         ; [$a2cb]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_AM_PICKPOCKET.
    .byte MESSAGEID_I_AM_PICKPOCKET         ; [$a2cc] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcb]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcb]
;
ISCRIPT_A2CE:                               ; [$a2ce]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Tilte magic.
    .byte MAGIC_TILTE                       ; [$a2d0] InventoryItem
    .word @_ISCRIPT_A2CE_HAS_TILTE          ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DIRECTIONS_DAYBREAK.
    .byte MESSAGEID_DIRECTIONS_DAYBREAK     ; [$a2d4] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2CE_HAS_TILTE:                 ; [$a2d6]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_FRIENDS_IN_DARTMOOR.
    .byte MESSAGEID_FRIENDS_IN_DARTMOOR     ; [$a2d7] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcc]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcc]
;
ISCRIPT_A2D9:                               ; [$a2d9]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Suit.
    .byte ARMOR_BATTLE_SUIT                 ; [$a2db] InventoryItem
    .word @_ISCRIPT_A2D9_HAS_BATTLE_SUIT    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_LOOK_FOR_BATTLE_SUIT.
    .byte MESSAGEID_LOOK_FOR_BATTLE_SUIT    ; [$a2df] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2D9_HAS_BATTLE_SUIT:           ; [$a2e1]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_FIND_MAGIC_CANE.
    .byte MESSAGEID_FIND_MAGIC_CANE         ; [$a2e2] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XXX Check if easter egg?
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcd]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcd]
;
ISCRIPT_A2E4:                               ; [$a2e4]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Dworf.
    .byte SPECIAL_RING_OF_DWORF             ; [$a2e6] InventoryItem
    .word @_ISCRIPT_A2E4_HAS_RING_OF_DWORF  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_YOU_ARE_FAMOUS_GOOD_LOOKING.
    .byte MESSAGEID_YOU_ARE_FAMOUS_GOOD_LOOKING ; [$a2ea] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2E4_HAS_RING_OF_DWORF:         ; [$a2ec]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_AUTOGRAPH.
    .byte MESSAGEID_AUTOGRAPH               ; [$a2ed] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fce]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fce]
;
ISCRIPT_A2EF:                               ; [$a2ef]
    .byte ISCRIPT_ENTITY_NURSE              ; XXX Show a portrait text box
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Suit.
    .byte ARMOR_BATTLE_SUIT                 ; [$a2f1] InventoryItem
    .word @_ISCRIPT_A2EF_HAS_BATTLE_SUIT    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_WHEN_TAKE_BATH.
    .byte MESSAGEID_WHEN_TAKE_BATH          ; [$a2f5] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2EF_HAS_BATTLE_SUIT:           ; [$a2f7]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_GURU_CONFLATE_HAS_RING_DWARVES.
    .byte MESSAGEID_GURU_CONFLATE_HAS_RING_DWARVES ; [$a2f8] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcf]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fcf]
;
ISCRIPT_A2FA:                               ; [$a2fa]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Suit.
    .byte ARMOR_BATTLE_SUIT                 ; [$a2fc] InventoryItem
    .word @_ISCRIPT_A2FA_HAS_BATTLE_SUIT    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DID_YOU_GET_BATTLE_SUIT.
    .byte MESSAGEID_DID_YOU_GET_BATTLE_SUIT ; [$a300] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A2FA_HAS_BATTLE_SUIT:           ; [$a302]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show,
                                            ; MESSAGE_DARTMORE_IS_MAZE.
    .byte MESSAGEID_DARTMORE_IS_MAZE        ; [$a303] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd0]
;
ISCRIPT_A305:                               ; [$a305]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Suit.
    .byte ARMOR_BATTLE_SUIT                 ; [$a307] InventoryItem
    .word @_ISCRIPT_A305_HAS_BATTLE_SUIT    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_IS_FIRST_VISIT_TO_STORE.
    .byte MESSAGEID_IS_FIRST_VISIT_TO_STORE ; [$a30b] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A305_HAS_BATTLE_SUIT:           ; [$a30d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MAGIC_CANE_ABOVE_TOWER.
    .byte MESSAGEID_MAGIC_CANE_ABOVE_TOWER  ; [$a30e] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdb]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdb]
;
ISCRIPT_A310:                               ; [$a310]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Dragon Slayer.
    .byte WEAPON_DRAGON_SLAYER              ; [$a312] InventoryItem
    .word @_ISCRIPT_A310_HAS_DRAGON_SLAYER  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_DIRECTIONS_TO_FRATERNAL.
    .byte MESSAGEID_DIRECTIONS_TO_FRATERNAL ; [$a316] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A310_HAS_DRAGON_SLAYER:         ; [$a318]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_YOU_NEED_DEMONS_RING.
    .byte MESSAGEID_YOU_NEED_DEMONS_RING    ; [$a319] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with a man sitting in a house in the overworld.
;
; This is in the bottom-left of an area otherwise full of
; enemy houses, 4 screens to the left of the Evil Fortress
; entrance. Exterior looks like a castle.
;
; If the player has the Dragon Slayer, he'll say to defeat
; evil with it. If not, he'll say that King Grieve has it.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdc]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdc]
;
ISCRIPT_OVERWORLD_HOUSE_MAN:                ; [$a31b]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Dragon Slayer.
    .byte WEAPON_DRAGON_SLAYER              ; [$a31d] InventoryItem
    .word @_ISCRIPT_OVERWORLD_HOUSE_MAN_HAS_DRAGON_SLAYER ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_KING_GRIEVE_HAS_DRAGON_SLAYER.
    .byte MESSAGEID_KING_GRIEVE_HAS_DRAGON_SLAYER ; [$a321] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_OVERWORLD_HOUSE_MAN_HAS_DRAGON_SLAYER: ; [$a323]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DEFEAT_EVIL_WITH_DRAGON_SLAYER.
    .byte MESSAGEID_DEFEAT_EVIL_WITH_DRAGON_SLAYER ; [$a324] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with a woman walking in a house in the overworld.
;
; This is in the bottom-left of an area otherwise full of
; enemy houses, 4 screens to the left of the Evil Fortress
; entrance. Exterior looks like a castle.
;
; If the player has the Dragon Slayer, she'll say that the
; Guru has the Demon's Ring. Otherwise, she'll say to find
; the Guru in Castle Fraternal.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdd]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdd]
;
ISCRIPT_OVERWORLD_HOUSE_WOMAN:              ; [$a326]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Dragon Slayer.
    .byte WEAPON_DRAGON_SLAYER              ; [$a328] InventoryItem
    .word @_ISCRIPT_OVERWORLD_HOUSE_WOMAN_HAS_DRAGON_SLAYER ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_GO_TO_FRATERNAL_GURU.
    .byte MESSAGEID_GO_TO_FRATERNAL_GURU    ; [$a32c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_OVERWORLD_HOUSE_WOMAN_HAS_DRAGON_SLAYER: ; [$a32e]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_GURU_HAS_DEMONS_RING.
    .byte MESSAGEID_GURU_HAS_DEMONS_RING    ; [$a32f] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; TODO
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fde]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fde]
;
ISCRIPT_A331:                               ; [$a331]
    .byte ISCRIPT_ENTITY_GENERIC            ; Show a generic text box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Dragon Slayer.
    .byte WEAPON_DRAGON_SLAYER              ; [$a333] InventoryItem
    .word @_ISCRIPT_A331_HAS_DRAGON_SLAYER  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_SEARCH_CASTLE_FOR_GURU.
    .byte MESSAGEID_SEARCH_CASTLE_FOR_GURU  ; [$a337] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A331_HAS_DRAGON_SLAYER:         ; [$a339]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_EVIL_IMMUNE_TO_MAGIC.
    .byte MESSAGEID_EVIL_IMMUNE_TO_MAGIC    ; [$a33a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Guru of Castle Fraternal.
;
; If the player has both the Dragon Slayer sword
; and the Demon's Ring, the Guru will say he'll
; meditate for you.
;
; If the player has the Dragon Slayer but not the
; Demon's Ring, the player will receive the Demon's Ring
; and tell you King Grieve has been defeated and to use
; the ring to reach the final boss.
;
; If the player doesn't have the Dragon Slayer, the
; Guru will give exposition on the meteorite.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdf]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fdf]
;
ISCRIPT_FRATERNAL_GURU:                     ; [$a33c]
    .byte ISCRIPT_ENTITY_GURU               ; Show the Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Dragon Slayer.
    .byte WEAPON_DRAGON_SLAYER              ; [$a33e] InventoryItem
    .word @_ISCRIPT_A33C_HAS_DRAGON_SLAYER  ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Else, show
                                            ; MESSAGE_METEORITE_EXPOSITION_2.
    .byte MESSAGEID_METEORITE_EXPOSITION_2  ; [$a342] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A33C_HAS_DRAGON_SLAYER:         ; [$a344]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Demon's Ring.
    .byte SPECIAL_DEMONS_RING               ; [$a345] InventoryItem
    .word @_ISCRIPT_A33C_HAS_DEMONS_RING    ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_DEFEATED_KING_GRIEVE.
    .byte MESSAGEID_DEFEATED_KING_GRIEVE    ; [$a349] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the Demon's Ring to the
                                            ; inventory.
    .byte SPECIAL_DEMONS_RING               ; [$a34b] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_A33C_HAS_DEMONS_RING:           ; [$a34d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_ILL_MEDITATE_FOR_YOU.
    .byte MESSAGEID_ILL_MEDITATE_FOR_YOU    ; [$a34e] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the King.
;
; If the player has no gold, the King will say some
; exposition and give 1500G.
;
; If the player already has gold, the King will say there's
; nothing more he can do to help.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f73]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f73]
;
ISCRIPT_EOLIS_KING:                         ; [$a350]
    .byte ISCRIPT_ENTITY_KING               ; Show the King portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_CHECK_GOLD         ; Check if the player has gold.
    .word @_ISCRIPT_NPC_KING_FOLLOW_UP_HAS_GOLD ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Else, show
                                                  ; MESSAGE_KING_EXPOSITION.
    .byte MESSAGEID_KING_EXPOSITION         ; [$a355] Message
    .byte ISCRIPT_ACTION_ADD_GOLD           ; Add 1500 gold.
    .word $05dc                             ; [$a357] ushort

    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_NPC_KING_FOLLOW_UP_HAS_GOLD:    ; [$a35a]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_NOTHING_MORE_TO_HELP.
    .byte MESSAGEID_NOTHING_MORE_TO_HELP    ; [$a35b] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction for Eolis Martial Arts / Magic Shop.
;
; The Martial Artist/Magician will give 40MP for 200G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f79]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f79]
;
ISCRIPT_EOLIS_MARTIAL_ARTS_MAGIC_SHOP:      ; [$a35d]
    .byte ISCRIPT_ENTITY_MAGICIAN           ; Show the Magician portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_MAGIC_200G.
    .byte MESSAGEID_MAGIC_200G              ; [$a35f] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 200G.
    .word $00c8                             ; [$a361] ushort

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 40MP.
    .byte $28                               ; [$a364] byte

    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_WATCH_POWER_LEVEL.
    .byte MESSAGEID_WATCH_POWER_LEVEL       ; [$a366] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction for the after-Victim Magic Shop.
;
; The Magician will sell Fire magic for 3000G.
;
; If the player already has Fire, he will say magic
; can be used for justice or destruction depending on
; who uses it.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb6]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb6]
;
ISCRIPT_AFTER_VICTIM_MAGIC_SHOP:            ; [$a368]
    .byte ISCRIPT_ENTITY_MAGICIAN           ; Show the Magician portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Fire magic.
    .byte MAGIC_FIRE                        ; [$a36a] InventoryItem
    .word @_ISCRIPT_AFTER_VICTIM_MAGIC_SHOP_HAS_FIRE ; If so, jump.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Else, show a dismissible
                                               ; MESSAGE_MAGIC_FIRE_3000G.
    .byte MESSAGEID_MAGIC_FIRE_3000G        ; [$a36e] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 3000G.
    .word $0bb8                             ; [$a370] ushort

    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the Fire magic to the
                                            ; inventory.
    .byte MAGIC_FIRE                        ; [$a373] InventoryItem
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_MAGIC_OF_JUSTICE_OR_DESTRUCTION.
    .byte MESSAGEID_MAGIC_OF_JUSTICE_OR_DESTRUCTION ; [$a375] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_AFTER_VICTIM_MAGIC_SHOP_HAS_FIRE: ; [$a377]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_RELY_ON_MAGIC.
    .byte MESSAGEID_DONT_RELY_ON_MAGIC      ; [$a378] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Eolis Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f78]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f78]
;
ISCRIPT_EOLIS_TOOL_SHOP:                    ; [$a37a]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a37c] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_EOLIS_TOOL_SHOP_BUY     ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word EOLIS_TOOL_SHOP_ITEMS             ; EOLIS_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a381]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a384] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_EOLIS_TOOL_SHOP_BUY:            ; [$a386]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word EOLIS_TOOL_SHOP_ITEMS             ; EOLIS_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a387]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a38a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Apolune Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f84]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f84]
;
ISCRIPT_APOLUNE_TOOL_SHOP:                  ; [$a38c]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a38e] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_APOLUNE_TOOL_SHOP_BUY   ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word APOLUNE_TOOL_SHOP_ITEMS           ; APOLUNE_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a393]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a396] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_APOLUNE_TOOL_SHOP_BUY:          ; [$a398]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word APOLUNE_TOOL_SHOP_ITEMS           ; Choose Buy
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a39c] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Before-Apolune Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f88]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f88]
;
ISCRIPT_BEFORE_APOLUNE_TOOL_SHOP:           ; [$a39e]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3a0] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_BEFORE_APOLUNE_TOOL_SHOP_BUY ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word BEFORE_APOLUNE_TOOL_SHOP_ITEMS    ; BEFORE_APOLUNE_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3a5]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3a8] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_BEFORE_APOLUNE_TOOL_SHOP_BUY:   ; [$a3aa]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word BEFORE_APOLUNE_TOOL_SHOP_ITEMS    ; BEFORE_APOLUNE_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3ab]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3ae] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Forepaw Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f93]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f93]
;
ISCRIPT_FOREPAW_TOOL_SHOP:                  ; [$a3b0]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3b2] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_FOREPAW_TOOL_SHOP_BUY   ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word FOREPAW_TOOL_SHOP_ITEMS           ; FOREPAW_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3b7]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3ba] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_FOREPAW_TOOL_SHOP_BUY:          ; [$a3bc]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word FOREPAW_TOOL_SHOP_ITEMS           ; FOREPAW_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3bd]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3c0] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Mascon Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa4]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa4]
;
ISCRIPT_MASCON_TOOL_SHOP:                   ; [$a3c2]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3c4] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_MASCON_TOOL_SHOP_BUY    ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word MASCON_TOOL_SHOP_ITEMS            ; MASCON_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3c9]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3cc] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_MASCON_TOOL_SHOP_BUY:           ; [$a3ce]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word MASCON_TOOL_SHOP_ITEMS            ; MASCON_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3cf]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3d2] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the After-Mascon Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa7]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa7]
;
ISCRIPT_AFTER_MASCON_TOOL_SHOP:             ; [$a3d4]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3d6] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_AFTER_MASCON_TOOL_SHOP_BUY ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word AFTER_MASCON_TOOL_SHOP_ITEMS      ; AFTER_MASCON_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3db]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3de] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_AFTER_MASCON_TOOL_SHOP_BUY:     ; [$a3e0]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word AFTER_MASCON_TOOL_SHOP_ITEMS      ; AFTER_MASCON_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3e1]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3e4] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Victim Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb3]
;
ISCRIPT_VICTIM_TOOL_SHOP:                   ; [$a3e6]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3e8] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_VICTIM_TOOL_SHOP_BUY    ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word VICTIM_TOOL_SHOP_ITEMS            ; VICTIM_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3ed]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3f0] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_VICTIM_TOOL_SHOP_BUY:           ; [$a3f2]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word VICTIM_TOOL_SHOP_ITEMS            ; VICTIM_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3f3]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a3f6] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Conflate Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc2]
;
ISCRIPT_CONFLATE_TOOL_SHOP:                 ; [$a3f8]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a3fa] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_CONFLATE_TOOL_SHOP_BUY  ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word CONFLATE_TOOL_SHOP_ITEMS          ; CONFLATE_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a3ff]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a402] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_CONFLATE_TOOL_SHOP_BUY:         ; [$a404]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word CONFLATE_TOOL_SHOP_ITEMS          ; CONFLATE_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a405]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a408] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Daybreak Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd1]
;
ISCRIPT_DAYBREAK_TOOL_SHOP:                 ; [$a40a]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a40c] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_DAYBREAK_TOOL_SHOP_BUY  ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word DAYBREAK_TOOL_SHOP_ITEMS          ; DAYBREAK_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a411]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a414] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_DAYBREAK_TOOL_SHOP_BUY:         ; [$a416]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word DAYBREAK_TOOL_SHOP_ITEMS          ; DAYBREAK_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a417]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a41a] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Dartmoor Tool Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe0]
;
ISCRIPT_DARTMOOR_TOOL_SHOP:                 ; [$a41c]
    .byte ISCRIPT_ENTITY_TOOLS_SALESMAN     ; Show the tools salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_TOOLS.
    .byte MESSAGEID_I_SELL_TOOLS            ; [$a41e] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_DARTMOOR_TOOL_SHOP_BUY  ; If Buy, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell, show the sell menu.
    .word DARTMOOR_TOOL_SHOP_ITEMS          ; DARTMOOR_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a423]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a426] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_DARTMOOR_TOOL_SHOP_BUY:         ; [$a428]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word DARTMOOR_TOOL_SHOP_ITEMS          ; DARTMOOR_TOOL_SHOP_ITEMS
                                            ; [$PRG12::a429]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a42c] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Eolis Tool Shop Items.
;
; * Hand Dagger: 400G
; * Red Potion:  160G
; * Elixir:      320G
; * Deluge:      400G
;============================================================================
EOLIS_TOOL_SHOP_ITEMS:                      ; [$a42e]
    .byte WEAPON_HAND_DAGGER                ; [$a42e] InventoryItem
    .word $0190                             ; [$a42f] ushort

    .byte ITEM_RED_POTION
    .word $00a0                             ; [$a432] ushort

    .byte SPECIAL_ELIXIR
    .word $0140                             ; [$a435] ushort

    .byte MAGIC_DELUGE
    .word $0190                             ; [$a438] ushort

    .byte $ff


;============================================================================
; Apolune Tool Shop Items.
;
; * Small Shield: 800G
; * Hand Dagger:  500G
; * Deluge:       500G
; * Red Potion:   300G
;============================================================================
APOLUNE_TOOL_SHOP_ITEMS:                    ; [$a43b]
    .byte SHIELD_SMALL                      ; [$a43b] InventoryItem
    .word $0320                             ; [$a43c] ushort

    .byte WEAPON_HAND_DAGGER
    .word $01f4                             ; [$a43f] ushort

    .byte MAGIC_DELUGE
    .word $01f4                             ; [$a442] ushort

    .byte ITEM_RED_POTION
    .word $012c                             ; [$a445] ushort

    .byte $ff


;============================================================================
; Before Apolune Tool Shop Items.
;
; * Magic Shield:  7600G
; * Death:        12500G
;============================================================================
BEFORE_APOLUNE_TOOL_SHOP_ITEMS:             ; [$a448]
    .byte SHIELD_MAGIC                      ; [$a448] InventoryItem
    .word $1db0                             ; [$a449] ushort

    .byte MAGIC_DEATH
    .word $30d4                             ; [$a44c] ushort

    .byte $ff


;============================================================================
; Forepaw Tool Shop Items.
;
; * Long Sword:   1600G
; * Studded Mail: 2500G
; * Small Shield: 1100G
; * Red Potion:    400G
; * Wing Boots:   2800G
;============================================================================
FOREPAW_TOOL_SHOP_ITEMS:                    ; [$a44f]
    .byte WEAPON_LONG_SWORD                 ; [$a44f] InventoryItem
    .word $0640                             ; [$a450] ushort

    .byte ARMOR_STUDDED_MAIL
    .word $09c4                             ; [$a453] ushort

    .byte SHIELD_SMALL
    .word $044c                             ; [$a456] ushort

    .byte ITEM_RED_POTION
    .word $0190                             ; [$a459] ushort

    .byte ITEM_WING_BOOTS
    .word $0af0                             ; [$a45c] ushort

    .byte $ff


;============================================================================
; Mascon Tool Shop Items:
;
; * Large Shield: 3500G
; * Thunder:      1200G
; * Mattock:       800G
; * Red Potion:    600G
;============================================================================
MASCON_TOOL_SHOP_ITEMS:                     ; [$a45f]
    .byte SHIELD_LARGE                      ; [$a45f] InventoryItem
    .word $0dac                             ; [$a460] ushort

    .byte MAGIC_THUNDER
    .word $04b0                             ; [$a463] ushort

    .byte MATTOCK
    .word $0320                             ; [$a466] ushort

    .byte ITEM_RED_POTION
    .word $0258                             ; [$a469] ushort

    .byte $ff


;============================================================================
; After Mascon Tool Shop Items.
;
; * Death:      9800G
; * Hour Glass: 5600G
; * Elixir:     4300G
; * Red Potion:  300G
;============================================================================
AFTER_MASCON_TOOL_SHOP_ITEMS:               ; [$a46c]
    .byte MAGIC_DEATH                       ; [$a46c] InventoryItem
    .word $2648                             ; [$a46d] ushort

    .byte ITEM_HOUR_GLASS
    .word $15e0                             ; [$a470] ushort

    .byte SPECIAL_ELIXIR
    .word $10cc                             ; [$a473] ushort

    .byte ITEM_RED_POTION
    .word $012c                             ; [$a476] ushort

    .byte $ff


;============================================================================
; Victim Tool Shop Items.
;
; * Full Plate: 5200G
; * Mattock:    1200G
; * Red Potion:  800G
;============================================================================
VICTIM_TOOL_SHOP_ITEMS:                     ; [$a479]
    .byte ARMOR_FULL_PLATE                  ; [$a479] InventoryItem
    .word $1450                             ; [$a47a] ushort

    .byte MATTOCK
    .word $04b0                             ; [$a47d] ushort

    .byte ITEM_RED_POTION
    .word $0320                             ; [$a480] ushort

    .byte $ff


;============================================================================
; Conflate Tool Shop Items:
;
; * Giant Blade:  8500G
; * Magic Shield: 9800G
; * Wing Boots:   5500G
; * Red Potion:   1000G
;============================================================================
CONFLATE_TOOL_SHOP_ITEMS:                   ; [$a483]
    .byte WEAPON_GIANT_BLADE                ; [$a483] InventoryItem
    .word $2134                             ; [$a484] ushort

    .byte SHIELD_MAGIC
    .word $2648                             ; [$a487] ushort

    .byte ITEM_WING_BOOTS
    .word $157c                             ; [$a48a] ushort

    .byte ITEM_RED_POTION
    .word $03e8                             ; [$a48d] ushort

    .byte $ff


;============================================================================
; Daybreak Tool Shop Items.
;
; * Tilte:       15000G
; * Giant Blade: 11500G
; * Red Potion:   1200G
;============================================================================
DAYBREAK_TOOL_SHOP_ITEMS:                   ; [$a490]
    .byte MAGIC_TILTE                       ; [$a490] InventoryItem
    .word $3a98                             ; [$a491] ushort

    .byte WEAPON_GIANT_BLADE
    .word $2cec                             ; [$a494] ushort

    .byte ITEM_RED_POTION
    .word $04b0                             ; [$a497] ushort

    .byte $ff


;============================================================================
; Dartmoor Tool Shop Items.
;
; * Giant Blade: 13000G
; * Red Potion:   2000G
;============================================================================
DARTMOOR_TOOL_SHOP_ITEMS:                   ; [$a49a]
    .byte WEAPON_GIANT_BLADE                ; [$a49a] InventoryItem
    .word $32c8                             ; [$a49b] ushort

    .byte ITEM_RED_POTION
    .word $07d0                             ; [$a49e] ushort

    .byte $ff


;============================================================================
; Interaction with the Eolis Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 50G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f76]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f76]
;
ISCRIPT_EOLIS_MEAT_SHOP:                    ; [$a4a1]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_50G.
    .byte MESSAGEID_DRIED_MEAT_50G          ; [$a4a3] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 50G.
    .word $0032                             ; [$a4a5] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4a8] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4aa] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4ac] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Forepaw Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 150G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f97]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f97]
;
ISCRIPT_FOREPAW_MEAT_SHOP:                  ; [$a4ae]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_150G.
    .byte MESSAGEID_DRIED_MEAT_150G         ; [$a4b0] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 150G.
    .word $0096                             ; [$a4b2] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4b5] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4b7] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4b9] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Mascon Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 180G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa5]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa5]
;
ISCRIPT_MASCON_MEAT_SHOP:                   ; [$a4bb]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_180G.
    .byte MESSAGEID_DRIED_MEAT_180G         ; [$a4bd] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 180G.
    .word $00b4                             ; [$a4bf] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4c2] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4c4] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4c6] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Victim Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 250G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb4]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb4]
;
ISCRIPT_VICTIM_MEAT_SHOP:                   ; [$a4c8]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_250G.
    .byte MESSAGEID_DRIED_MEAT_250G         ; [$a4ca] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 250G.
    .word $00fa                             ; [$a4cc] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4cf] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4d1] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4d3] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Conflate Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 350G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc3]
;
ISCRIPT_CONFLATE_MEAT_SHOP:                 ; [$a4d5]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_350G.
    .byte MESSAGEID_DRIED_MEAT_350G         ; [$a4d7] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 350G.
    .word $015e                             ; [$a4d9] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4dc] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4de] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4e0] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Daybreak Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 500G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd2]
;
ISCRIPT_DAYBREAK_MEAT_SHOP:                 ; [$a4e2]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_500G.
    .byte MESSAGEID_DRIED_MEAT_500G         ; [$a4e4] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 500G.
    .word $01f4                             ; [$a4e6] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4e9] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4eb] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4ed] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Dartmoor Meat Shop.
;
; The shop keeper will offer 30HP and 30MP for 800G.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe1]
;
ISCRIPT_DARTMOOR_MEAT_SHOP:                 ; [$a4ef]
    .byte ISCRIPT_ENTITY_MEAT_SALESMAN      ; Show the meat shop salesman
                                            ; portrait text box.
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show
                                               ; MESSAGE_DRIED_MEAT_800G.
    .byte MESSAGEID_DRIED_MEAT_800G         ; [$a4f1] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay 800G.
    .word $0320                             ; [$a4f3] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 30HP.
    .byte $1e                               ; [$a4f6] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 30MP.
    .byte $1e                               ; [$a4f8] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a4fa] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Eolis Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f77]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f77]
;
ISCRIPT_EOLIS_KEY_SHOP:                     ; [$a4fc]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a4fe] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_EOLIS_KEY_SHOP_BUY      ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word EOLIS_KEY_SHOP_ITEMS              ; EOLIS_KEY_SHOP_ITEMS
                                            ; [$PRG12::a503]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a506] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_EOLIS_KEY_SHOP_BUY:             ; [$a508]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word EOLIS_KEY_SHOP_ITEMS              ; EOLIS_KEY_SHOP_ITEMS
                                            ; [$PRG12::a509]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a50c] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Apolune Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f85]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f85]
;
ISCRIPT_APOLUNE_KEY_SHOP:                   ; [$a50e]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a510] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_APOLUNE_KEY_SHOP_BUY    ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word APOLUNE_KEY_SHOP_ITEMS            ; APOLUNE_KEY_SHOP_ITEMS
                                            ; [$PRG12::a515]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a518] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_APOLUNE_KEY_SHOP_BUY:           ; [$a51a]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word APOLUNE_KEY_SHOP_ITEMS            ; APOLUNE_KEY_SHOP_ITEMS
                                            ; [$PRG12::a51b]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a51e] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Forepaw Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f96]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f96]
;
ISCRIPT_FOREPAW_KEY_SHOP:                   ; [$a520]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a522] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_FOREPAW_KEY_SHOP_BUY    ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word FOREPAW_KEY_SHOP_ITEMS            ; FOREPAW_KEY_SHOP_ITEMS
                                            ; [$PRG12::a527]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a52a] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_FOREPAW_KEY_SHOP_BUY:           ; [$a52c]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word FOREPAW_KEY_SHOP_ITEMS            ; FOREPAW_KEY_SHOP_ITEMS
                                            ; [$PRG12::a52d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a530] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Mascon Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa6]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa6]
;
ISCRIPT_MASCON_KEY_SHOP:                    ; [$a532]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a534] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_MASCONE_KEY_SHOP_BUY    ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word MACONE_KEY_SHOP_ITEMS             ; MACONE_KEY_SHOP_ITEMS
                                            ; [$PRG12::a539]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a53c] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_MASCONE_KEY_SHOP_BUY:           ; [$a53e]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word MACONE_KEY_SHOP_ITEMS             ; MACONE_KEY_SHOP_ITEMS
                                            ; [$PRG12::a53f]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a542] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Victim Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb5]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb5]
;
ISCRIPT_VICTIM_KEY_SHOP:                    ; [$a544]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a546] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_VICTIM_KEY_SHOP_BUY     ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word VICTIM_KEY_SHOP_ITEMS             ; VICTIM_KEY_SHOP_ITEMS
                                            ; [$PRG12::a54b]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a54e] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_VICTIM_KEY_SHOP_BUY:            ; [$a550]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word VICTIM_KEY_SHOP_ITEMS             ; VICTIM_KEY_SHOP_ITEMS
                                            ; [$PRG12::a551]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a554] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Daybreak Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd3]
;
ISCRIPT_DAYBREAK_KEY_SHOP:                  ; [$a556]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a558] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_DAYBREAK_KEY_SHOP_BUY   ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word DAYBREAK_KEY_SHOP_ITEMS           ; DAYBREAK_KEY_SHOP_ITEMS
                                            ; [$PRG12::a55d]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a560] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_DAYBREAK_KEY_SHOP_BUY:          ; [$a562]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word DAYBREAK_KEY_SHOP_ITEMS           ; DAYBREAK_KEY_SHOP_ITEMS
                                            ; [$PRG12::a563]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a566] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the Dartmoor Key Shop.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe2]
;
ISCRIPT_DARTMOOR_KEY_SHOP:                  ; [$a568]
    .byte ISCRIPT_ENTITY_KEY_SALESMAN       ; Show the key salesman portrait
                                            ; text box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_I_SELL_KEYS.
    .byte MESSAGEID_I_SELL_KEYS             ; [$a56a] Message
    .byte ISCRIPT_ACTION_SHOW_BUY_SELL_MENU ; Show the Buy/Sell menu.
    .word @_ISCRIPT_DARTMOOR_KEY_SHOP_BUY   ; If Buy was chosen, jump.
    .byte ISCRIPT_ACTION_SHOW_SELL_MENU     ; If Sell was chosen, show the
                                            ; sell menu.
    .word DARTMOOR_KEY_SHOP_ITEMS           ; DARTMOOR_KEY_SHOP_ITEMS
                                            ; [$PRG12::a56f]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a572] Message
    .byte ISCRIPT_ACTION_END                ; End.

  @_ISCRIPT_DARTMOOR_KEY_SHOP_BUY:          ; [$a574]
    .byte ISCRIPT_ACTION_OPEN_SHOP          ; Open the Buy shop menu.
    .word DARTMOOR_KEY_SHOP_ITEMS           ; DARTMOOR_KEY_SHOP_ITEMS
                                            ; [$PRG12::a575]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_THANK_YOU_FOR_SHOPPING.
    .byte MESSAGEID_THANK_YOU_FOR_SHOPPING  ; [$a578] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Eolis Key Shop Items
;
; * "J" Key: 100G
;============================================================================
EOLIS_KEY_SHOP_ITEMS:                       ; [$a57a]
    .byte KEY_J                             ; [$a57a] InventoryItem
    .word $0064                             ; [$a57b] ushort

    .byte $ff


;============================================================================
; Apolune Key Shop
;
; * "J" Key: 140G
;============================================================================
APOLUNE_KEY_SHOP_ITEMS:                     ; [$a57e]
    .byte KEY_J                             ; [$a57e] InventoryItem
    .word $008c                             ; [$a57f] ushort

    .byte $ff


;============================================================================
; Forepaw Key Shop Items
;
; * "J" Key: 200G
; * "Q" Key: 500G
;============================================================================
FOREPAW_KEY_SHOP_ITEMS:                     ; [$a582]
    .byte KEY_J                             ; [$a582] InventoryItem
    .word $00c8                             ; [$a583] ushort

    .byte KEY_Q
    .word $01f4                             ; [$a586] ushort

    .byte $ff


;============================================================================
; Mascone Key Shop Items
;
; * "J" Key: 500G
; * "Q" Key: 600G
;============================================================================
MACONE_KEY_SHOP_ITEMS:                      ; [$a589]
    .byte KEY_J                             ; [$a589] InventoryItem
    .word $01f4                             ; [$a58a] ushort

    .byte KEY_Q
    .word $0258                             ; [$a58d] ushort

    .byte $ff


;============================================================================
; Victim Key Shop Items
;
; * "K" Key: 1500G
; * "Q" Key: 1200G
;============================================================================
VICTIM_KEY_SHOP_ITEMS:                      ; [$a590]
    .byte KEY_K                             ; [$a590] InventoryItem
    .word $05dc                             ; [$a591] ushort

    .byte KEY_Q
    .word $04b0                             ; [$a594] ushort

    .byte $ff


;============================================================================
; Daybreak Key Shop Items
;
; * "K" Key: 1200G
; * "Q" Key: 1000G
;============================================================================
DAYBREAK_KEY_SHOP_ITEMS:                    ; [$a597]
    .byte KEY_K                             ; [$a597] InventoryItem
    .word $04b0                             ; [$a598] ushort

    .byte KEY_Q
    .word $03e8                             ; [$a59b] ushort

    .byte $ff


;============================================================================
; Dartmoor Key Shop Items
;
; * "K" Key - 1300G
;============================================================================
DARTMOOR_KEY_SHOP_ITEMS:                    ; [$a59e]
    .byte KEY_K                             ; [$a59e] InventoryItem
    .word $0514                             ; [$a59f] ushort

    .byte $ff


;============================================================================
; Interaction with the doctor of Apolune.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f80]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f80]
;
ISCRIPT_APOLUNE_DOCTOR:                     ; [$a5a2]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5a4] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_250G_PLEASE.
    .byte MESSAGEID_250G_PLEASE             ; [$a5a6] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $00fa                             ; [$a5a8] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5ab] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5ad] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5af] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the doctor of Forepaw.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f95]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f95]
;
ISCRIPT_FOREPAW_DOCTOR:                     ; [$a5b1]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5b3] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_500G_PLEASE.
    .byte MESSAGEID_500G_PLEASE             ; [$a5b5] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $01f4                             ; [$a5b7] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5ba] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5bc] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5be] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the doctor of Mascon.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa3]
;
ISCRIPT_MASCON_DOCTOR:                      ; [$a5c0]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5c2] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_1000G_PLEASE.
    .byte MESSAGEID_1000G_PLEASE            ; [$a5c4] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $03e8                             ; [$a5c6] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5c9] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5cb] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5cd] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the doctor of Victim.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb2]
;
ISCRIPT_VICTIM_DOCTOR:                      ; [$a5cf]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5d1] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_2500G_PLEASE.
    .byte MESSAGEID_2500G_PLEASE            ; [$a5d3] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $09c4                             ; [$a5d5] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5d8] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5da] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5dc] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the doctor of Conflate.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc1]
;
ISCRIPT_CONFLATE_DOCTOR:                    ; [$a5de]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5e0] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_1800G_PLEASE.
    .byte MESSAGEID_1800G_PLEASE            ; [$a5e2] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $0708                             ; [$a5e4] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5e7] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5e9] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5eb] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the doctor of Dartmoor.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe5]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe5]
;
ISCRIPT_DARTMOOR_DOCTOR:                    ; [$a5ed]
    .byte ISCRIPT_ENTITY_DOCTOR             ; Show the Doctor portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DO_YOU_WANT_TREATMENT.
    .byte MESSAGEID_DO_YOU_WANT_TREATMENT   ; [$a5ef] Message
    .byte ISCRIPT_ACTION_SHOW_QUESTION_MESSAGE ; Show a dismissible
                                               ; MESSAGE_3000G_PLEASE.
    .byte MESSAGEID_3000G_PLEASE            ; [$a5f1] Message
    .byte ISCRIPT_ACTION_PAY_GOLD           ; If not dismissed, pay gold.
    .word $0bb8                             ; [$a5f3] ushort

    .byte ISCRIPT_ACTION_ADD_HP             ; Add 80HP.
    .byte $50                               ; [$a5f6] byte

    .byte ISCRIPT_ACTION_ADD_MP             ; Add 80MP.
    .byte $50                               ; [$a5f8] byte

    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_DONT_TRY_TOO_HARD.
    .byte MESSAGEID_DONT_TRY_TOO_HARD       ; [$a5fa] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Common script for a player's new password at a temple.
;============================================================================
ISCRIPT_COMMON_GURU_PASSWORD:               ; [$a5fc]
    .byte ISCRIPT_ACTION_SHOW_MESSAGE       ; Show
                                            ; MESSAGE_MEDITATE_WITH_YOU.
    .byte MESSAGEID_MEDITATE_WITH_YOU       ; [$a5fd] Message
    .byte ISCRIPT_ACTION_SHOW_PASSWORD      ; Generate and show a new
                                            ; password.
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Common script for a player's new rank at a temple.
;============================================================================
ISCRIPT_COMMON_GURU_NEW_RANK:               ; [$a600]
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_NEW_TITLE.
    .byte MESSAGEID_NEW_TITLE               ; [$a601] Message
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the guru of Apolune.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f87]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f87]
;
ISCRIPT_APOLUNE_GURU:                       ; [$a603]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; temple of Apolune.
    .byte TEMPLE_APOLUNE                    ; [$a605] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a60a]


;============================================================================
; Interaction with the guru of Forepaw.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f94]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9f94]
;
ISCRIPT_FOREPAW_GURU:                       ; [$a60c]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; temple of Forepaw.
    .byte TEMPLE_FOREPAW                    ; [$a60e] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a613]


;============================================================================
; Interaction with the guru of Mascon.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa8]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fa8]
;
ISCRIPT_MASCON_GURU:                        ; [$a615]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; temple of Mascon.
    .byte TEMPLE_MASCON                     ; [$a617] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a61c]


;============================================================================
; Interaction with the guru of Victim.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb7]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fb7]
;
ISCRIPT_VICTIM_GURU:                        ; [$a61e]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; temple of Victim.
    .byte TEMPLE_VICTIM                     ; [$a620] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a625]


;============================================================================
; Interaction with the guru of Conflate.
;
; This guru will check if the player has the Battle Suit
; and Ring of Dworf.
;
; If they have the Battle Suit but not Ring of Dworf,
; the player will receive the ring and be given directions
; to Dartmore.
;
; Otherwise, they'll get the normal Guru behavior.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fc0]
;
ISCRIPT_CONFLATE_GURU:                      ; [$a627]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Battle Suit.
    .byte ARMOR_BATTLE_SUIT                 ; [$a629] InventoryItem
    .word @_ISCRIPT_GURU_CONFLATE_HAS_BATTLE_SUIT ; If so, jump.

  @_ISCRIPT_GURU_CONFLATE_DEFAULT:          ; [$a62c]
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; temple of Conflate.
    .byte TEMPLE_CONFLATE                   ; [$a62d] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a632]

  @_ISCRIPT_GURU_CONFLATE_HAS_BATTLE_SUIT:  ; [$a634]
    .byte ISCRIPT_ACTION_CHECK_FOR_ITEM     ; Check if the player has the
                                            ; Ring of Dworf.
    .byte SPECIAL_RING_OF_DWORF             ; [$a635] InventoryItem
    .word @_ISCRIPT_GURU_CONFLATE_DEFAULT   ; If so, jump to normal guru
                                            ; behavior.
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; Show
                                                  ; MESSAGE_DIRECTIONS_DARTMORE.
    .byte MESSAGEID_DIRECTIONS_DARTMORE     ; [$a639] Message
    .byte ISCRIPT_ACTION_ADD_ITEM           ; Add the Ring of Dworf to the
                                            ; inventory.
    .byte SPECIAL_RING_OF_DWORF             ; [$a63b] InventoryItem
    .byte ISCRIPT_ACTION_END                ; End.


;============================================================================
; Interaction with the guru of Daybreak.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd4]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fd4]
;
ISCRIPT_DAYBREAK_GURU:                      ; [$a63d]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; Daybreak temple.
    .byte TEMPLE_DAYBREAK                   ; [$a63f] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a644]


;============================================================================
; Interaction with the guru of the final temple.
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe3]
;
ISCRIPT_GURU_FINAL:                         ; [$a646]
    .byte ISCRIPT_ENTITY_GURU               ; Display a Guru portrait text
                                            ; box.
    .byte ISCRIPT_ACTION_SET_SPAWN_POINT    ; Set the spawn point to the
                                            ; final temple.
    .byte TEMPLE_FINAL                      ; [$a648] Temple
    .byte ISCRIPT_ACTION_CHECK_UPDATE_PLAYER_TITLE ; Check the player rank
                                                   ; and update if needed.
    .word ISCRIPT_COMMON_GURU_NEW_RANK      ; If set, jump to show the new
                                            ; rank.
    .byte ISCRIPT_ACTION_JUMP               ; Else, jump to show the new
                                            ; password.
    .word ISCRIPT_COMMON_GURU_PASSWORD      ; ISCRIPT_COMMON_GURU_PASSWORD
                                            ; [$PRG12::a64d]


;============================================================================
; "Glad you're back."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe4]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe4]
;
ISCRIPT_KING_END_GAME:                      ; [$a64f]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a64f] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a650] IScriptAction
    .byte MESSAGEID_GLAD_YOURE_BACK         ; [$a651] Message
    .byte ISCRIPT_ACTION_END_GAME           ; [$a652] IScriptAction
    .byte ISCRIPT_ACTION_END                ; [$a653] IScriptAction


;============================================================================
; "There is the mark of Queen by the key hole."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe6]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe6]
;
ISCRIPT_MARK_OF_QUEEN:                      ; [$a654]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a654] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a655] IScriptAction
    .byte MESSAGEID_MARK_OF_QUEEN           ; [$a656] Message
    .byte ISCRIPT_ACTION_END                ; [$a657] IScriptAction


;============================================================================
; "There is the mark of King by the key hole."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe7]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe7]
;
ISCRIPT_MARK_OF_KING:                       ; [$a658]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a658] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a659] IScriptAction
    .byte MESSAGEID_MARK_OF_KING            ; [$a65a] Message
    .byte ISCRIPT_ACTION_END                ; [$a65b] IScriptAction


;============================================================================
; "There is the mark of Ace by the key hole."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe8]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe8]
;
ISCRIPT_MARK_OF_ACE:                        ; [$a65c]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a65c] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a65d] IScriptAction
    .byte MESSAGEID_MARK_OF_ACE             ; [$a65e] Message
    .byte ISCRIPT_ACTION_END                ; [$a65f] IScriptAction


;============================================================================
; "There is the mark of Joker by the key hole."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe9]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fe9]
;
ISCRIPT_MARK_OF_JOKER:                      ; [$a660]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a660] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a661] IScriptAction
    .byte MESSAGEID_MARK_OF_JOKER           ; [$a662] Message
    .byte ISCRIPT_ACTION_END                ; [$a663] IScriptAction


;============================================================================
; "Do you need a ring to open a door?"
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fea]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fea]
;
ISCRIPT_NEED_RING_FOR_DOOR:                 ; [$a664]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a664] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a665] IScriptAction
    .byte MESSAGEID_NEED_RING_FOR_DOOR      ; [$a666] Message
    .byte ISCRIPT_ACTION_END                ; [$a667] IScriptAction


;============================================================================
; "I've used Red Potion."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9feb]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9feb]
;
ISCRIPT_USED_RED_POTION:                    ; [$a668]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a668] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a669] IScriptAction
    .byte MESSAGEID_USED_RED_POTION         ; [$a66a] Message
    .byte ISCRIPT_ACTION_END                ; [$a66b] IScriptAction


;============================================================================
; "I've used Mattock."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fec]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fec]
;
ISCRIPT_USED_MATTOCK:                       ; [$a66c]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a66c] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a66d] IScriptAction
    .byte MESSAGEID_USED_MATTOCK            ; [$a66e] Message
    .byte ISCRIPT_ACTION_END                ; [$a66f] IScriptAction


;============================================================================
; "I've used Hour Glass."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fed]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fed]
;
ISCRIPT_USED_HOURGLASS:                     ; [$a670]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a670] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a671] IScriptAction
    .byte MESSAGEID_USED_HOURGLASS          ; [$a672] Message
    .byte ISCRIPT_ACTION_END                ; [$a673] IScriptAction


;============================================================================
; "I've used Wing Boots."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fee]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fee]
;
ISCRIPT_USED_WINGBOOTS:                     ; [$a674]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a674] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a675] IScriptAction
    .byte MESSAGEID_USED_WINGBOOTS          ; [$a676] Message
    .byte ISCRIPT_ACTION_END                ; [$a677] IScriptAction


;============================================================================
; "I've used key."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fef]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fef]
;
ISCRIPT_USED_KEY:                           ; [$a678]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a678] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a679] IScriptAction
    .byte MESSAGEID_USED_KEY                ; [$a67a] Message
    .byte ISCRIPT_ACTION_END                ; [$a67b] IScriptAction


;============================================================================
; "I've used Elixir."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff0]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff0]
;
ISCRIPT_USED_ELIXIR:                        ; [$a67c]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a67c] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a67d] IScriptAction
    .byte MESSAGEID_USED_ELIXIR             ; [$a67e] Message
    .byte ISCRIPT_ACTION_END                ; [$a67f] IScriptAction


;============================================================================
; "I'm holding Elixir."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff1]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff1]
;
ISCRIPT_GOT_ELIXIR:                         ; [$a680]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a680] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a681] IScriptAction
    .byte MESSAGEID_HOLDING_ELIXIR          ; [$a682] Message
    .byte ISCRIPT_ACTION_END                ; [$a683] IScriptAction


;============================================================================
; "I'm holding Red Potion."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff2]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff2]
;
ISCRIPT_GOT_RED_POTION:                     ; [$a684]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a684] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a685] IScriptAction
    .byte MESSAGEID_HOLDING_RED_POTION      ; [$a686] Message
    .byte ISCRIPT_ACTION_END                ; [$a687] IScriptAction


;============================================================================
; "I'm holding Mattock."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff3]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff3]
;
ISCRIPT_GOT_MATTOCK:                        ; [$a688]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a688] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a689] IScriptAction
    .byte MESSAGEID_HOLDING_MATTOCK         ; [$a68a] Message
    .byte ISCRIPT_ACTION_END                ; [$a68b] IScriptAction


;============================================================================
; "I'm holding Wing Boots."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff4]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff4]
;
ISCRIPT_GOT_WINGBOOTS:                      ; [$a68c]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a68c] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a68d] IScriptAction
    .byte MESSAGEID_HOLDING_WINGBOOTS       ; [$a68e] Message
    .byte ISCRIPT_ACTION_END                ; [$a68f] IScriptAction


;============================================================================
; "I'm holding Hour Glass."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff5]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff5]
;
ISCRIPT_GOT_HOURGLASS:                      ; [$a690]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a690] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a691] IScriptAction
    .byte MESSAGEID_HOLDING_HOURGLASS       ; [$a692] Message
    .byte ISCRIPT_ACTION_END                ; [$a693] IScriptAction


;============================================================================
; "I've got the Battle Suit."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff6]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff6]
;
ISCRIPT_GOT_BATTLE_SUIT:                    ; [$a694]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a694] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a695] IScriptAction
    .byte MESSAGEID_GOT_BATTLE_SUIT         ; [$a696] Message
    .byte ISCRIPT_ACTION_END                ; [$a697] IScriptAction


;============================================================================
; "I've got the Battle Helmet."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff7]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff7]
;
ISCRIPT_GOT_BATTLE_HELMET:                  ; [$a698]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a698] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a699] IScriptAction
    .byte MESSAGEID_GOT_BATTLE_HELMET       ; [$a69a] Message
    .byte ISCRIPT_ACTION_END                ; [$a69b] IScriptAction


;============================================================================
; "I've got the Dragon Slayer."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff8]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff8]
;
ISCRIPT_GOT_DRAGON_SLAYER:                  ; [$a69c]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a69c] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a69d] IScriptAction
    .byte MESSAGEID_GOT_DRAGON_SLAYER       ; [$a69e] Message
    .byte ISCRIPT_ACTION_END                ; [$a69f] IScriptAction


;============================================================================
; "I've got the Black Onyx."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff9]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ff9]
;
ISCRIPT_GOT_BLACK_ONYX:                     ; [$a6a0]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6a0] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6a1] IScriptAction
    .byte MESSAGEID_GOT_BLACK_ONYX          ; [$a6a2] Message
    .byte ISCRIPT_ACTION_END                ; [$a6a3] IScriptAction


;============================================================================
; "I've got the Pendant."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffa]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffa]
;
ISCRIPT_GOT_PENDANT:                        ; [$a6a4]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6a4] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6a5] IScriptAction
    .byte MESSAGEID_GOT_PENDANT             ; [$a6a6] Message
    .byte ISCRIPT_ACTION_END                ; [$a6a7] IScriptAction


;============================================================================
; "I've got the Magical Rod."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffb]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffb]
;
ISCRIPT_GOT_MAGICAL_ROD:                    ; [$a6a8]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6a8] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6a9] IScriptAction
    .byte MESSAGEID_GOT_MAGICAL_ROD         ; [$a6aa] Message
    .byte ISCRIPT_ACTION_END                ; [$a6ab] IScriptAction


;============================================================================
; "I've touched Poison."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffc]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffc]
;
ISCRIPT_TOUCHED_POISON:                     ; [$a6ac]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6ac] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6ad] IScriptAction
    .byte MESSAGEID_TOUCHED_POISON          ; [$a6ae] Message
    .byte ISCRIPT_ACTION_END                ; [$a6af] IScriptAction


;============================================================================
; "The glove increases offensive power."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffd]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffd]
;
ISCRIPT_GOT_POWER_GLOVE:                    ; [$a6b0]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6b0] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6b1] IScriptAction
    .byte MESSAGEID_GLOVE_INCREASES_POWER   ; [$a6b2] Message
    .byte ISCRIPT_ACTION_END                ; [$a6b3] IScriptAction


;============================================================================
; "The power of the Glove is gone."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffe]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9ffe]
;
ISCRIPT_POWER_GLOVE_GONE:                   ; [$a6b4]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6b4] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6b5] IScriptAction
    .byte MESSAGEID_POWER_GLOVE_IS_GONE     ; [$a6b6] Message
    .byte ISCRIPT_ACTION_END                ; [$a6b7] IScriptAction


;============================================================================
; "I am free from injury because of the Ointment."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fff]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::9fff]
;
ISCRIPT_OINTMENT_USED:                      ; [$a6b8]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6b8] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6b9] IScriptAction
    .byte MESSAGEID_USED_OINTMENT           ; [$a6ba] Message
    .byte ISCRIPT_ACTION_END                ; [$a6bb] IScriptAction


;============================================================================
; "The power of the Ointment is gone."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a000]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a000]
;
ISCRIPT_OINTMENT_GONE:                      ; [$a6bc]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6bc] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6bd] IScriptAction
    .byte MESSAGEID_OINTMENT_GONE           ; [$a6be] Message
    .byte ISCRIPT_ACTION_END                ; [$a6bf] IScriptAction


;============================================================================
; "The power of the Wing Boots is gone."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a001]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a001]
;
ISCRIPT_WINGBOOTS_GONE:                     ; [$a6c0]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6c0] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6c1] IScriptAction
    .byte MESSAGEID_WINGBOOTS_GONE          ; [$a6c2] Message
    .byte ISCRIPT_ACTION_END                ; [$a6c3] IScriptAction


;============================================================================
; "The power of the Hour Glass is gone."
;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a002]
;============================================================================

;
; XREFS:
;     ISCRIPT_ADDRS_L [$PRG12::a002]
;
ISCRIPT_HOURGLASS_GONE:                     ; [$a6c4]
    .byte ISCRIPT_ENTITY_GENERIC            ; [$a6c4] IScriptEntity
    .byte ISCRIPT_ACTION_SHOW_UNSKIPPABLE_MESSAGE ; [$a6c5] IScriptAction
    .byte MESSAGEID_HOURGLASS_GONE          ; [$a6c6] Message
    .byte ISCRIPT_ACTION_END                ; [$a6c7] IScriptAction

;
; XREFS:
;     SPLASHANIM_PALETTE_L [$PRG12::a72c]
;
SPLASHANIM_INTRO_PALETTE:                   ; [$a6c8]
    .byte $0f                               ; [0]:
    .byte $07                               ; [1]:
    .byte $17                               ; [2]:
    .byte $27                               ; [3]:
    .byte $0f                               ; [4]:
    .byte $27                               ; [5]:
    .byte $17                               ; [6]:
    .byte $27                               ; [7]:
    .byte $0f                               ; [8]:
    .byte $0c                               ; [9]:
    .byte $17                               ; [10]:
    .byte $10                               ; [11]:
    .byte $0f                               ; [12]:
    .byte $0c                               ; [13]:
    .byte $17                               ; [14]:
    .byte $27                               ; [15]:
    .byte $0f                               ; [16]:
    .byte $17                               ; [17]:
    .byte $26                               ; [18]:
    .byte $30                               ; [19]:
    .byte $0f                               ; [20]:
    .byte $17                               ; [21]:
    .byte $26                               ; [22]:
    .byte $30                               ; [23]:
    .byte $0f                               ; [24]:
    .byte $17                               ; [25]:
    .byte $26                               ; [26]:
    .byte $30                               ; [27]:
    .byte $0f                               ; [28]:
    .byte $17                               ; [29]:
    .byte $26                               ; [30]:
    .byte $30                               ; [31]:

;
; XREFS:
;     SPLASHANIM_PALETTE_L [$PRG12::a72d]
;
SPLASHANIM_OUTRO_PALETTE:                   ; [$a6e8]
    .byte $0f                               ; [0]:
    .byte $17                               ; [1]:
    .byte $27                               ; [2]:
    .byte $37                               ; [3]:
    .byte $0f                               ; [4]:
    .byte $37                               ; [5]:
    .byte $19                               ; [6]:
    .byte $29                               ; [7]:
    .byte $0f                               ; [8]:
    .byte $1c                               ; [9]:
    .byte $19                               ; [10]:
    .byte $30                               ; [11]:
    .byte $0f                               ; [12]:
    .byte $1c                               ; [13]:
    .byte $27                               ; [14]:
    .byte $37                               ; [15]:
    .byte $0f                               ; [16]:
    .byte $17                               ; [17]:
    .byte $26                               ; [18]:
    .byte $30                               ; [19]:
    .byte $0f                               ; [20]:
    .byte $1c                               ; [21]:
    .byte $2c                               ; [22]:
    .byte $30                               ; [23]:
    .byte $0f                               ; [24]:
    .byte $17                               ; [25]:
    .byte $26                               ; [26]:
    .byte $30                               ; [27]:
    .byte $0f                               ; [28]:
    .byte $17                               ; [29]:
    .byte $26                               ; [30]:
    .byte $30                               ; [31]:

;============================================================================
; TODO: Document SplashAnimation_Intro_SomethingA708
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;============================================================================
SplashAnimation_Intro_SomethingA708:        ; [$a708]
    INC a:SplashAnimation_PaletteStage
    LDA a:SplashAnimation_PaletteStage
    AND #$07
    BNE @LAB_PRG12__a727
    LDY #$1f

  @LAB_PRG12__a714:                         ; [$a714]
    LDA Screen_PaletteData_Tiles,Y
    SEC
    SBC #$10
    BPL @LAB_PRG12__a71e
    LDA #$0f

  @LAB_PRG12__a71e:                         ; [$a71e]
    STA Screen_PaletteData_Tiles,Y
    DEY
    BPL @LAB_PRG12__a714
    JMP PPUBuffer_WritePalette

  @LAB_PRG12__a727:                         ; [$a727]
    RTS

;
; XREFS:
;     SplashAnimation_DrawScenery
;
SPLASHANIM_CHR_L:                           ; [$a728]
    .byte $a0                               ; [0]: Intro
    .byte $a0                               ; [1]: Outro

;
; XREFS:
;     SplashAnimation_DrawScenery
;
SPLASHANIM_CHR_U:                           ; [$a72a]
    .byte $ac                               ; [0]: Intro
    .byte $b0                               ; [1]: Outro

;
; XREFS:
;     SplashAnimation_DrawScenery
;
SPLASHANIM_PALETTE_L:                       ; [$a72c]
    .byte $c8                               ; [0]: Intro
    .byte $e8                               ; [1]: Outro

;
; XREFS:
;     SplashAnimation_DrawScenery
;
SPLASHANIM_PALETTE_U:                       ; [$a72e]
    .byte $a6                               ; [0]: Intro
    .byte $a6                               ; [1]: Outro

;============================================================================
; TODO: Document SplashAnimation_DrawScenery
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_DrawScenery:                ; [$a730]
    STA a:SplashAnimation_SceneIndex
    JSR PPU_WaitUntilFlushed
    LDA #$a0
    STA IScriptOrCHRAddr
    LDA #$9b
    STA IScriptOrCHRAddr_U
    LDA #$00
    STA PPU_TargetAddr
    LDA #$00
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$90
    JSR PPU_WriteTilesFromCHRRAM
    LDA #$a0
    STA IScriptOrCHRAddr
    LDA #$a4
    STA IScriptOrCHRAddr_U
    LDA #$00
    STA PPU_TargetAddr
    LDA #$18
    STA PPU_TargetAddr_U
    LDX #$0a
    LDY #$80
    JSR PPU_WriteTilesFromCHRRAM
    LDX a:SplashAnimation_SceneIndex
    LDA SPLASHANIM_CHR_L,X
    STA IScriptOrCHRAddr
    LDA SPLASHANIM_CHR_U,X
    STA IScriptOrCHRAddr_U
    LDA #$20
    STA PPU_TargetAddr_U
    LDA #$00
    STA PPU_TargetAddr
    LDX #$0a
    LDY #$40
    JSR PPU_WriteTilesFromCHRRAM
    LDX a:SplashAnimation_SceneIndex
    LDA SPLASHANIM_PALETTE_L,X
    STA Temp_Int24
    LDA SPLASHANIM_PALETTE_U,X
    STA Temp_Int24_M
    LDY #$1f

  @_paletteLoop:                            ; [$a78f]
    LDA (Temp_Int24),Y
    STA Screen_PaletteData_Tiles,Y
    DEY
    BPL @_paletteLoop
    JMP PPUBuffer_WritePalette

;============================================================================
; TODO: Document SplashAnimation_RunIntro
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     Game_ShowStartScreen
;============================================================================
SplashAnimation_RunIntro:                   ; [$a79a]
    LDA #$00
    JSR SplashAnimation_DrawScenery
    JSR Maybe_SplashAnimation_InitIntroState
    LDA #$00
    STA a:SplashAnimation_PaletteStage
    LDA #$00
    STA Music_Current
    JSR Screen_ResetForNonGame

  @LAB_PRG12__a7ae:                         ; [$a7ae]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR SplashAnimation_SomethingUpdateState
    JSR SplashAnimation_Maybe_CalcPlayerAnimState
    JSR SplashAnimation_Maybe_AnimPlayerStep
    LDX a:IntroAnimation_PlayerSizeCounter
    CPX #$04
    BNE @LAB_PRG12__a7ae
    JSR SplashAnimation_Intro_SomethingA708
    LDA a:SplashAnimation_PaletteStage
    CMP #$20
    BNE @LAB_PRG12__a7ae
    RTS

;============================================================================
; TODO: Document SplashAnimation_Maybe_CalcPlayerAnimState
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;============================================================================
SplashAnimation_Maybe_CalcPlayerAnimState:  ; [$a7cf]
    LDY #$07
    JSR SplashAnimation_Maybe_NextAnimState1
    LDY #$07
    JSR SplashAnimation_Maybe_NextAnimState2
    LDX a:IntroAnimation_PlayerSizeCounter
    CMP BYTE_ARRAY_PRG12__a859,X
    BCS RETURN_A7F0
    INC a:IntroAnimation_PlayerSizeCounter
    LDA BYTE_ARRAY_PRG12__a85e,X
    STA a:SplashAnimation_0692
    LDA BYTE_ARRAY_PRG12__a862,X
    STA a:SplashAnimation_0693

    ;
    ; XREFS:
    ;     SplashAnimation_Maybe_CalcPlayerAnimSize
    ;     SplashAnimation_Maybe_CalcPlayerAnimState
    ;
RETURN_A7F0:                                ; [$a7f0]
    RTS

;============================================================================
; TODO: Document SplashAnimation_Maybe_CalcPlayerAnimSize
;
; INPUTS:
;     A
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_Maybe_CalcPlayerAnimSize:   ; [$a7f1]
    LDY #$07
    JSR SplashAnimation_Maybe_NextAnimState1
    LDY #$07
    JSR SplashAnimation_Maybe_NextAnimState2
    LDX a:IntroAnimation_PlayerSizeCounter
    CMP BYTE_ARRAY_PRG12__a866,X
    BCC RETURN_A7F0
    INC a:IntroAnimation_PlayerSizeCounter
    LDA BYTE_ARRAY_PRG12__a86a,X
    STA a:SplashAnimation_0692
    LDA BYTE_ARRAY_PRG12__a86e,X
    STA a:SplashAnimation_0693
    RTS

;============================================================================
; TODO: Document Maybe_SplashAnimation_InitIntroState
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;============================================================================
Maybe_SplashAnimation_InitIntroState:       ; [$a813]
    LDA #$18
    STA a:SplashAnimation_068e
    LDA #$ff
    STA a:SplashAnimation_068f
    LDA #$00
    STA a:SplashAnimation_068c
    STA a:IntroAnimation_PlayerSizeCounter
    STA a:SplashAnimation_0690
    STA a:SplashAnimation_0691
    LDA #$20
    STA a:SplashAnimation_0692
    LDA #$e0
    STA a:SplashAnimation_0693
    RTS

;============================================================================
; TODO: Document Maybe_SplashAnimation_InitOutroState
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
Maybe_SplashAnimation_InitOutroState:       ; [$a836]
    LDA #$70
    STA a:SplashAnimation_068e
    LDA #$ae
    STA a:SplashAnimation_068f
    LDA #$00
    STA a:SplashAnimation_068c
    STA a:IntroAnimation_PlayerSizeCounter
    STA a:SplashAnimation_0690
    STA a:SplashAnimation_0691
    LDA #$fd
    STA a:SplashAnimation_0692
    LDA #$01
    STA a:SplashAnimation_0693
    RTS

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimState
;
BYTE_ARRAY_PRG12__a859:                     ; [$a859]
    .byte $cc                               ; [0]:
    .byte $bc                               ; [1]:
    .byte $b4                               ; [2]:
    .byte $b0                               ; [3]:
    .byte $00                               ; [4]:

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimState
;
BYTE_ARRAY_PRG12__a85e:                     ; [$a85e]
    .byte $11                               ; [0]:
    .byte $0a                               ; [1]:
    .byte $05                               ; [2]:
    .byte $03                               ; [3]:

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimState
;
BYTE_ARRAY_PRG12__a862:                     ; [$a862]
    .byte $f0                               ; [0]:
    .byte $f8                               ; [1]:
    .byte $fd                               ; [2]:
    .byte $ff                               ; [3]:

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimSize
;
BYTE_ARRAY_PRG12__a866:                     ; [$a866]
    .byte $b0                               ; [0]:
    .byte $b4                               ; [1]:
    .byte $bc                               ; [2]:
    .byte $cc                               ; [3]:

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimSize
;
BYTE_ARRAY_PRG12__a86a:                     ; [$a86a]
    .byte $fb                               ; [0]:
    .byte $f6                               ; [1]:
    .byte $ef                               ; [2]:
    .byte $e0                               ; [3]:

;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimSize
;
BYTE_ARRAY_PRG12__a86e:                     ; [$a86e]
    .byte $03                               ; [0]:
    .byte $08                               ; [1]:
    .byte $10                               ; [2]:
    .byte $20                               ; [3]:

;============================================================================
; TODO: Document SplashAnimation_Maybe_NextAnimState1
;
; INPUTS:
;     Y
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimSize
;     SplashAnimation_Maybe_CalcPlayerAnimState
;============================================================================
SplashAnimation_Maybe_NextAnimState1:       ; [$a872]
    LDA #$00
    STA Temp_Int24
    LDA a:SplashAnimation_0692

  @LAB_PRG12__a879:                         ; [$a879]
    STA Temp_Int24_M
    ROL Temp_Int24_M
    ROR A
    ROR Temp_Int24
    DEY
    BNE @LAB_PRG12__a879
    CLC
    STA Temp_Int24_M
    LDA Temp_Int24
    CLC
    ADC a:SplashAnimation_0690
    STA a:SplashAnimation_0690
    LDA Temp_Int24_M
    ADC a:SplashAnimation_068e
    STA a:SplashAnimation_068e
    RTS

;============================================================================
; TODO: Document SplashAnimation_Maybe_NextAnimState2
;
; INPUTS:
;     Y
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_Maybe_CalcPlayerAnimSize
;     SplashAnimation_Maybe_CalcPlayerAnimState
;============================================================================
SplashAnimation_Maybe_NextAnimState2:       ; [$a898]
    LDA #$00
    STA Temp_Int24
    LDA a:SplashAnimation_0693

  @LAB_PRG12__a89f:                         ; [$a89f]
    STA Temp_Int24_M
    ROL Temp_Int24_M
    ROR A
    ROR Temp_Int24
    DEY
    BNE @LAB_PRG12__a89f
    CLC
    STA Temp_Int24_M
    LDA Temp_Int24
    CLC
    ADC a:SplashAnimation_0691
    STA a:SplashAnimation_0691
    LDA Temp_Int24_M
    ADC a:SplashAnimation_068f
    STA a:SplashAnimation_068f
    RTS

;============================================================================
; TODO: Document SplashAnimation_Maybe_AnimPlayerStep
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;============================================================================
SplashAnimation_Maybe_AnimPlayerStep:       ; [$a8be]
    JSR SplashAnimation_A90F
    LDY a:IntroAnimation_PlayerSizeCounter
    CPY #$03
    BCS @LAB_PRG12__a8d8
    AND #$01
    BNE @LAB_PRG12__a8d8
    LDA a:SplashAnimation_068c
    AND #$0f
    BNE @LAB_PRG12__a8d8
    LDA #$15
    JSR Sound_PlayEffect

  @LAB_PRG12__a8d8:                         ; [$a8d8]
    LDA BYTE_ARRAY_PRG12__a8de,X
    JMP SplashAnimation_FuncAA94

;
; XREFS:
;     SplashAnimation_Maybe_AnimPlayerStep
;
BYTE_ARRAY_PRG12__a8de:                     ; [$a8de]
    .byte $00                               ; [0]:
    .byte $01                               ; [1]:
    .byte $02                               ; [2]:
    .byte $01                               ; [3]:
    .byte $03                               ; [4]:
    .byte $04                               ; [5]:
    .byte $05                               ; [6]:
    .byte $04                               ; [7]:
    .byte $06                               ; [8]:
    .byte $06                               ; [9]:
    .byte $07                               ; [10]:
    .byte $07                               ; [11]:
    .byte $08                               ; [12]:
    .byte $08                               ; [13]:
    .byte $09                               ; [14]:
    .byte $09                               ; [15]:
    .byte $0a                               ; [16]:
    .byte $0a                               ; [17]:
    .byte $0b                               ; [18]:
    .byte $0b                               ; [19]:

;============================================================================
; TODO: Document SplashAnimation_OutroFuncAF82
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_OutroFuncAF82:              ; [$a8f2]
    JSR SplashAnimation_A90F
    LDA BYTE_ARRAY_PRG12__a8fb,X
    JMP SplashAnimation_FuncAA94

;
; XREFS:
;     SplashAnimation_OutroFuncAF82
;
BYTE_ARRAY_PRG12__a8fb:                     ; [$a8fb]
    .byte $0c                               ; [0]:
    .byte $0c                               ; [1]:
    .byte $0d                               ; [2]:
    .byte $0d                               ; [3]:
    .byte $0e                               ; [4]:
    .byte $0e                               ; [5]:
    .byte $0f                               ; [6]:
    .byte $0f                               ; [7]:
    .byte $10                               ; [8]:
    .byte $10                               ; [9]:
    .byte $11                               ; [10]:
    .byte $11                               ; [11]:
    .byte $12                               ; [12]:
    .byte $13                               ; [13]:
    .byte $14                               ; [14]:
    .byte $13                               ; [15]:
    .byte $15                               ; [16]:
    .byte $16                               ; [17]:
    .byte $17                               ; [18]:
    .byte $16                               ; [19]:

;============================================================================
; TODO: Document SplashAnimation_A90F
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     A
;
; XREFS:
;     SplashAnimation_Maybe_AnimPlayerStep
;     SplashAnimation_OutroFuncAF82
;============================================================================
SplashAnimation_A90F:                       ; [$a90f]
    LDA a:SplashAnimation_068e
    STA a:SplashAnimation_0689
    LDA a:SplashAnimation_068f
    STA a:SplashAnimation_068a
    LDA a:SplashAnimation_068c
    INC a:SplashAnimation_068c
    LSR A
    LSR A
    LSR A
    LSR A
    AND #$03
    STA Temp_Int24
    LDA a:IntroAnimation_PlayerSizeCounter
    ASL A
    ASL A
    ORA Temp_Int24
    TAX
    RTS

;============================================================================
; TODO: Document SplashAnimation_RunOutro
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     IScriptAction_FinishGame
;============================================================================
SplashAnimation_RunOutro:                   ; [$a932]
    LDA #$01
    JSR SplashAnimation_DrawScenery
    JSR Maybe_SplashAnimation_InitOutroState
    JSR SplashAnimation_SomethingOutro_A99C
    LDA #$0c
    STA Music_Current
    JSR Screen_ResetForNonGame

  @LAB_PRG12__a944:                         ; [$a944]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR SplashAnimation_SomethingUpdateState
    JSR SplashAnimation_Maybe_CalcPlayerAnimSize
    JSR SplashAnimation_OutroFuncAF82
    JSR SplashAnimation_SomethingOutroA9C9
    JSR SplashAnimation_SomethingA9F2
    JSR SplashAnimation_UpdateOutro
    LDA a:SplashAnimation_068f
    CMP #$fa
    BCC @LAB_PRG12__a944

  @LAB_PRG12__a963:                         ; [$a963]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR SplashAnimation_SomethingUpdateState
    JSR SplashAnimation_SomethingOutroA9C9
    JSR SplashAnimation_SomethingA9F2
    JSR SplashAnimation_UpdateOutro
    LDA Music_Current
    BNE @LAB_PRG12__a963
    LDA #$10
    STA InterruptCounter

  @LAB_PRG12__a97d:                         ; [$a97d]
    JSR WaitForNextFrame
    JSR Screen_ResetSpritesForNonGame
    JSR SplashAnimation_SomethingUpdateState
    JSR SplashAnimation_SomethingOutroA9C9
    JSR SplashAnimation_SomethingA9F2
    JSR SplashAnimation_UpdateOutro
    LDA InterruptCounter
    BNE @LAB_PRG12__a97d
    RTS

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a994:                     ; [$a994]
    .byte $d8                               ; [0]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a994_1_:                  ; [$a995]
    .byte $e0                               ; [1]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a996:                     ; [$a996]
    .byte $c2                               ; [0]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a996_1_:                  ; [$a997]
    .byte $d0                               ; [1]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a998:                     ; [$a998]
    .byte $ff                               ; [0]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a998_1_:                  ; [$a999]
    .byte $ff                               ; [1]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a99a:                     ; [$a99a]
    .byte $00                               ; [0]:

;
; XREFS:
;     SpashAnimation_SomethingOutro_a9a2
;
BYTE_ARRAY_PRG12__a99a_1_:                  ; [$a99b]
    .byte $01                               ; [1]:

;============================================================================
; TODO: Document SplashAnimation_SomethingOutro_A99C
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_SomethingOutro_A99C:        ; [$a99c]
    LDX #$00
    JSR SpashAnimation_SomethingOutro_a9a2
    INX

    ;
    ; v-- Fall through --v
    ;

;============================================================================
; TODO: Document SpashAnimation_SomethingOutro_a9a2
;
; INPUTS:
;     X
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_SomethingOutro_A99C
;============================================================================
SpashAnimation_SomethingOutro_a9a2:         ; [$a9a2]
    LDA #$00
    STA SplashAnimation_0694,X
    STA SplashAnimation_0696,X
    STA SplashAnimation_069c,X
    STA SplashAnimation_069e,X
    LDA BYTE_ARRAY_PRG12__a994,X
    STA SplashAnimation_0698,X
    LDA BYTE_ARRAY_PRG12__a996,X
    STA SplashAnimation_069a,X
    LDA BYTE_ARRAY_PRG12__a998,X
    STA SplashAnimation_06a0,X
    LDA BYTE_ARRAY_PRG12__a99a,X
    STA SplashAnimation_06a2,X
    RTS

;============================================================================
; TODO: Document SplashAnimation_SomethingOutroA9C9
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_SomethingOutroA9C9:         ; [$a9c9]
    LDX #$00
    JSR @LAB_PRG12__a9cf
    INX

  @LAB_PRG12__a9cf:                         ; [$a9cf]
    LDY #$01
    JSR SpashAnimation_SomethingOutro_aa20
    LDY #$01
    JSR SpashAnimation_SomethingOutro_aa46
    LDY SplashAnimation_0696,X
    INY
    CPY #$08
    BNE @LAB_PRG12__a9ed
    INC SplashAnimation_0694,X
    LDA SplashAnimation_0694,X
    CMP #$0a
    BEQ SpashAnimation_SomethingOutro_a9a2
    LDY #$00

  @LAB_PRG12__a9ed:                         ; [$a9ed]
    TYA
    STA SplashAnimation_0696,X

RETURN_A9F1:                                ; [$a9f1]
    RTS

;============================================================================
; TODO: Document SplashAnimation_SomethingA9F2
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_SomethingA9F2:              ; [$a9f2]
    LDX #$00
    JSR @LAB_PRG12__a9f8
    INX

  @LAB_PRG12__a9f8:                         ; [$a9f8]
    LDA SplashAnimation_0694,X
    CMP #$03
    BCS RETURN_A9F1
    LDA SplashAnimation_0698,X
    STA a:SplashAnimation_0689
    LDA SplashAnimation_069a,X
    STA a:SplashAnimation_068a
    TXA
    ASL A
    ASL A
    ORA SplashAnimation_0694,X
    TAY
    LDA BYTE_ARRAY_PRG12__aa18,Y
    JMP SplashAnimation_FuncAA94

BYTE_ARRAY_PRG12__aa18:                     ; [$aa18]
    .byte $1a                               ; [0]:
    .byte $1b                               ; [1]:
    .byte $1c                               ; [2]:
    .byte $00                               ; [3]:
    .byte $1d                               ; [4]:
    .byte $1e                               ; [5]:
    .byte $1f                               ; [6]:
    .byte $00                               ; [7]:

;============================================================================
; TODO: Document SpashAnimation_SomethingOutro_aa20
;
; INPUTS:
;     X
;     Y
;
; OUTPUTS:
;     TODO
;============================================================================
SpashAnimation_SomethingOutro_aa20:         ; [$aa20]
    LDA #$00
    STA Temp_Int24
    LDA SplashAnimation_06a0,X

  @LAB_PRG12__aa27:                         ; [$aa27]
    STA Temp_Int24_M
    ROL Temp_Int24_M
    ROR A
    ROR Temp_Int24
    DEY
    BNE @LAB_PRG12__aa27
    CLC
    STA Temp_Int24_M
    LDA Temp_Int24
    CLC
    ADC SplashAnimation_069c,X
    STA SplashAnimation_069c,X
    LDA Temp_Int24_M
    ADC SplashAnimation_0698,X
    STA SplashAnimation_0698,X
    RTS

;============================================================================
; TODO: Document SpashAnimation_SomethingOutro_aa46
;
; INPUTS:
;     X
;     Y
;
; OUTPUTS:
;     TODO
;============================================================================
SpashAnimation_SomethingOutro_aa46:         ; [$aa46]
    LDA #$00
    STA Temp_Int24
    LDA SplashAnimation_06a2,X

  @LAB_PRG12__aa4d:                         ; [$aa4d]
    STA Temp_Int24_M
    ROL Temp_Int24_M
    ROR A
    ROR Temp_Int24
    DEY
    BNE @LAB_PRG12__aa4d
    CLC
    STA Temp_Int24_M
    LDA Temp_Int24
    CLC
    ADC SplashAnimation_069e,X
    STA SplashAnimation_069e,X
    LDA Temp_Int24_M
    ADC SplashAnimation_069a,X
    STA SplashAnimation_069a,X
    RTS

;============================================================================
; TODO: Document SplashAnimation_UpdateOutro
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_UpdateOutro:                ; [$aa6c]
    LDA #$e0
    STA a:SplashAnimation_0689
    LDA #$78
    STA a:SplashAnimation_068a
    LDA InterruptCounter
    AND #$10
    LSR A
    LSR A
    LSR A
    LSR A
    ADC #$18
    JMP SplashAnimation_FuncAA94

;============================================================================
; TODO: Document SplashAnimation_SomethingUpdateState
;
; INPUTS:
;     None.
;
; OUTPUTS:
;     TODO
;
; XREFS:
;     SplashAnimation_RunIntro
;     SplashAnimation_RunOutro
;============================================================================
SplashAnimation_SomethingUpdateState:       ; [$aa83]
    LDX #$00
    LDA #$f0

  @LAB_PRG12__aa87:                         ; [$aa87]
    STA SPRITE_0_RANGE_1_START,X
    INX
    INX
    INX
    INX
    BNE @LAB_PRG12__aa87
    STX a:SplashAnimation_0688
    RTS

;============================================================================
; TODO: Document SplashAnimation_FuncAA94
;
; INPUTS:
;     A
;     X
;
; OUTPUTS:
;     A
;
; XREFS:
;     SplashAnimation_Maybe_AnimPlayerStep
;     SplashAnimation_OutroFuncAF82
;     SplashAnimation_UpdateOutro
;============================================================================
SplashAnimation_FuncAA94:                   ; [$aa94]
    TAY
    LDA BYTE_ARRAY_PRG12__ab17,Y
    STA Temp_Int24
    LDA BYTE_ARRAY_PRG12__ab37,Y
    STA Temp_Int24_M
    LDY #$00
    LDA a:SplashAnimation_0689
    CLC
    ADC (Temp_Int24),Y
    STA a:SplashAnimation_0689
    INY
    LDA a:SplashAnimation_068a
    CLC
    ADC (Temp_Int24),Y
    CMP #$f0
    BCS @_return
    STA a:SplashAnimation_068a
    INY
    LDA (Temp_Int24),Y
    STA a:DAT_068b
    INY
    LDA (Temp_Int24),Y
    STA TextBox_ContentsY
    INY
    TXA
    PHA
    LDX a:SplashAnimation_0688

  @LAB_PRG12__aac9:                         ; [$aac9]
    LDA a:DAT_068b
    STA Temp_Int24_U
    LDA a:SplashAnimation_0689
    STA TextBox_ContentsX

  @LAB_PRG12__aad3:                         ; [$aad3]
    LDA (Temp_Int24),Y
    INY
    CMP #$ff
    BEQ @LAB_PRG12__aaf9
    STA SPRITE0_TILE,X
    LDA a:SplashAnimation_068a
    CMP #$f0
    BCS @LAB_PRG12__ab11
    LDA a:SplashAnimation_068a
    STA SPRITE_0_RANGE_1_START,X
    LDA (Temp_Int24),Y
    INY
    STA SPRITE0_ATTRS,X
    LDA TextBox_ContentsX
    STA SPRITE0_X,X
    INX
    INX
    INX
    INX

  @LAB_PRG12__aaf9:                         ; [$aaf9]
    LDA TextBox_ContentsX
    CLC
    ADC #$08
    STA TextBox_ContentsX
    DEC Temp_Int24_U
    BNE @LAB_PRG12__aad3
    LDA a:SplashAnimation_068a
    CLC
    ADC #$08
    STA a:SplashAnimation_068a
    DEC TextBox_ContentsY
    BNE @LAB_PRG12__aac9

  @LAB_PRG12__ab11:                         ; [$ab11]
    STX a:SplashAnimation_0688
    PLA
    TAX

  @_return:                                 ; [$ab16]
    RTS

;
; XREFS:
;     SplashAnimation_FuncAA94
;
BYTE_ARRAY_PRG12__ab17:                     ; [$ab17]
    .byte $57                               ; [0]:
    .byte $6f                               ; [1]:
    .byte $87                               ; [2]:
    .byte $9f                               ; [3]:
    .byte $b3                               ; [4]:
    .byte $c7                               ; [5]:
    .byte $db                               ; [6]:
    .byte $eb                               ; [7]:
    .byte $fb                               ; [8]:
    .byte $05                               ; [9]:
    .byte $0f                               ; [10]:
    .byte $17                               ; [11]:
    .byte $1f                               ; [12]:
    .byte $27                               ; [13]:
    .byte $2f                               ; [14]:
    .byte $39                               ; [15]:
    .byte $43                               ; [16]:
    .byte $53                               ; [17]:
    .byte $63                               ; [18]:
    .byte $77                               ; [19]:
    .byte $8b                               ; [20]:
    .byte $9f                               ; [21]:
    .byte $b7                               ; [22]:
    .byte $cf                               ; [23]:
    .byte $e7                               ; [24]:
    .byte $26                               ; [25]:
    .byte $65                               ; [26]:
    .byte $6b                               ; [27]:
    .byte $71                               ; [28]:
    .byte $77                               ; [29]:
    .byte $7d                               ; [30]:
    .byte $83                               ; [31]:

;
; XREFS:
;     SplashAnimation_FuncAA94
;
BYTE_ARRAY_PRG12__ab37:                     ; [$ab37]
    .byte $ab                               ; [0]:
    .byte $ab                               ; [1]:
    .byte $ab                               ; [2]:
    .byte $ab                               ; [3]:
    .byte $ab                               ; [4]:
    .byte $ab                               ; [5]:
    .byte $ab                               ; [6]:
    .byte $ab                               ; [7]:
    .byte $ab                               ; [8]:
    .byte $ac                               ; [9]:
    .byte $ac                               ; [10]:
    .byte $ac                               ; [11]:
    .byte $ac                               ; [12]:
    .byte $ac                               ; [13]:
    .byte $ac                               ; [14]:
    .byte $ac                               ; [15]:
    .byte $ac                               ; [16]:
    .byte $ac                               ; [17]:
    .byte $ac                               ; [18]:
    .byte $ac                               ; [19]:
    .byte $ac                               ; [20]:
    .byte $ac                               ; [21]:
    .byte $ac                               ; [22]:
    .byte $ac                               ; [23]:
    .byte $ac                               ; [24]:
    .byte $ad                               ; [25]:
    .byte $ad                               ; [26]:
    .byte $ad                               ; [27]:
    .byte $ad                               ; [28]:
    .byte $ad                               ; [29]:
    .byte $ad                               ; [30]:
    .byte $ad                               ; [31]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $46                               ; [4]:
    .byte $00                               ; [5]:
    .byte $47                               ; [6]:
    .byte $00                               ; [7]:
    .byte $48                               ; [8]:
    .byte $00                               ; [9]:
    .byte $49                               ; [10]:
    .byte $00                               ; [11]:
    .byte $4a                               ; [12]:
    .byte $00                               ; [13]:
    .byte $4b                               ; [14]:
    .byte $00                               ; [15]:
    .byte $4c                               ; [16]:
    .byte $00                               ; [17]:
    .byte $4d                               ; [18]:
    .byte $00                               ; [19]:
    .byte $4e                               ; [20]:
    .byte $00                               ; [21]:
    .byte $4f                               ; [22]:
    .byte $00                               ; [23]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $50                               ; [4]:
    .byte $00                               ; [5]:
    .byte $51                               ; [6]:
    .byte $00                               ; [7]:
    .byte $52                               ; [8]:
    .byte $00                               ; [9]:
    .byte $53                               ; [10]:
    .byte $00                               ; [11]:
    .byte $54                               ; [12]:
    .byte $00                               ; [13]:
    .byte $55                               ; [14]:
    .byte $00                               ; [15]:
    .byte $56                               ; [16]:
    .byte $00                               ; [17]:
    .byte $57                               ; [18]:
    .byte $00                               ; [19]:
    .byte $58                               ; [20]:
    .byte $00                               ; [21]:
    .byte $59                               ; [22]:
    .byte $00                               ; [23]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $46                               ; [4]:
    .byte $00                               ; [5]:
    .byte $47                               ; [6]:
    .byte $00                               ; [7]:
    .byte $5a                               ; [8]:
    .byte $00                               ; [9]:
    .byte $5b                               ; [10]:
    .byte $00                               ; [11]:
    .byte $5c                               ; [12]:
    .byte $00                               ; [13]:
    .byte $5d                               ; [14]:
    .byte $00                               ; [15]:
    .byte $5e                               ; [16]:
    .byte $00                               ; [17]:
    .byte $5f                               ; [18]:
    .byte $00                               ; [19]:
    .byte $60                               ; [20]:
    .byte $00                               ; [21]:
    .byte $61                               ; [22]:
    .byte $00                               ; [23]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $62                               ; [4]:
    .byte $00                               ; [5]:
    .byte $63                               ; [6]:
    .byte $00                               ; [7]:
    .byte $64                               ; [8]:
    .byte $00                               ; [9]:
    .byte $65                               ; [10]:
    .byte $00                               ; [11]:
    .byte $66                               ; [12]:
    .byte $00                               ; [13]:
    .byte $67                               ; [14]:
    .byte $00                               ; [15]:
    .byte $68                               ; [16]:
    .byte $00                               ; [17]:
    .byte $69                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $62                               ; [4]:
    .byte $00                               ; [5]:
    .byte $63                               ; [6]:
    .byte $00                               ; [7]:
    .byte $70                               ; [8]:
    .byte $00                               ; [9]:
    .byte $71                               ; [10]:
    .byte $00                               ; [11]:
    .byte $72                               ; [12]:
    .byte $00                               ; [13]:
    .byte $73                               ; [14]:
    .byte $00                               ; [15]:
    .byte $74                               ; [16]:
    .byte $00                               ; [17]:
    .byte $75                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $62                               ; [4]:
    .byte $00                               ; [5]:
    .byte $63                               ; [6]:
    .byte $00                               ; [7]:
    .byte $6a                               ; [8]:
    .byte $00                               ; [9]:
    .byte $6b                               ; [10]:
    .byte $00                               ; [11]:
    .byte $6c                               ; [12]:
    .byte $00                               ; [13]:
    .byte $6d                               ; [14]:
    .byte $00                               ; [15]:
    .byte $6e                               ; [16]:
    .byte $00                               ; [17]:
    .byte $6f                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $02                               ; [2]:
    .byte $03                               ; [3]:
    .byte $76                               ; [4]:
    .byte $00                               ; [5]:
    .byte $77                               ; [6]:
    .byte $00                               ; [7]:
    .byte $78                               ; [8]:
    .byte $00                               ; [9]:
    .byte $79                               ; [10]:
    .byte $00                               ; [11]:
    .byte $34                               ; [12]:
    .byte $00                               ; [13]:
    .byte $7b                               ; [14]:
    .byte $00                               ; [15]:
    .byte $f8                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $02                               ; [2]:
    .byte $03                               ; [3]:
    .byte $76                               ; [4]:
    .byte $00                               ; [5]:
    .byte $77                               ; [6]:
    .byte $00                               ; [7]:
    .byte $7c                               ; [8]:
    .byte $00                               ; [9]:
    .byte $7d                               ; [10]:
    .byte $00                               ; [11]:
    .byte $3a                               ; [12]:
    .byte $00                               ; [13]:
    .byte $7f                               ; [14]:
    .byte $00                               ; [15]:
    .byte $fc                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $01                               ; [2]:
    .byte $03                               ; [3]:
    .byte $36                               ; [4]:
    .byte $00                               ; [5]:
    .byte $3d                               ; [6]:
    .byte $00                               ; [7]:
    .byte $3e                               ; [8]:
    .byte $00                               ; [9]:
    .byte $fc                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $01                               ; [2]:
    .byte $03                               ; [3]:
    .byte $37                               ; [4]:
    .byte $00                               ; [5]:
    .byte $40                               ; [6]:
    .byte $00                               ; [7]:
    .byte $41                               ; [8]:
    .byte $00                               ; [9]:
    .byte $fc                               ; [0]:
    .byte $f8                               ; [1]:
    .byte $01                               ; [2]:
    .byte $02                               ; [3]:
    .byte $7a                               ; [4]:
    .byte $00                               ; [5]:
    .byte $43                               ; [6]:
    .byte $00                               ; [7]:
    .byte $fc                               ; [0]:
    .byte $f8                               ; [1]:
    .byte $01                               ; [2]:
    .byte $02                               ; [3]:
    .byte $7e                               ; [4]:
    .byte $00                               ; [5]:
    .byte $45                               ; [6]:
    .byte $00                               ; [7]:
    .byte $fc                               ; [0]:
    .byte $f8                               ; [1]:
    .byte $01                               ; [2]:
    .byte $02                               ; [3]:
    .byte $42                               ; [4]:
    .byte $00                               ; [5]:
    .byte $43                               ; [6]:
    .byte $00                               ; [7]:
    .byte $fc                               ; [0]:
    .byte $f8                               ; [1]:
    .byte $01                               ; [2]:
    .byte $02                               ; [3]:
    .byte $44                               ; [4]:
    .byte $00                               ; [5]:
    .byte $45                               ; [6]:
    .byte $00                               ; [7]:
    .byte $fc                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $01                               ; [2]:
    .byte $03                               ; [3]:
    .byte $3c                               ; [4]:
    .byte $00                               ; [5]:
    .byte $3d                               ; [6]:
    .byte $00                               ; [7]:
    .byte $3e                               ; [8]:
    .byte $00                               ; [9]:
    .byte $fc                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $01                               ; [2]:
    .byte $03                               ; [3]:
    .byte $3f                               ; [4]:
    .byte $00                               ; [5]:
    .byte $40                               ; [6]:
    .byte $00                               ; [7]:
    .byte $41                               ; [8]:
    .byte $00                               ; [9]:
    .byte $f8                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $02                               ; [0]:
    .byte $03                               ; [1]:
    .byte $30                               ; [2]:
    .byte $00                               ; [3]:
    .byte $31                               ; [4]:
    .byte $00                               ; [5]:
    .byte $32                               ; [6]:
    .byte $00                               ; [7]:
    .byte $33                               ; [8]:
    .byte $00                               ; [9]:
    .byte $34                               ; [10]:
    .byte $00                               ; [11]:
    .byte $35                               ; [12]:
    .byte $00                               ; [13]:
    .byte $f8                               ; [0]:
    .byte $f4                               ; [1]:
    .byte $02                               ; [2]:
    .byte $03                               ; [3]:
    .byte $30                               ; [4]:
    .byte $00                               ; [5]:
    .byte $31                               ; [6]:
    .byte $00                               ; [7]:
    .byte $38                               ; [8]:
    .byte $00                               ; [9]:
    .byte $39                               ; [10]:
    .byte $00                               ; [11]:
    .byte $3a                               ; [12]:
    .byte $00                               ; [13]:
    .byte $3b                               ; [14]:
    .byte $00                               ; [15]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $1c                               ; [4]:
    .byte $00                               ; [5]:
    .byte $1d                               ; [6]:
    .byte $00                               ; [7]:
    .byte $1e                               ; [8]:
    .byte $00                               ; [9]:
    .byte $1f                               ; [10]:
    .byte $00                               ; [11]:
    .byte $20                               ; [12]:
    .byte $00                               ; [13]:
    .byte $21                               ; [14]:
    .byte $00                               ; [15]:
    .byte $22                               ; [16]:
    .byte $00                               ; [17]:
    .byte $23                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $1c                               ; [4]:
    .byte $00                               ; [5]:
    .byte $1d                               ; [6]:
    .byte $00                               ; [7]:
    .byte $2a                               ; [8]:
    .byte $00                               ; [9]:
    .byte $2b                               ; [10]:
    .byte $00                               ; [11]:
    .byte $2c                               ; [12]:
    .byte $00                               ; [13]:
    .byte $2d                               ; [14]:
    .byte $00                               ; [15]:
    .byte $2e                               ; [16]:
    .byte $00                               ; [17]:
    .byte $2f                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $f0                               ; [1]:
    .byte $02                               ; [2]:
    .byte $04                               ; [3]:
    .byte $1c                               ; [4]:
    .byte $00                               ; [5]:
    .byte $1d                               ; [6]:
    .byte $00                               ; [7]:
    .byte $24                               ; [8]:
    .byte $00                               ; [9]:
    .byte $25                               ; [10]:
    .byte $00                               ; [11]:
    .byte $26                               ; [12]:
    .byte $00                               ; [13]:
    .byte $27                               ; [14]:
    .byte $00                               ; [15]:
    .byte $28                               ; [16]:
    .byte $00                               ; [17]:
    .byte $29                               ; [18]:
    .byte $00                               ; [19]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $00                               ; [4]:
    .byte $00                               ; [5]:
    .byte $01                               ; [6]:
    .byte $00                               ; [7]:
    .byte $02                               ; [8]:
    .byte $00                               ; [9]:
    .byte $03                               ; [10]:
    .byte $00                               ; [11]:
    .byte $04                               ; [12]:
    .byte $00                               ; [13]:
    .byte $05                               ; [14]:
    .byte $00                               ; [15]:
    .byte $06                               ; [16]:
    .byte $00                               ; [17]:
    .byte $07                               ; [18]:
    .byte $00                               ; [19]:
    .byte $08                               ; [20]:
    .byte $00                               ; [21]:
    .byte $09                               ; [22]:
    .byte $00                               ; [23]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $0a                               ; [4]:
    .byte $00                               ; [5]:
    .byte $0b                               ; [6]:
    .byte $00                               ; [7]:
    .byte $0c                               ; [8]:
    .byte $00                               ; [9]:
    .byte $0d                               ; [10]:
    .byte $00                               ; [11]:
    .byte $0e                               ; [12]:
    .byte $00                               ; [13]:
    .byte $0f                               ; [14]:
    .byte $00                               ; [15]:
    .byte $10                               ; [16]:
    .byte $00                               ; [17]:
    .byte $11                               ; [18]:
    .byte $00                               ; [19]:
    .byte $12                               ; [20]:
    .byte $00                               ; [21]:
    .byte $13                               ; [22]:
    .byte $00                               ; [23]:
    .byte $f8                               ; [0]:
    .byte $ec                               ; [1]:
    .byte $02                               ; [2]:
    .byte $05                               ; [3]:
    .byte $00                               ; [4]:
    .byte $00                               ; [5]:
    .byte $01                               ; [6]:
    .byte $00                               ; [7]:
    .byte $14                               ; [8]:
    .byte $00                               ; [9]:
    .byte $15                               ; [10]:
    .byte $00                               ; [11]:
    .byte $16                               ; [12]:
    .byte $00                               ; [13]:
    .byte $17                               ; [14]:
    .byte $00                               ; [15]:
    .byte $18                               ; [16]:
    .byte $00                               ; [17]:
    .byte $19                               ; [18]:
    .byte $00                               ; [19]:
    .byte $1a                               ; [20]:
    .byte $00                               ; [21]:
    .byte $1b                               ; [22]:
    .byte $00                               ; [23]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $04                               ; [2]:
    .byte $0b                               ; [3]:
    .byte $ff                               ; [4]:
    .byte $80                               ; [5]:
    .byte $01                               ; [6]:
    .byte $83                               ; [7]:
    .byte $01                               ; [8]:
    .byte $83                               ; [9]:
    .byte $01                               ; [10]:
    .byte $ff                               ; [11]:
    .byte $81                               ; [12]:
    .byte $01                               ; [13]:
    .byte $8e                               ; [14]:
    .byte $01                               ; [15]:
    .byte $ff                               ; [16]:
    .byte $ff                               ; [17]:
    .byte $81                               ; [18]:
    .byte $01                               ; [19]:
    .byte $ff                               ; [20]:
    .byte $ff                               ; [21]:
    .byte $ff                               ; [22]:
    .byte $81                               ; [23]:
    .byte $01                               ; [24]:
    .byte $ff                               ; [25]:
    .byte $ff                               ; [26]:
    .byte $ff                               ; [27]:
    .byte $81                               ; [28]:
    .byte $01                               ; [29]:
    .byte $ff                               ; [30]:
    .byte $ff                               ; [31]:
    .byte $ff                               ; [32]:
    .byte $81                               ; [33]:
    .byte $01                               ; [34]:
    .byte $ff                               ; [35]:
    .byte $ff                               ; [36]:
    .byte $ff                               ; [37]:
    .byte $81                               ; [38]:
    .byte $01                               ; [39]:
    .byte $ff                               ; [40]:
    .byte $ff                               ; [41]:
    .byte $ff                               ; [42]:
    .byte $81                               ; [43]:
    .byte $01                               ; [44]:
    .byte $ff                               ; [45]:
    .byte $ff                               ; [46]:
    .byte $ff                               ; [47]:
    .byte $81                               ; [48]:
    .byte $01                               ; [49]:
    .byte $ff                               ; [50]:
    .byte $ff                               ; [51]:
    .byte $84                               ; [52]:
    .byte $01                               ; [53]:
    .byte $85                               ; [54]:
    .byte $01                               ; [55]:
    .byte $ff                               ; [56]:
    .byte $ff                               ; [57]:
    .byte $ff                               ; [58]:
    .byte $8f                               ; [59]:
    .byte $01                               ; [60]:
    .byte $ff                               ; [61]:
    .byte $ff                               ; [62]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $04                               ; [2]:
    .byte $0b                               ; [3]:
    .byte $ff                               ; [4]:
    .byte $82                               ; [5]:
    .byte $01                               ; [6]:
    .byte $83                               ; [7]:
    .byte $81                               ; [8]:
    .byte $83                               ; [9]:
    .byte $81                               ; [10]:
    .byte $ff                               ; [11]:
    .byte $81                               ; [12]:
    .byte $41                               ; [13]:
    .byte $8e                               ; [14]:
    .byte $01                               ; [15]:
    .byte $ff                               ; [16]:
    .byte $ff                               ; [17]:
    .byte $81                               ; [18]:
    .byte $41                               ; [19]:
    .byte $ff                               ; [20]:
    .byte $ff                               ; [21]:
    .byte $ff                               ; [22]:
    .byte $81                               ; [23]:
    .byte $41                               ; [24]:
    .byte $ff                               ; [25]:
    .byte $ff                               ; [26]:
    .byte $ff                               ; [27]:
    .byte $81                               ; [28]:
    .byte $41                               ; [29]:
    .byte $ff                               ; [30]:
    .byte $ff                               ; [31]:
    .byte $ff                               ; [32]:
    .byte $81                               ; [33]:
    .byte $41                               ; [34]:
    .byte $ff                               ; [35]:
    .byte $ff                               ; [36]:
    .byte $ff                               ; [37]:
    .byte $81                               ; [38]:
    .byte $41                               ; [39]:
    .byte $ff                               ; [40]:
    .byte $ff                               ; [41]:
    .byte $ff                               ; [42]:
    .byte $81                               ; [43]:
    .byte $41                               ; [44]:
    .byte $ff                               ; [45]:
    .byte $ff                               ; [46]:
    .byte $ff                               ; [47]:
    .byte $81                               ; [48]:
    .byte $41                               ; [49]:
    .byte $ff                               ; [50]:
    .byte $ff                               ; [51]:
    .byte $86                               ; [52]:
    .byte $01                               ; [53]:
    .byte $87                               ; [54]:
    .byte $41                               ; [55]:
    .byte $ff                               ; [56]:
    .byte $ff                               ; [57]:
    .byte $ff                               ; [58]:
    .byte $8f                               ; [59]:
    .byte $41                               ; [60]:
    .byte $ff                               ; [61]:
    .byte $ff                               ; [62]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $88                               ; [4]:
    .byte $01                               ; [5]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $89                               ; [4]:
    .byte $01                               ; [5]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $8a                               ; [4]:
    .byte $01                               ; [5]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $8b                               ; [4]:
    .byte $01                               ; [5]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $8c                               ; [4]:
    .byte $01                               ; [5]:
    .byte $00                               ; [0]:
    .byte $00                               ; [1]:
    .byte $01                               ; [2]:
    .byte $01                               ; [3]:
    .byte $8d                               ; [4]:
    .byte $01                               ; [5]:
    .byte $80                               ; [6]:
    .byte $ff                               ; [7]:
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ad8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ad93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ad9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ada3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adcb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$add3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$addb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ade3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adf3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$adfb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ae9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aea3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aeab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aeb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aebb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aec3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aecb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aed3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aedb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aee3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aeeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aef3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aefb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$af9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afa3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afcb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afd3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afdb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afe3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$afeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$aff3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$affb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b003] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b00b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b013] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b01b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b023] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b02b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b033] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b03b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b043] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b04b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b053] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b05b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b063] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b06b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b073] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b07b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b083] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b08b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b093] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b09b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b0fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b103] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b10b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b113] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b11b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b123] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b12b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b133] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b13b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b143] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b14b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b153] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b15b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b163] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b16b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b173] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b17b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b183] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b18b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b193] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b19b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b1fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b203] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b20b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b213] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b21b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b223] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b22b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b233] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b23b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b243] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b24b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b253] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b25b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b263] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b26b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b273] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b27b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b283] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b28b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b293] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b29b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b2fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b303] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b30b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b313] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b31b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b323] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b32b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b333] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b33b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b343] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b34b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b353] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b35b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b363] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b36b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b373] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b37b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b383] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b38b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b393] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b39b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b3fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b403] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b40b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b413] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b41b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b423] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b42b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b433] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b43b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b443] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b44b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b453] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b45b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b463] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b46b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b473] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b47b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b483] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b48b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b493] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b49b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b4fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b503] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b50b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b513] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b51b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b523] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b52b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b533] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b53b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b543] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b54b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b553] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b55b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b563] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b56b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b573] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b57b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b583] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b58b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b593] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b59b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b5fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b603] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b60b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b613] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b61b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b623] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b62b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b633] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b63b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b643] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b64b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b653] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b65b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b663] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b66b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b673] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b67b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b683] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b68b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b693] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b69b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b6fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b703] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b70b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b713] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b71b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b723] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b72b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b733] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b73b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b743] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b74b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b753] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b75b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b763] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b76b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b773] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b77b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b783] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b78b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b793] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b79b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b7fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b803] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b80b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b813] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b81b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b823] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b82b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b833] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b83b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b843] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b84b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b853] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b85b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b863] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b86b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b873] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b87b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b883] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b88b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b893] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b89b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b8fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b903] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b90b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b913] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b91b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b923] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b92b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b933] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b93b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b943] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b94b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b953] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b95b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b963] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b96b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b973] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b97b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b983] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b98b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b993] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b99b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9a3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9ab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9b3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9bb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9c3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9cb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9d3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9db] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9e3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9eb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9f3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$b9fb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$ba9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$baa3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$baab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bab3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$babb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bac3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bacb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bad3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$badb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bae3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$baeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$baf3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bafb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bb9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bba3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbcb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbd3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbdb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbe3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbf3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bbfb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bc9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bca3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bccb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcd3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcdb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bce3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bceb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcf3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bcfb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bd9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bda3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdcb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdd3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bddb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bde3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdf3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bdfb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$be9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bea3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$beab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$beb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bebb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bec3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$becb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bed3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bedb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bee3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$beeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bef3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$befb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf03] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf0b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf13] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf1b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf23] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf2b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf33] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf3b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf43] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf4b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf53] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf5b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf63] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf6b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf73] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf7b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf83] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf8b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf93] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bf9b] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfa3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfab] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfb3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfbb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfc3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfcb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfd3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfdb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfe3] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bfeb] undefined
    .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff   ; [$bff3] undefined
    .byte $ff,$ff,$ff,$ff,$ff               ; [$bffb] undefined
